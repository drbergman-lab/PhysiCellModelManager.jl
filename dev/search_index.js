var documenterSearchIndex = {"docs":
[{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTHPC/#VCTHPC","page":"VCTHPC","title":"VCTHPC","text":"","category":"section"},{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"Run pcvct on an HPC.","category":"page"},{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"Modules = [pcvct]\nPages = [\"VCTHPC.jl\"]","category":"page"},{"location":"lib/VCTHPC/#pcvct.isRunningOnHPC-Tuple{}","page":"VCTHPC","title":"pcvct.isRunningOnHPC","text":"isRunningOnHPC()\n\nReturn true if the current environment is an HPC environment, false otherwise.\n\nCurrently, this function checks if the sbatch command is available, indicating a SLURM environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTHPC/#pcvct.setJobOptions-Tuple{Dict}","page":"VCTHPC","title":"pcvct.setJobOptions","text":"setJobOptions(options::Dict)\n\nSet the default job options for use with SLURM.\n\nFor any key-value pair in options, the corresponding key in the global sbatch_options dictionary is set to the value. A flag is then added to the sbatch command for each key-value pair in options: --key=value. When running simulations, any values in this dictionary that are Function's will be assumed to be functions of the simulation id.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTHPC/#pcvct.useHPC","page":"VCTHPC","title":"pcvct.useHPC","text":"useHPC([use::Bool=true])\n\nSet the global variable run_on_hpc to use.\n\nExamples\n\nuseHPC() # Set to true so `sbatch` is used for running simulations\nuseHPC(true) # set to true so `sbatch` is used for running simulations\nuseHPC(false) # Set to false so simulations are run locally\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTExport/#VCTExport","page":"VCTExport","title":"VCTExport","text":"","category":"section"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"This file holds the functions for exporting a simulation to a user_project format.","category":"page"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"Modules = [pcvct]\nPages = [\"VCTExport.jl\"]","category":"page"},{"location":"lib/VCTExport/#pcvct.exportSimulation","page":"VCTExport","title":"pcvct.exportSimulation","text":"exportSimulation(simulation_id::Integer[, export_folder::AbstractString])\nexportSimulation(simulation::Simulation[, export_folder::AbstractString])\n\nCreate a user_project folder from a simulation that can be loaded into PhysiCell.\n\nWarning: not all features in drbergman/PhysiCell/latest/release are not supported in MathCancer/PhysiCell.\n\nArguments\n\nsimulation_id::Integer: the id of the simulation to export\nsimulation::Simulation: the simulation to export\nexport_folder::AbstractString: the folder to export the simulation to. Default is the simulation output folder.\n\n\n\n\n\n","category":"function"},{"location":"misc/renaming/#Renaming","page":"Renaming","title":"Renaming","text":"","category":"section"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"Julia packages are supposed to follow certain conventions to be admitted to the General registry. In particular, it must end with .jl, be CamelCase, avoid jargon/acronyms (looking at you pcvct), and be descriptive. We want to clearly tie it to PhysiCell but not make it sound like a replacement for PhysiCell, i.e. not PhysiCell.jl. Here are the options brainstormed thus far:","category":"page"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"PhysiCellVT.jl\nPhysiVT.jl (possible confusion with the OpenVT project where VT = virtual tissue)\nPhysiCellCohorts.jl\nPhysiCellTrials.jl\nPhysiVirtualTrials.jl\nPhysiCellBatch.jl\nPhysiBatch.jl\nPhysiCellDB.jl\nPhysiDB.jl (the clear name for make the database portion a separate package)\nPhysiCell.jl (kinda self-important to assume this will be all the PhysiCell stuff in Julia)","category":"page"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTRunner/#VCTRunner","page":"VCTRunner","title":"VCTRunner","text":"","category":"section"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"Run simulations, monads, samplings, and trials in the pcvct framework.","category":"page"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"Modules = [pcvct]\nPages = [\"VCTRunner.jl\"]","category":"page"},{"location":"lib/VCTRunner/#Base.run-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"Base.run","text":"run(T::AbstractTrial[; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions()])`\n\nRun the given simulation, monad, sampling, or trial.\n\nCall the appropriate functions to run the simulations and return the number of successful simulations. Also print out messages to the console to inform the user about the progress and results of the simulations.\n\nArguments\n\nT::AbstractTrial: The trial, sampling, monad, or simulation to run.\nforce_recompile::Bool=false: If true, forces a recompilation of all files by removing all .o files in the PhysiCell directory.\nprune_options::PruneOptions=PruneOptions(): Options for pruning simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTRunner/#pcvct.collectSimulationTasks-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"pcvct.collectSimulationTasks","text":"collectSimulationTasks(T::AbstractTrial[; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions()])\n\nCollect the simulation tasks for the given trial, sampling, monad, or simulation.\n\nUsed by run to collect the tasks to run.\n\nSee also run.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTRunner/#pcvct.runAbstractTrial-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"pcvct.runAbstractTrial","text":"runAbstractTrial(T::AbstractTrial; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions())\n\nAlias for run, but only with this particular signature. Does not work on Cmd objects as Base.run is built for. Also, does not work with running sensitivity samplings.\n\n\n\n\n\n","category":"method"},{"location":"man/covariations/#CoVariations","page":"CoVariations","title":"CoVariations","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"Sometimes several parameters need to be varied together. A common use case is the varying the base value of a rule and the max response of the rule[1] To handle this scenario, pcvct provides the CoVariation type. A CoVariation is a wrapper for a vector of ElementaryVariation's, and each ElementaryVariation must be of the same type, i.e., all DiscreteVariation's or all DistributedVariation's. The type of a CoVariation is parameterized by the type of ElementaryVariation's it contains. Thus, there are, for now, two types of CoVariation's: CoVariation{DiscreteVariation} and CoVariation{DistributedVariation}.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"[1]: PhysiCell does not allow the base value to exceed the max response. That is, the base response of a decreasing signal cannot be < the max response. Similarly, the base resposne of an increasing signal cannot be > the max response.","category":"page"},{"location":"man/covariations/#CoVariation{DiscreteVariation}","page":"CoVariations","title":"CoVariation{DiscreteVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DiscreteVariation}, each of the DiscreteVariation's must have the same number of values. This may be relaxed in future versions, but the primary use case anticipated is a GridVariation which requires the variations to inform the size of the grid. No restrictions are imposed on how the values of the various variations are linked. pcvct will use values that share an index their respective vectors together.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"base_xml_path = pcvct.customDataPath(\"default\", \"sample\")\nev1 = DiscreteVariation(base_xml_path, [1, 2, 3]) # vary the `sample` custom data for cell type default\nmax_xml_path = [\"hypothesis_ruleset:name:default\", \"behavior:name:custom sample\", \"increasing_signals\", \"max_response\"] # the max response of the rule increasing sample (must be bigger than the base response above)\nev2 = DiscreteVariation(rule_xml_path, [2, 3, 4])\ncovariation = CoVariation(ev1, ev2) # CoVariation([ev1, ev2]) also works","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"It is also not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"# have the phase durations vary by and compensate for each other\nphase_0_xml_path = [pcvct.cyclePath(\"default\"); \"phase_durations\"; \"duration:index:0\"]\nphase_0_durations = [300.0, 400.0] \nphase_1_durations = [200.0, 100.0] # the (mean) duration through these two phases is 500 min\n# input any number of tuples (xml_path, values)\ncovariation = Covariation((phase_0_xml_path, phase_0_durations), (phase_1_xml_path, phase_1_durations))","category":"page"},{"location":"man/covariations/#CoVariation{DistributedVariation}","page":"CoVariations","title":"CoVariation{DistributedVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DistributedVariation}, the conversion of a CDF value, x in 0 1, is done independently for each distribution. That is, in the joint probability space, a CoVariation{DistributedVariation} restricts us to the one-dimensional line connecting mathbf0 to mathbf1. To allow for the parameters to vary inversely with one another, the DistributedVariation type accepts an optional flip::Bool argument (not a keyword argument!). For a distribution dv with dv.flip=true, when a value is requested with a CDF x, pcvct will \"flip\" the CDF to give the value with CDF 1 - x.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"using pcvct\ntiming_1_path = pcvct.userParameterPath(\"event_1_time\")\ntiming_2_path = pcvct.userParameterPath(\"event_2_time\")\ndv1 = UniformDistributedVariation(timing_1_path, 100.0, 200.0)\nflip = true\ndv2 = UniformDistributedVariation(timing_2_path, 100.0, 200.0, flip)\ncovariation = CoVariation(dv1, dv2)\ncdf = 0.1\npcvct._values.(covariation.variations, cdf) # pcvct internal for getting values for an ElementaryVariation\n# output\n2-element Vector{Vector{Float64}}:\n [110.0]\n [190.0]","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"As with CoVariation{DiscreteVariation}, it is not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor. It is not possible to flip a DistributedVariation with this syntax, however.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"apop_xml_path = [pcvct.apoptosisPath(\"default\"); \"death_rate\"]\napop_dist = Uniform(0, 0.001)\ncycle_entry_path = [pcvct.cyclePath(\"default\"); \"phase_transition_rates\"; \"rate:start_index:0\"]\ncycle_dist = Uniform(0.00001, 0.0001)\ncovariation = CoVariation((apop_xml_path, apop_dist), (cycle_entry_path, cycle_dist))","category":"page"},{"location":"man/sensitivity_analysis/#Sensitivity-analysis","page":"Sensitivity Analysis","title":"Sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"pcvct supports some sensitivity analysis workflows. By using pcvct, you will have the opportunity to readily reuse previous simulations to perform and extend sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/#Supported-sensitivity-analysis-methods","page":"Sensitivity Analysis","title":"Supported sensitivity analysis methods","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"pcvct currently supports three sensitivity analysis methods:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Morris One-At-A-Time (MOAT)\nSobol\nRandom Balance Design (RBD)","category":"page"},{"location":"man/sensitivity_analysis/#Morris-One-At-A-Time-(MOAT)","page":"Sensitivity Analysis","title":"Morris One-At-A-Time (MOAT)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The Morris One-At-A-Time (MOAT) method gives an intuitive understanding of the sensitivity of a model to its parameters. What it lacks in theoretical grounding, it makes up for in speed and ease of use. In short, MOAT will sample parameter space at n points. From each point, it will vary each parameter one at a time and record the change in model output. Aggregating these changes, MOAT will quantify the sensitivity of the model to each parameter.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"MOAT uses a Latin Hypercube Sampling (LHS) to sample the parameter space. By default, it will use the centerpoint of each bin as the point to vary each parameter from. To pick a random point within the bin, set add_noise=true.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"MOAT furthermore uses an orthogonal LHS, if possible. If n=k^d for some integer k, then the LHS will be orthogonal. Here, n is the requested number of base points and d is the number of parameters varied. For example, if n=16 and d=4, then k=2 and the LHS will be orthogonal. To force pcvct to NOT use an orthogonal LHS, set orthogonalize=false.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"To use the MOAT method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"MOAT() # will default to n=15\nMOAT(8) # set n=8\nMOAT(8; add_noise=true) # use a random point in the bin, not necessarily the center\nMOAT(8; orthogonalize=false) # do not use an orthogonal LHS (even if d=3, so k=2 would make an orthogonal LHS)","category":"page"},{"location":"man/sensitivity_analysis/#Sobol","page":"Sensitivity Analysis","title":"Sobol","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The Sobol method is a more rigorous sensitivity analysis method, relying on the variance of the model output to quantify sensitivity. It relies on a Sobol sequence, a deterministic sequence of points that are evenly distributed in the unit hypercube. The important main feature of the Sobol sequence is that it is a low-discrepancy sequence, meaning that it fills the space very evenly. Thus, using such sequences can give a very good approximation of certain quantities (like integrals) with fewer points than a random sequence would require. The Sobol sequence is built around powers of 2, and so picking n=2^k (as well as ±1) will give the best results. See SobolVariation for more information on how pcvct will use the Sobol sequence to sample the parameter space and how you can control it.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"If the extremes of your distributions (where the CDF is 0 or 1) are non-physical, e.g., an unbounded normal distribution, then consider using n=2^k-1 to pick a subsequence that does not include the extremes. For example, if you choose n=7, then the Sobol sequence will be [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875]. If you do want to include the extremes, consider using n=2^k+1. For example, if you choose n=9, then the Sobol sequence will be [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1].","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"You can also choose which method is used to compute the first and total order Sobol indices. For first order: the choices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. For total order: the choices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"To use the Sobol method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Sobolʼ(9)\nSobolʼ(9; skip_start=true) # skip to the odd multiples of 1/32 (smallest one with at least 9)","category":"page"},{"location":"man/sensitivity_analysis/#Random-Balance-Design-(RBD)","page":"Sensitivity Analysis","title":"Random Balance Design (RBD)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The RBD method uses a random design matrix (similar to the Sobol method) and uses a Fourier transform (as in in the FAST method) to compute the sensitivity indices. It is much cheaper than Sobol, but only gives first order indices. Choosing n design points, RBD will run n monads. It will then rearrange the n output values so that each parameter in turn is varied along a sinusoid and computes the Fourier transforms to estimate the first order indices. By default, it looks up to the 6th harmonic, but you can control this with the num_harmonics keyword argument.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"By default, pcvct will make use of the Sobol sequence to pick the design points. It is best to pick n such that is differs from a power of 2 by at most 1, e.g. 7, 8, or 9. In this case, pcvct will actually use a half-period of a sinusoid when converting the design points into CDF space. Otherwise, pcvct will use random permuations of n uniformly spaced points in each parameter dimension and will use a full period of a sinusoid when converting the design points into CDF space.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"To use the RBD method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"RBD(9) # will use a Sobol sequence with elements chosen from 0:0.125:1\nRBD(32; use_sobol=false) # opt out of using the Sobol sequence\nRBD(22) # will use the first 22 elements of the Sobol sequence, including 0\nRBD(32; num_harmonics=4) # will look up to the 4th harmonic, instead of the default 6th","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"If you choose n=2^k - 1 or n=2^k + 1, then you will be well-positioned to increment k by one and rerun the RBD method to get more accurate results. The reason: pcvct will start from the start of the Sobol sequence to cover these n points, meaning runs will not need to be repeated. If n=2^k, then pcvct will choose the n odd multiples of 1/2^(k+1) from the Sobol sequence, which will not be used if k is incremented.","category":"page"},{"location":"man/sensitivity_analysis/#Setting-up-a-sensitivity-analysis","page":"Sensitivity Analysis","title":"Setting up a sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/#Simulation-inputs","page":"Sensitivity Analysis","title":"Simulation inputs","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Having chosen a sensitivity analysis method, you must now choose the same set of inputs as required for a sampling. You will need:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"inputs::InputFolders containing the data/inputs/ folder info defining your model\nn_replicates::Integer for the number of replicates to run at each parameter vector to get average behavior\nevs::Vector{<:ElementaryVariation} to define the parameters to conduct the sensitivity analysis on and their ranges/distributions","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Unlike for (most) trials, the ElementaryVariation's you will want here are likely to be DistributedVariation's to allow for a continuum of parameter values to be tested. pcvct offers UniformDistributedVariation and NormalDistributedVariation as convenience functions to create these DistributedVariation's. You can also use any d::Distribution to create a DistributedVariation directly:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"dv = DistributedVariation(xml_path, d)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Currently, pcvct does not support defining relationships between parameters in any context. CoVariation's are a work-in-progress and will be a sibling of ElementaryVariation in the type tree.","category":"page"},{"location":"man/sensitivity_analysis/#Sensitivity-functions","page":"Sensitivity Analysis","title":"Sensitivity functions","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"At the time of starting the sensitivity analysis, you can include any number of sensitivity functions to compute. They must take a single argument, the simulation ID (an Int64) and return a Number (or any type that Statistics.mean will accept a Vector of). For example, finalPopulationCount returns a dictionary of the final population counts of each cell type from a simulation ID. So, if you want to know the sensitivity of the final population count of cell type \"cancer\", you could define a function like:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"f(sim_id) = finalPopulationCount(sim_id)[\"cancer\"]","category":"page"},{"location":"man/sensitivity_analysis/#Running-the-analysis","page":"Sensitivity Analysis","title":"Running the analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Putting it all together, you can run this analysis:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"config_folder = \"default\"\ncustom_codes = \"default\"\ninputs = InputFolders(config_folder, custom_codes)\nn_replicates = 3\nevs = [NormalDistributedVariation([pcvct.apoptosisPath(\"cancer\"); \"rate\"], 1e-3, 1e-4; lb=0),\n       UniformDistributedVariation([pcvct.cyclePath(\"cancer\"); \"phase_durations\"; \"duration:index:0\"], 720, 2880)]\nmethod = MOAT(15)\nsensitivity_sampling = run(method, inputs, n_replicates, evs)","category":"page"},{"location":"man/sensitivity_analysis/#Post-processing","page":"Sensitivity Analysis","title":"Post-processing","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The object sensitivity_sampling is of type pcvct.GSASampling, meaning you can use pcvct.calculateGSA! to compute sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"f = simulation_id -> finalPopulationCount(simulation_id)[\"default\"] # count the final population of cell type \"default\"\ncalculateGSA!(sensitivity_sampling, f)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"These results are stored in a Dict in the sensitivity_sampling object:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"println(sensitivity_sampling.results[f])","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The exact concrete type of sensitivity_sampling will depend on the method used. This, in turn, is used by calculateGSA! to determine how to compute the sensitivity indices.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Likewise, the method will determine how the sensitivity scheme is saved After running the simulations, pcvct will print a CSV in the data/outputs/sampling/$(sampling) folder named based on the method. This can later be used to reload the GSASampling and continue doing analysis. Currently, this requires some ingenuity by the user. A future version of pcvct could provide convenience functions for simplifying this.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"using CSV, DataFrames\nsampling_id = 1 # for example\nmonad_ids_df = CSV.read(\"data/outputs/samplings/$(sampling_id)/moat_scheme.csv\", DataFrame) # if this was a MOAT scheme\nmoat_sampling = MOATSampling(Sampling(sampling_id), monad_ids_df, Dict{Function, GlobalSensitivity.MorrisResult}())","category":"page"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTImport/#VCTImport","page":"VCTImport","title":"VCTImport","text":"","category":"section"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"Import a project from the standard PhysiCell format into the pcvct format.","category":"page"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"Modules = [pcvct]\nPages = [\"VCTImport.jl\"]","category":"page"},{"location":"lib/VCTImport/#pcvct.importProject","page":"VCTImport","title":"pcvct.importProject","text":"importProject(path_to_project::AbstractString[, src=Dict(), dest=Dict(); extreme_caution::Bool=false])\n\nImport a project from the structured in the format of PhysiCell sample projects and user projects into the pcvct structure.\n\nArguments\n\npath_to_project::AbstractString: Path to the project to import. Relative paths are resolved from the current working directory where Julia was launched.\nsrc::Dict: Dictionary of the project sources to import. If absent, tries to use the default names.\n\nThe following keys are recognized: config, main, makefile, custom_modules, rulesets_collection, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\ndest::Dict: Dictionary of the inputs folders to create in the pcvct structure. If absent, taken from the project name.\n\nThe following keys are recognized: config, custom_code, rules, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\nextreme_caution::Bool: If true, will ask for confirmation before deleting any folders created during the import process. Care has been taken to ensure this is unnecessary. Provided for users who want to be extra cautious.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTCreation/#VCTCreation","page":"VCTCreation","title":"VCTCreation","text":"","category":"section"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"Create a new pcvct project.","category":"page"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"Modules = [pcvct]\nPages = [\"VCTCreation.jl\"]","category":"page"},{"location":"lib/VCTCreation/#pcvct.createProject","page":"VCTCreation","title":"pcvct.createProject","text":"createProject(project_dir::String=\".\"; clone_physicell::Bool=true, template_as_default::Bool=true, terse::Bool=false)\n\nCreate a new pcvct project structure.\n\nCreates a new project directory at project_dir with the following structure:\n\nproject_dir\n├── data\n├── PhysiCell # The latest release from https://github.com/drbergman/PhysiCell\n└── VCT\n\ndata is populated with the standard structure. PhysiCell is a copy of PhysiCell. VCT contains a generated GenerateData.jl file.\n\nArguments\n\nproject_dir::String=\".\": The directory in which to create the project. Relative paths are resolved from the current working directory where Julia was launched.\nclone_physicell::Bool=true: Whether to clone the PhysiCell repository. If false, the latest release will be downloaded. Recommended to set to true so pcvct will be able to track changes to the PhysiCell repository.\ntemplate_as_default::Bool=true: Whether to set up the project with the template files as the default. If false, the project will be set up with an empty structure.\nterse::Bool=false: Whether to generate a terse GenerateData.jl file. If true, the file will be generated without comments and explanations.\n\nNote\n\nThe names of the data and PhysiCell directories are fixed and cannot be changed. Their relative locations should not be changed without updating the GenerateData.jl file. The name of the VCT file and the GenerateData.jl are just by convention and can be changed.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTICCell/#VCTICCell","page":"VCTICCell","title":"VCTICCell","text":"","category":"section"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"Functionality for the pcvct-specific XML-based cell initial conditions.","category":"page"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"Modules = [pcvct]\nPages = [\"VCTICCell.jl\"]","category":"page"},{"location":"lib/VCTICCell/#pcvct.createICCellXMLTemplate-Tuple{String}","page":"VCTICCell","title":"pcvct.createICCellXMLTemplate","text":"createICCellXMLTemplate(folder::String)\n\nCreate folder data/inputs/ics/cells/folder and create a template XML file for IC cells.\n\npcvct introduces a new way to initialize cells in a simulation, wholly contained within pcvct. It will not work in PhysiCell! This function creates a template XML file for IC cells, showing all the current functionality of this initialization scheme. It uses the cell type \"default\". Create ICs for more cell types by copying the cell_patches element. The ID attribute in patch elements is there exactly to allow variations to target specific patches. Manually maintain these or you will not be able to vary specific patches effectively.\n\nEach time a simulation is run that is using a cells.xml file, a new CSV file will be created, drawing randomly from the patches defined in the XML file. These will all be stored with data/inputs/ics/cells/folder/ic_cell_variations as ic_cell_variation_#_s#.csv where the first # is the variation ID associated with variation on the XML file and the second # is the simulation ID. Importantly, no two simulations will use the same CSV file.\n\n\n\n\n\n","category":"method"},{"location":"man/physicell_studio/#Using-PhysiCell-Studio","page":"PhysiCell Studio","title":"Using PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"See PhysiCell-Studio.","category":"page"},{"location":"man/physicell_studio/#Setting-paths","page":"PhysiCell Studio","title":"Setting paths","text":"","category":"section"},{"location":"man/physicell_studio/#Environment-variables","page":"PhysiCell Studio","title":"Environment variables","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"You must first inform pcvct where your desired python executable is and the PhysiCell Studio folder. The recommended way to do this is to add the following two lines to your shell environment file (e.g. ~/.bashrc or ~/.zshenv):","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"export PCVCT_PYTHON_PATH=\"/usr/bin/python3\"\nexport PCVCT_STUDIO_PATH=\"/home/user/PhysiCell-Studio\"","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If your python executable is on your PATH, you can set PCVCT_PYTHON_PATH=\"python3\", for example.","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"After making these changes, make sure to source the file to apply the changes:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"$ source ~/.bashrc","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"Or open a new terminal window.","category":"page"},{"location":"man/physicell_studio/#Using-keyword-arguments","page":"PhysiCell Studio","title":"Using keyword arguments","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you prefer not to set these environment variables, you can pass the paths as keyword arguments to the runStudio function. It will remember these settings during the session, so you only need to pass them once. See below for the function signature.","category":"page"},{"location":"man/physicell_studio/#Launching-PhysiCell-Studio","page":"PhysiCell Studio","title":"Launching PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"First, launch julia and make sure the project is initialized by running:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"# if you used createProject(), these are the first two lines of GenerateData.jl\nusing pcvct\ninitializeVCT(path_to_physicell, path_to_data)","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"As soon as the simulation has begun (so that its PhysiCell-generated output folder is created and populated), you can launch PhysiCell Studio. If you set the environment variables, you can run the following command for a simulation with id sim_id::Integer:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id)","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you did not set the environment variables, you can run the following command:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id; python_path=path_to_python, studio_path=path_to_studio)","category":"page"},{"location":"man/physicell_studio/#Editing-in-PhysiCell-Studio","page":"PhysiCell Studio","title":"Editing in PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"When you run the runStudio function, PhysiCell Studio will open with the simulation you specified using temporary files for the configuration and rules. Any edits to these in studio will be lost when the studio is closed. Remember: this is the output of a simulation that already ran. Use the File > Save as dropdown to save the configuration file. Use the Rules tab to save the rules file. Note: the recent changes in PhysiCell 1.14.1 copying over the initial conditions files are not yet supported by this. See Known limitations for more information.","category":"page"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTSensitivity/#VCTSensitivity","page":"VCTSensitivity","title":"VCTSensitivity","text":"","category":"section"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"Run sensitivity analyses on a model.","category":"page"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"Modules = [pcvct]\nPages = [\"VCTSensitivity.jl\"]","category":"page"},{"location":"lib/VCTSensitivity/#pcvct.GSASampling","page":"VCTSensitivity","title":"pcvct.GSASampling","text":"GSASampling\n\nStore the information that comes out of a global sensitivity analysis method.\n\nSubtypes\n\nMOATSampling\nSobolSampling\nRBDSampling\n\nMethods\n\ngetMonadIDDataFrame(gsa_sampling::GSASampling): get the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\ngetSimulationIDs(gsa_sampling::GSASampling): get the simulation IDs that were run in the sensitivity analysis.\nmethodString(gsa_sampling::GSASampling): get the string representation of the method used in the sensitivity analysis.\nsensitivityResults!(gsa_sampling::GSASampling, functions::Vector{<:Function}): calculate the sensitivity indices for the given functions.\ncalculateGSA!(gsa_sampling::GSASampling, f::Vector{<:Function}): calculate the sensitivity indices for the given function(s).\nevaluateFunctionOnSampling(gsa_sampling::GSASampling, f::Function): evaluate the function on the sampling and return the results.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.MOAT","page":"VCTSensitivity","title":"pcvct.MOAT","text":"MOAT\n\nStore the information necessary to run a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nlhs_variation::LHSVariation: the Latin Hypercube Sampling (LHS) variation to use for the MOAT. See LHSVariation.\n\nExamples\n\nNote: any keyword arguments in the MOAT constructor are passed to LHSVariation.\n\nMOAT() # default to 15 base points\nMOAT(10) # 10 base points\nMOAT(10; add_noise=true) # do not restrict the base points to the center of their cells\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.MOATSampling","page":"VCTSensitivity","title":"pcvct.MOATSampling","text":"MOATSampling\n\nStore the information that comes out of a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.MorrisResult}: the results of the sensitivity analysis for each function.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.RBD","page":"VCTSensitivity","title":"pcvct.RBD","text":"RBD\n\nStore the information necessary to run a Random Balance Design (RBD) global sensitivity analysis.\n\nBy default, RBD will use the Sobol' sequence to sample the parameter space. See below for how to turn this off. Currently, users cannot control the Sobolʼ sequence used in RBD to the same degree it can be controlled in Sobolʼ. Open an Issue if you would like this feature.\n\nFields\n\nrbd_variation::RBDVariation: the RBD variation to use for the RBD analysis. See RBDVariation.\nnum_harmonics::Int: the number of harmonics to use from the Fourier transform for the RBD analysis.\n\nExamples\n\nNote: any keyword arguments in the RBD constructor are passed to RBDVariation, except for the num_harmonics keyword argument. If num_harmonics is not specified, it defaults to 6.\n\nRBD(15) # 15 points from the Sobol' sequence\nRBD(15; num_harmonics=10) # use 10 harmonics\nRBD(15; use_sobol=false) # opt out of using the Sobol' sequence, instead using a random sequence in each dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.RBDSampling","page":"VCTSensitivity","title":"pcvct.RBDSampling","text":"RBDSampling\n\nStore the information that comes out of a Random Balance Design (RBD) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nnum_harmonics::Int: the number of harmonics used in the Fourier transform.\nnum_cycles::Union{Int, Rational}: the number of cycles used for each parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.SobolSampling","page":"VCTSensitivity","title":"pcvct.SobolSampling","text":"SobolSampling\n\nStore the information that comes out of a Sobol' global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods used for calculating the first and total order indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.Sobolʼ","page":"VCTSensitivity","title":"pcvct.Sobolʼ","text":"Sobolʼ\n\nStore the information necessary to run a Sobol' global sensitivity analysis as well as how to extract the first and total order indices.\n\nThe rasp symbol is used to avoid conflict with the Sobol module. To type it in VS Code, use \\rasp and then press tab. The methods available for the first order indices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. The methods available for the total order indices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.\n\nFields\n\nsobol_variation::SobolVariation: the Sobol' variation to use for the Sobol' analysis. See SobolVariation.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods to use for calculating the first and total order indices.\n\nExamples\n\nNote: any keyword arguments in the Sobolʼ constructor are passed to SobolVariation, except for the sobol_index_methods keyword argument. Do not use the n_matrices keyword argument in the SobolVariation constructor as it is set to 2 as required for Sobol' analysis.\n\nSobolʼ(15) # 15 points from the Sobol' sequence\nSobolʼ(15; sobol_index_methods=(first_order=:Jansen1999, total_order=:Jansen1999)) # use Jansen, 1999 for both first and total order indices\nSobolʼ(15; randomization=NoRand())` # use the default Sobol' sequence with no randomization. See GlobalSensitivity.jl for more options.\nSobolʼ(15; skip_start=true) # force the Sobol' sequence to skip to the lowest denominator in the sequence that can hold 15 points, i.e., choose from [1/32, 3/32, 5/32, ..., 31/32]\nSobolʼ(15; skip_start=false) # force the Sobol' sequence to start at the beginning, i.e. [0, 0.5, 0.25, 0.75, ...]\nSobolʼ(15; include_one=true) # force the Sobol' sequence to include 1 in the sequence\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#Base.run-Tuple{pcvct.GSAMethod, Integer, InputFolders, Union{pcvct.AbstractVariation, Vector{<:pcvct.AbstractVariation}}}","page":"VCTSensitivity","title":"Base.run","text":"run(method::GSAMethod, args...; functions::Vector{<:Function}=Function[], kwargs...)\n\nRun a global sensitivity analysis method on the given arguments.\n\nArguments\n\nmethod::GSAMethod: the method to run. Options are MOAT, Sobolʼ, and RBD.\nn_replicates::Int: the number of replicates to run for each monad, i.e., at each sampled parameter vector.\ninputs::InputFolders: the input folders shared across all simuations to run.\navs::Vector{<:AbstractVariation}: the elementary variations to sample. These can be either DiscreteVariation's or DistributedVariation's.\n\nAlternatively, the third argument, inputs, can be replaced with a reference::AbstractMonad, i.e., a simulation or monad to be the reference. This should be preferred to setting reference variation IDs manually, i.e., if not using the base files in the input folders.\n\nKeyword Arguments\n\nThe three reference_ keyword arguments are only compatible when the third argument is of type InputFolders.\n\nreference_config_variation_id::Int=0: the reference config variation ID\nreference_rulesets_variation_id::Int=0: the reference rulesets variation ID\nreference_ic_cell_variation_id::Int=0: the reference IC cell variation ID\nignore_indices::Vector{Int}=[]: indices into avs to ignore when perturbing the parameters. Only used for Sobolʼ. See Sobolʼ for a use case.\nforce_recompile::Bool=false: whether to force recompilation of the simulation code\nprune_options::PruneOptions=PruneOptions(): the options for pruning the simulation results\nuse_previous::Bool=true: whether to use previous simulation results if they exist\nfunctions::Vector{<:Function}=Function[]: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTSensitivity/#pcvct.calculateGSA!-Tuple{pcvct.GSASampling, Vector{<:Function}}","page":"VCTSensitivity","title":"pcvct.calculateGSA!","text":"calculateGSA!(gsa_sampling::GSASampling, functions::Vector{<:Function})\n\nCalculate the sensitivity indices for the given functions.\n\nThis function is also used to compute the sensitivity indices for a single function:\n\ncalculateGSA!(gsa_sampling, f)\n\nArguments\n\ngsa_sampling::GSASampling: the sensitivity analysis to calculate the indices for.\nfunctions::Vector{<:Function}: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTSensitivity/#pcvct.variationsToMonads-Tuple{InputFolders, Matrix{Int64}, Matrix{Int64}, Matrix{Int64}, Bool}","page":"VCTSensitivity","title":"pcvct.variationsToMonads","text":"variationsToMonads(inputs::InputFolders, all_config_variation_ids::Matrix{Int}, all_rulesets_variation_ids::Matrix{Int}, all_ic_cell_variation_ids::Matrix{Int}, use_previous::Bool)\n\nReturn a dictionary of monads and a matrix of monad IDs based on the given variation IDs.\n\nThe three matrix inputs together define a single matrix of variation IDs. This information, together with the inputs, identifies the monads to be used. The use_previous flag determines whether to use previous simulations, if they exist.\n\nReturns\n\nmonad_dict::Dict{VariationIDs, Monad}: a dictionary of the monads to be used without duplicates.\nmonad_ids::Matrix{Int}: a matrix of the monad IDs to be used. Matches the shape of the input IDs matrices.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTConfiguration/#VCTConfiguration","page":"VCTConfiguration","title":"VCTConfiguration","text":"","category":"section"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Interface with the configuration file necessary for PhysiCell simulations.","category":"page"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Provide functionality for accessing and modifying elements in any XML, including the PhysiCell configuration file, XML rules file, and XML IC cell file.","category":"page"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Modules = [pcvct]\nPages = [\"VCTConfiguration.jl\"]","category":"page"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTLoader/#VCTLoader","page":"VCTLoader","title":"VCTLoader","text":"","category":"section"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"Load PhysiCell data into useful forms for downstream analysis.","category":"page"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"Modules = [pcvct]\nPages = [\"VCTLoader.jl\"]","category":"page"},{"location":"lib/VCTLoader/#pcvct.PhysiCellSequence","page":"VCTLoader","title":"pcvct.PhysiCellSequence","text":"PhysiCellSequence\n\nA sequence of PhysiCell snapshots.\n\nFields\n\nfolder::String: The folder containing the PhysiCell simulation output.\nsnapshots::Vector{PhysiCellSnapshot}: A vector of PhysiCell snapshots.\ncell_type_to_name_dict::Dict{Int, String}: A dictionary mapping cell type IDs to cell type names.\nsubstrate_names::Vector{String}: A vector of substrate names.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTLoader/#pcvct.PhysiCellSnapshot","page":"VCTLoader","title":"pcvct.PhysiCellSnapshot","text":"PhysiCellSnapshot\n\nA single snapshot of a PhysiCell simulation.\n\nThe cells, substrates, and mesh fields may remain empty until they are needed for analysis.\n\nFields\n\nfolder::String: The folder containing the PhysiCell simulation output.\nindex::Union{Int, Symbol}: The index of the snapshot. Can be an integer or a symbol (:initial or :final).\ntime::Float64: The time of the snapshot.\ncells::DataFrame: A DataFrame containing cell data.\nsubstrates::DataFrame: A DataFrame containing substrate data.\nmesh::Dict{String, Vector{Float64}}: A dictionary containing mesh data.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTLoader/#pcvct.computeMeanSpeed-Tuple{Integer}","page":"VCTLoader","title":"pcvct.computeMeanSpeed","text":"computeMeanSpeed(simulation_id::Integer[; direction=:any])\n\nReturn dictionaries containing the mean speed, total distance traveled, and total time spent for each cell type in the PhysiCell simulation.\n\nThe time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first.\n\nTo account for cells that may change cell type during the simulation, the dictionaries returned are keyed by cell type. So, a dictionary with key \"A\" and value 2.0 indicates that the mean speed of this cell while it was of type \"A\" is 2.0.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation.\ndirection::Symbol: The direction to compute the mean speed. Can be :x, :y, :z, or :any (default). If :x, for example, the mean speed is calculated using only the x component of the cell's movement.\n\nReturns\n\nmean_speed_dicts::Vector{Dict{String,Float64}}: A vector of dictionaries where each dictionary is specific to a single cell. The key is the cell type and the value is the mean speed of that cell.\ndistance_dicts::Vector{Dict{String,Float64}}: A vector of dictionaries where each dictionary is specific to a single cell. The key is the cell type and the value is the total distance traveled by that cell.\ntime_dicts::Vector{Dict{String,Float64}}: A vector of dictionaries where each dictionary is specific to a single cell. The key is the cell type and the value is the total time in the simulation for that cell.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTLoader/#pcvct.getCellDataSequence-Tuple{pcvct.PhysiCellSequence, Vector{String}}","page":"VCTLoader","title":"pcvct.getCellDataSequence","text":"getCellDataSequence(sequence::PhysiCellSequence, labels::Vector{String}; include_dead::Bool=false, include_cell_type::Bool=false)\n\nReturn a dictionary where the keys are cell IDs from the PhysiCell simulation and the values are NamedTuples containing the time and the values of the specified labels for that cell. In the case of a label that has multiple columns, such as position, the values are concatenated into a length(snapshots) x number of columns array.\n\nExamples\n\ndata = getCellDataSequence(sequence, [\"position\", \"elapsed_time_in_phase\"]; include_dead=true, include_cell_type=true)\ndata[1] # the first cell's data\ndata[1].position # an Nx3 array of the cell's position over time\ndata[1].elapsed_time_in_phase # an Nx1 array of the cell's elapsed time in phase over time\ndata[1].cell_type_name # the cell type name of the first cell\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTLoader/#pcvct.getCellPositionSequence-Tuple{pcvct.PhysiCellSequence}","page":"VCTLoader","title":"pcvct.getCellPositionSequence","text":"getCellPositionSequence(sequence::PhysiCellSequence; include_dead::Bool=false, include_cell_type::Bool=false)\n\nReturn a dictionary where the keys are cell IDs from the PhysiCell simulation and the values are NamedTuples containing the time and the position of the cell.\n\nThis is a convenience function for getCellDataSequence(sequence, \"position\"; include_dead=include_dead, include_cell_type=include_cell_type).\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTMovie/#VCTMovie","page":"VCTMovie","title":"VCTMovie","text":"","category":"section"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"Make movies for simulations in the database.","category":"page"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"Modules = [pcvct]\nPages = [\"VCTMovie.jl\"]","category":"page"},{"location":"lib/VCTMovie/#pcvct.makeMovie-Tuple{pcvct.AbstractTrial}","page":"VCTMovie","title":"pcvct.makeMovie","text":"makeMovie(T::AbstractTrial)\n\nMake movies for all simulations in T, a simulation, monad, sampling, or trial.\n\nUses the PhysiCell Makefile to generate the movies. Deletes the JPEG files after the movie is generated.    \n\nPassing a single simulation ID into makeMovie will generate a movie for that simulation.\n\nExamples\n\nmakeMovie(123) # make a movie for simulation 123\nmakeMovie(sampling) # make movies for all simulations in sampling\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTVariations/#VCTVariations","page":"VCTVariations","title":"VCTVariations","text":"","category":"section"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"Vary parameters of the project.","category":"page"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"Modules = [pcvct]\nPages = [\"VCTVariations.jl\"]","category":"page"},{"location":"lib/VCTVariations/#pcvct.CoVariation","page":"VCTVariations","title":"pcvct.CoVariation","text":"CoVariation\n\nA co-variation of one or more variations.\n\nFields\n\nvariations::Vector{T}: The variations that make up the co-variation.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.DiscreteVariation","page":"VCTVariations","title":"pcvct.DiscreteVariation","text":"DiscreteVariation\n\nThe location, target, and values of a discrete variation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets, or :ic_cell. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\nvalues::Vector{T}: The values of the variation. The values are the possible values that the target can take on.\n\nA singleton value can be passed in place of values for convenience.\n\nExamples\n\njulia> dv = DiscreteVariation([\"overall\", \"max_time\"], [1440.0, 2880.0])\nDiscreteVariation{Float64}(:config, pcvct.XMLPath([\"overall\", \"max_time\"]), [1440.0, 2880.0])\n\nxml_path = [\"hypothesis_ruleset:name:default\",\"behavior:name:cycle entry\",\"decreasing_signals\",\"max_response\"]\nDiscreteVariation(xml_path, 0)\n# output\nDiscreteVariation{Int64}(:rulesets, pcvct.XMLPath([\"hypothesis_ruleset:name:default\", \"behavior:name:cycle entry\", \"decreasing_signals\", \"max_response\"]), [0])\n\nxml_path = [\"cell_patches:name:default\",\"patch_collection:type:disc\",\"patch:ID:1\",\"x0\"]\nDiscreteVariation(xml_path, [0.0, 100.0])\n# output\nDiscreteVariation{Float64}(:ic_cell, pcvct.XMLPath([\"cell_patches:name:default\", \"patch_collection:type:disc\", \"patch:ID:1\", \"x0\"]), [0.0, 100.0])\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.DistributedVariation","page":"VCTVariations","title":"pcvct.DistributedVariation","text":"DistributedVariation\n\nThe location, target, and distribution of a distributed variation.\n\nAnalagousy to DiscreteVariation, instances of DistributedVariation can be initialized with a target (XML path) and a distribution (a distribution from the Distributions package). Alternatively, users can use the UniformDistributedVariation and NormalDistributedVariation functions to create instances of DistributedVariation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets, or :ic_cell. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\ndistribution::Distribution: The distribution of the variation.\nflip::Bool=false: Whether to flip the distribution, i.e., when asked for the iCDF of x, return the iCDF of 1-x. Useful for CoVariation's.\n\nExamples\n\nusing Distributions\nd = Uniform(1, 2)\nDistributedVariation([pcvct.apoptosisPath(\"default\"); \"death_rate\"], d)\n# output\nDistributedVariation(:config, pcvct.XMLPath([\"cell_definitions\", \"cell_definition:name:default\", \"phenotype\", \"death\", \"model:code:100\", \"death_rate\"]), Distributions.Uniform{Float64}(a=1.0, b=2.0), false)\n\n```jldoctest using Distributions d = Uniform(1, 2) flip = true # the cdf on this variation will decrease from 1 to 0 as the value increases from 1 to 2 DistributedVariation([pcvct.necrosisPath(\"default\"); \"death_rate\"], d, flip)\n\noutput\n\nDistributedVariation(:config, pcvct.XMLPath([\"celldefinitions\", \"celldefinition:name:default\", \"phenotype\", \"death\", \"model:code:101\", \"death_rate\"]), Distributions.Uniform{Float64}(a=1.0, b=2.0), true)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.GridVariation","page":"VCTVariations","title":"pcvct.GridVariation","text":"GridVariation\n\nA variation method that creates a grid of all possible combinations of the values of the variations.\n\nExamples\n\njulia> GridVariation() # the only method for GridVariation\nGridVariation()\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.LHSVariation","page":"VCTVariations","title":"pcvct.LHSVariation","text":"LHSVariation\n\nA variation method that creates a Latin Hypercube Sample of the values of the variations.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nExamples\n\njulia> LHSVariation(4) # set `n` and use default values for the rest\nLHSVariation(4, false, Random.TaskLocalRNG(), true)\n\nusing Random\nLHSVariation(; n=4, add_noise=true, rng=MersenneTwister(1234), orthogonalize=false)\n# output\nLHSVariation(4, true, MersenneTwister(1234), false)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.RBDVariation","page":"VCTVariations","title":"pcvct.RBDVariation","text":"RBDVariation\n\nA variation method that creates a Random Balance Design of the values of the variations.\n\nThis creates n sample points where the values in each dimension are uniformly distributed. By default, this will use Sobol sequences (see SobolVariation) to create the sample points. If use_sobol is false, it will use random permutations of uniformly spaced points for each dimension.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\nuse_sobol::Bool=true: Whether to use Sobol sequences to create the sample points.\n\nDo not set these next two fields unless you know what you are doing. Let pcvct compute them.\n\npow2_diff::Union{Missing, Int}=missing: The difference between n and the nearest power of 2. Missing means pcvct will compute it if using Sobol sequences.\nnum_cycles::Union{Missing, Int, Rational}=missing: The number of cycles to use in the Sobol sequence. Missing means pcvct will set it.\n\nExamples\n\njulia> pcvct.RBDVariation(4) # set `n` and use default values for the rest\npcvct.RBDVariation(4, Random.TaskLocalRNG(), true, 0, 1//2)\n\njulia> pcvct.RBDVariation(4; use_sobol=false) # use random permutations of uniformly spaced points\npcvct.RBDVariation(4, Random.TaskLocalRNG(), false, missing, 1//1)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.SobolVariation","page":"VCTVariations","title":"pcvct.SobolVariation","text":"SobolVariation\n\nA variation method that creates a Sobol sequence of the values of the variations.\n\nSee generateSobolCDFs for more information on how the Sobol sequence is generated based on n and the other fields.\n\nSee the GlobalSensitivity.jl package for more information on RandomizationMethod's to use.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence.\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nExamples\n\njulia> SobolVariation(9) # set `n` and use default values for the rest; will use [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1]\nSobolVariation(9, 1, QuasiMonteCarlo.NoRand(), missing, missing)\n\njulia> SobolVariation(15; skip_start=true) # use [0.5, 0.25, 0.75, ..., 1/16, 3/16, ..., 15/16]\nSobolVariation(15, 1, QuasiMonteCarlo.NoRand(), true, missing)\n\njulia> SobolVariation(4; include_one=true) # use [0, 0.5, 1] and one of [0.25, 0.75]\nSobolVariation(4, 1, QuasiMonteCarlo.NoRand(), missing, true)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.XMLPath","page":"VCTVariations","title":"pcvct.XMLPath","text":"XMLPath\n\nHold the XML path as a vector of strings.\n\nPhysiCell uses a : in names for signals/behaviors from cell custom data. For example, custom:sample is the default way to represent the sample custom data in a PhysiCell rule. pcvct uses : to indicate an attribute in an XML path and thus splits on : when looking for attribute values. To avoid this conflict, pcvct will internally replace custom:<name> and custom: <name> with custom <name>. Users should never have to think about this. Any pcvct function that uses XML paths will automatically handle this replacement.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.NormalDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"VCTVariations","title":"pcvct.NormalDistributedVariation","text":"NormalDistributedVariation(xml_path::Vector{<:AbstractString}, mu::T, sigma::T; lb::Real=-Inf, ub::Real=Inf) where {T<:Real}\n\nCreate a (possibly truncated) distributed variation with a normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.UniformDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"VCTVariations","title":"pcvct.UniformDistributedVariation","text":"UniformDistributedVariation(xml_path::Vector{<:AbstractString}, lb::T, ub::T) where {T<:Real}\n\nCreate a distributed variation with a uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addAttackRateVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"VCTVariations","title":"pcvct.addAttackRateVariationDimension!","text":"addAttackRateVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, target_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for the attack rate of a cell type against a target cell type.\n\nExamples:\n\naddAttackRateVariationDimension!(evs, \"immune\", \"cancer\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addCustomDataVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"VCTVariations","title":"pcvct.addCustomDataVariationDimension!","text":"addCustomDataVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, field_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for a custom data field of a cell type.\n\nExamples:\n\naddCustomDataVariationDimension!(evs, \"immune\", \"perforin\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addDomainVariationDimension!-Tuple{Vector{<:ElementaryVariation}, NamedTuple}","page":"VCTVariations","title":"pcvct.addDomainVariationDimension!","text":"addDomainVariationDimension!(evs::Vector{<:ElementaryVariation}, domain::NamedTuple)\n\nPushes variations onto evs for each domain boundary named in domain.\n\nThe names in domain can be flexibly named as long as they contain either min or max and one of x, y, or z (other than the the x in max). It is not required to include all three dimensions and their boundaries. The values for each boundary can be a single value or a vector of values.\n\nExamples:\n\n``` evs = ElementaryVariation[] addDomainVariationDimension!(evs, (xmin=-78, xmax=78, miny=-30, maxy=[30, 60], z_max=10))\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.generateLHSCDFs-Tuple{Int64, Int64}","page":"VCTVariations","title":"pcvct.generateLHSCDFs","text":"generateLHSCDFs(n::Int, d::Int[; add_noise::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG, orthogonalize::Bool=true])\n\nGenerate a Latin Hypercube Sample of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples, if possible. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nReturns\n\ncdfs::Matrix{Float64}: The CDFs for the samples. Each row is a sample and each column is a dimension (corresponding to a feature).\n\nExamples\n\ncdfs = pcvct.generateLHSCDFs(4, 2)\nsize(cdfs)\n# output\n(4, 2)\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.generateSobolCDFs-Tuple{Int64, Int64}","page":"VCTVariations","title":"pcvct.generateSobolCDFs","text":"generateSobolCDFs(n::Int, d::Int[; n_matrices::Int=1, randomization::RandomizationMethod=NoRand(), skip_start::Union{Missing, Bool, Int}=missing, include_one::Union{Missing, Bool}=missing)\n\nGenerate n_matrices Sobol sequences of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nThe subsequence of the Sobol sequence is chosen based on the value of n and the value of include_one. If it is one less than a power of 2, e.g. n=7, skip 0 and start from 0.5. Otherwise, it will always start from 0. If it is one more than a power of 2, e.g. n=9, include 1 (unless include_one is false).\n\nThe skip_start field can be used to control this by skipping the start of the sequence. If skip_start is true, skip to the smallest consecutive subsequence with the same denominator that has at least n elements. If skip_start is false, start from 0. If skip_start is an integer, skip that many elements in the sequence, .e.g., skip_start=1 skips 0 and starts at 0.5.\n\nIf you want to include 1 in the sequence, set include_one to true. If you want to exlude 1 (in the case of n=9, e.g.), set include_one to false.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence (effectively, the dimension of the sample is d x n_matrices).\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence. See GlobalSensitivity.jl.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nReturns\n\ncdfs::Array{Float64, 3}: The CDFs for the samples. The first dimension is the features, the second dimension is the matrix, and the third dimension is the sample points.\n\nExamples\n\ncdfs = pcvct.generateSobolCDFs(11, 3)\nsize(cdfs)\n# output\n(3, 1, 11)\n\ncdfs = pcvct.generateSobolCDFs(7, 5; n_matrices=2)\nsize(cdfs)\n# output\n(5, 2, 7)\n\n\n\n\n\n","category":"method"},{"location":"man/known_limitations/#Known-limitations","page":"Known limitations","title":"Known limitations","text":"","category":"section"},{"location":"man/known_limitations/#Always-select-all-simulations-associated-with-a-Monad","page":"Known limitations","title":"Always select all simulations associated with a Monad","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"Anytime a group of simulation replicates (a Monad in pcvct internals) is requested, all simulations in that group are used, regardless of the value of n_replicates. If the number of simulations in the group is less than n_replicates, then additional simulations are run to reach n_replicates. Note: if use_previous=false, then n_replicates will be run regardless and the returned Monad will only have the newly-run simulations. If you do need an upper bound on the number of simulations in such a grouping, submit an issue. It is assumed that most, if not all use cases, will benefit from more simulations.","category":"page"},{"location":"man/known_limitations/#Initial-conditions-not-loaded-when-launching-PhysiCell-Studio-for-a-simulation.","page":"Known limitations","title":"Initial conditions not loaded when launching PhysiCell Studio for a simulation.","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"When launching PhysiCell Studio from pcvct, the initial conditions (cells and substrates) are not loaded.","category":"page"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTDeletion/#VCTDeletion","page":"VCTDeletion","title":"VCTDeletion","text":"","category":"section"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"Safely delete output from a pcvct project.","category":"page"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"Modules = [pcvct]\nPages = [\"VCTDeletion.jl\"]","category":"page"},{"location":"lib/VCTDeletion/#pcvct.deleteSimulations-Tuple{AbstractVector{<:Union{Missing, Integer}}}","page":"VCTDeletion","title":"pcvct.deleteSimulations","text":"deleteSimulations(simulation_ids::AbstractVector{<:Union{Integer,Missing}}; delete_supers::Bool=true, and_constraints::String=\"\")\n\nDeletes the simulations with the input IDs from the database and from the data/outputs/simulations folder.\n\nWorks with any vector of integers or a single integer. If delete_supers is true, it will also delete any monads, samplings, and trials that no longer have any simulations associated with them. It is recommended to leave this to true to keep the database clean. The and_constraints argument allows for additional SQLite conditions to be added to the WHERE clause of the SQLite query. Use this only after inspecting the simulations table in the data/vct.db database.     Note: deleteSimulation is an alias for deleteSimulations.\n\nExamples\n\ndeleteSimulations(1:3)\ndeleteSimulations(4)\ndeleteSimulations(1:100; and_constraints=\"AND config_id = 1\") # delete simulations with IDs 1 to 100 that have config_id = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDeletion/#pcvct.deleteSimulationsByStatus","page":"VCTDeletion","title":"pcvct.deleteSimulationsByStatus","text":"deleteSimulationsByStatus(status_codes_to_delete::Vector{String}=[\"Failed\"]; user_check::Bool=true)\n\nDelete simulations from the database based on their status codes.\n\nThe list of possible status codes is: \"Not Started\", \"Queued\", \"Running\", \"Completed\", \"Failed\".\n\nArguments\n\nstatus_codes_to_delete::Vector{String}: A vector of status codes for which simulations should be deleted. Default is [\"Failed\"].\nuser_check::Bool: If true, prompts the user for confirmation before deleting simulations. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTDeletion/#pcvct.eraseSimulationID-Tuple{Int64}","page":"VCTDeletion","title":"pcvct.eraseSimulationID","text":"eraseSimulationID(simulation_id::Int[; monad_id::Union{Missing,Int}=missing])\n\nErase a simulation ID from the simulations.csv file of the monad it belongs to.\n\nIf monad_id is not provided, the function will infer it from the simulation ID. If the monad contains only the given simulation ID, the monad will be deleted. This is used when running simulations if they error so that the monads no longer rely on them, but the simulation output can still be checked.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDeletion/#pcvct.resetDatabase-Tuple{}","page":"VCTDeletion","title":"pcvct.resetDatabase","text":"resetDatabase()\n\nReset the database (after user confirmation) by deleting all simulations, monads, samplings, and trials.\n\nAll the base inputs files will be kept, so previously run scripts should still work as expected. If the user aborts the reset, the user will then be asked if they want to continue with the script.\n\nKeyword Arguments\n\nforce_reset::Bool: If true, skips the user confirmation prompt. Default is false.\nforce_continue::Bool: If true, skips the user confirmation prompt for continuing with the script after aborting the reset. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"man/best_practices/#Best-practices","page":"Best practices","title":"Best practices","text":"","category":"section"},{"location":"man/best_practices/#Do-NOT-manually-edit-files-inside-inputs.","page":"Best practices","title":"Do NOT manually edit files inside inputs.","text":"","category":"section"},{"location":"man/best_practices/","page":"Best practices","title":"Best practices","text":"If parameter values need to be changed, use variations as shown in VCT/GenerateData.jl. Let pcvct manage the databases that track simulation parameters.","category":"page"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTAnalysis/#VCTAnalysis","page":"VCTAnalysis","title":"VCTAnalysis","text":"","category":"section"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"Analyze output from a pcvct project.","category":"page"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"Modules = [pcvct]\nPages = [\"population.jl\", \"substrate.jl\"]","category":"page"},{"location":"lib/VCTAnalysis/#pcvct.MonadPopulationTimeSeries","page":"VCTAnalysis","title":"pcvct.MonadPopulationTimeSeries","text":"MonadPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a monad's population time series.\n\nNote: unlike SimulationPopulationTimeSeries, this type does not save the data to a file.\n\nExamples\n\nmpts = MonadPopulationTimeSeries(1)\nmpts = MonadPopulationTimeSeries(monad(1))\n\nFields\n\nmonad_id::Int: The ID of the monad.\nmonad_length::Int: The number of simulations in the monad.\ntime::Vector{Real}: The time points of the population time series.\ncell_count_arrays::Dict{String, Array{Integer,2}}: A dictionary where keys are cell type names and values are (length(time), monad_length)-sized arrays of cell counts over time for each simulation in the monad.\ncell_count_means::Dict{String, Vector{Real}}: A dictionary where keys are cell type names and values are vectors of mean cell counts over time for each simulation in the monad.\ncell_count_stds::Dict{String, Vector{Real}}: A dictionary where keys are cell type names and values are vectors of standard deviation of cell counts over time for each simulation in the monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#pcvct.SimulationPopulationTimeSeries","page":"VCTAnalysis","title":"pcvct.SimulationPopulationTimeSeries","text":"SimulationPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a simulation's population time series.\n\nIf constructed using a Simulation or an Integer (representing a simulation ID), it will save the time series inside the simulations/simulation_id/summary/ folder. It will also look for previously computed time series there to avoid recomputing them.\n\nExamples\n\nspts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has \"_include_dead\" appended\n\nFields\n\nfolder::String: The folder containing the simulation's output.\ntime::Vector{Real}: The time points of the population time series.\ncell_count::Dict{String, Vector{Integer}}: A dictionary where keys are cell type names and values are vectors of cell counts over time.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#pcvct.finalPopulationCount","page":"VCTAnalysis","title":"pcvct.finalPopulationCount","text":"finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])\n\nReturn the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.\n\nAlso works with the simulation ID:\n\nfpc = finalPopulationCount(1)\n\nExample\n\nfpc = finalPopulationCount(simulation)\nfinal_default_count = fpc[\"default\"]\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#pcvct.plotbycelltype","page":"VCTAnalysis","title":"pcvct.plotbycelltype","text":"plotbycelltype(T::AbstractTrial, cell_types::Union{String, Vector{String}}=:all)\n\nPlot the population time series of a trial by cell type.\n\nEach cell type gets its own subplot. Each monad gets its own series within each subplot.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}","page":"VCTAnalysis","title":"pcvct.populationTimeSeries","text":"populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])\n\nReturn the population time series of a simulation or a monad.\n\nSee SimulationPopulationTimeSeries and MonadPopulationTimeSeries for more details.\n\n\n\n\n\n","category":"method"},{"location":"man/database_upgrades/#Database-upgrades","page":"Database upgrades","title":"Database upgrades","text":"","category":"section"},{"location":"man/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Over time, the database structure of pcvct will evolve to reflect new capabilities, features, and improvements. Not every release will change the database structure, but when one does in a way that could affect your workflow, pcvct will throw a warning. The warning will link to this page and the function will wait for user input to proceed. Changes are listed in reverse chronological order.","category":"page"},{"location":"man/database_upgrades/#to-v0.0.10","page":"Database upgrades","title":"to v0.0.10","text":"","category":"section"},{"location":"man/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Start tracking the PhysiCell version used in the simulation. This introduces the physicell_versions table which tracks the PhysiCell versions used in simulations. Currently, only supports reading the PhysiCell version, not setting it (e.g., through git commands). Key changes include:","category":"page"},{"location":"man/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Adding the physicell_version_id column to the simulations, monads, and samplings tables.\nAdding the physicell_versions table.\nIf PhysiCell is a git-tracked repo, this will store the commit hash as well as any tag and repo owner it can find based on the remotes. It will also store the date of the commit.\nIf PhysiCell is not a git-tracked repo, it will read the VERSION.txt file and store that as the commit_hash with -download appended to the version.","category":"page"},{"location":"man/database_upgrades/#to-v0.0.3","page":"Database upgrades","title":"to v0.0.3","text":"","category":"section"},{"location":"man/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Introduce XML-based cell initial conditions. This introduces ic_cell_variations. Also, standardized the use of config_variation in place of variation. Key changes include:","category":"page"},{"location":"man/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Renaming the variation_id column in the simulations and monads tables to config_variation_id.\nAdding the ic_cell_variation_id column to the simulations and monads tables.\nIn data/inputs/configs, renaming all instances of \"variation\" to \"config_variation\" in filenames and databases.","category":"page"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTDatabase/#VCTDatabase","page":"VCTDatabase","title":"VCTDatabase","text":"","category":"section"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"Create and manage the pcvct database.","category":"page"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"Modules = [pcvct]\nPages = [\"VCTDatabase.jl\"]","category":"page"},{"location":"lib/VCTDatabase/#pcvct.isStarted-Tuple{Int64}","page":"VCTDatabase","title":"pcvct.isStarted","text":"isStarted(simulation_id::Int[; new_status_code::Union{Missing,String}=missing])\n\nCheck if a simulation has been started.\n\nIf new_status_code is provided, update the status of the simulation to this value. The check and status update are done in a transaction to ensure that the status is not changed by another process.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDatabase/#pcvct.printSimulationsTable-Tuple","page":"VCTDatabase","title":"pcvct.printSimulationsTable","text":"printSimulationsTable()\n\nPrint a table of simulations and their varied values. See keyword arguments below for more control of the output.\n\nThere are many methods for this function. The simplest is printSimulationsTable(), which prints all simulations in the database. You can also pass in any number of simulations, monads, samplings, and trials to print a table of those simulations:\n\nprintSimulationsTable([simulation_1, monad_3, sampling_2, trial_1])\n\nFinally, a vector of simulation IDs can be passed in:\n\nprintSimulationsTable([1, 2, 3])\n\nKeyword arguments can be used with any of these methods to control the output:\n\nKeyword Arguments\n\nsink: A function to print the table. Defaults to println. Note, the table is a DataFrame, so you can also use CSV.write to write the table to a CSV file.\nremove_constants::Bool: If true, removes columns that have the same value for all simulations. Defaults to true.\nsort_by::Vector{String}: A vector of column names to sort the table by. Defaults to all columns. To populate this argument, first print the table to see the column names.\nsort_ignore::Vector{String}: A vector of column names to ignore when sorting. Defaults to the database IDs associated with the simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTClasses/#VCTClasses","page":"VCTClasses","title":"VCTClasses","text":"","category":"section"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"Class definitions for the hierarchical structure connecting simulations to trials.","category":"page"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"Modules = [pcvct]\nPages = [\"VCTClasses.jl\"]","category":"page"},{"location":"lib/VCTClasses/#pcvct.InputFolders","page":"VCTClasses","title":"pcvct.InputFolders","text":"InputFolders\n\nConsolidate the folder information for a simulation/monad/sampling.\n\nPass the folder names within the inputs/<input_type> directory to create an InputFolders object. Pass them in the order of config, custom_code, rulesets_collection, ic_cell, ic_substrate, ic_ecm, ic_dc. Or use the keyword-based constructors:\n\nInputFolders(config, custom_code; rulesets_collection=\"\", ic_cell=\"\", ic_substrate=\"\", ic_ecm=\"\", ic_dc=\"\")\n\nInputFolders(; config=\"\", custom_code=\"\", rulesets_collection=\"\", ic_cell=\"\", ic_substrate=\"\", ic_ecm=\"\", ic_dc=\"\")\n\nFields\n\nconfig::InputFolder: id and folder name for the base configuration folder.\ncustom_code::InputFolder: id and folder name for the custom code folder.\nrulesets_collection::InputFolder: id and folder name for the rulesets collection folder.\nic_cell::InputFolder: id and folder name for the initial condition (IC) cells folder.\nic_substrate::InputFolder: id and folder name for the initial condition (IC) substrate folder.\nic_ecm::InputFolder: id and folder name for the initial condition (IC) extracellular matrix (ECM) folder.\nic_dc::InputFolder: id and folder name for the initial condition (IC) dirichlet conditions (DC) folder.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Monad","page":"VCTClasses","title":"pcvct.Monad","text":"Monad\n\nA group of simulations that are identical up to randomness.\n\nTo create a new monad, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations. Set n_replicates=0 to avoid adding new simulations to the database. This is useful for creating references for later use. Otherwise, set n_replicates > 1 to create the simulations to go with this monad. If n_replicates = 1, it will return a Simulation object.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nmonad = createTrial(inputs; n_replicates=0) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nmonad = createTrial(inputs, ev; n_replicates=10) # uses the config file with the specified variation\n\nmonad = createTrial(inputs, ev; n_replicates=10, use_previous=false) # changes the default behavior and creates 10 new simulations for this monad\n\nIf there is a previously created monad that you wish to access, you can use its ID to create a Monad object:\n\nmonad = Monad(monad_id)\nmonad = Monad(monad_id; n_replicates=5) # ensures at least 5 simulations in the monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this monad. Matches with the folder in data/outputs/monads/\nn_replicates::Int: minimum number of simulations to ensure are part of this monad when running this monad.\nsimulation_ids::Vector{Int}: array of simulation IDs belonging to this monad. This need not have length equal to n_replicates.\ninputs::InputFolders: contains the folder info for this monad.\nvariation_ids::VariationIDs: contains the variation IDs for this monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Sampling","page":"VCTClasses","title":"pcvct.Sampling","text":"Sampling\n\nA group of monads that have the same input folders, but differ in parameter values.\n\nTo create a new sampling, best practice is to use createTrial and supply it with the InputFolders and any number of DiscreteVariations. At least one should have multiple values to create a sampling.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling = createTrial(inputs, ev; n_replicates=3, use_previous=true)\n\nIf there is a previously created sampling that you wish to access, you can use its ID to create a Sampling object:\n\nsampling = Sampling(sampling_id)\nsampling = Sampling(sampling_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this sampling. Matches with the folder in data/outputs/samplings/\nn_replicates::Int: minimum number of simulations to ensure are part of each monad when running this sampling.\nmonad_ids::Vector{Int}: array of monad IDs belonging to this sampling.\ninputs::InputFolders: contains the folder info for this sampling.\nvariation_ids::Vector{VariationIDs}: contains the variation IDs for each monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Simulation","page":"VCTClasses","title":"pcvct.Simulation","text":"Simulation\n\nA simulation that represents a single run of the model.\n\nTo create a new simulation, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations:\n\ninputs = InputFolders(config_folder, custom_code_folder)\nsimulation = createTrial(inputs) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nsimulation = createTrial(inputs, ev) # uses the config file with the specified variation\n\nIf there is a previously created simulation that you wish to access, you can use its ID to create a Simulation object:\n\nsimulation = Simulation(simulation_id)\n\nFields\n\nid::Int: integer uniquely identifying this simulation. Matches with the folder in data/outputs/simulations/\ninputs::InputFolders: contains the folder info for this simulation.\nvariation_ids::VariationIDs: contains the variation IDs for this simulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Trial","page":"VCTClasses","title":"pcvct.Trial","text":"Trial\n\nA group of samplings that can have different input folders.\n\nTo create a new trial, best practice currently is to create a vector of Sampling objects and passing them to Trial.\n\ninputs_1 = InputFolders(config_folder_1, custom_code_folder_1)\ninputs_2 = InputFolders(config_folder_2, custom_code_folder_2)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling_1 = createTrial(inputs_1, ev; n_replicates=3, use_previous=true)\nsampling_2 = createTrial(inputs_2, ev; n_replicates=3, use_previous=true)\ntrial = Trial([sampling_1, sampling_2])\n\nIf there is a previous trial that you wish to access, you can use its ID to create a Trial object:\n\ntrial = Trial(trial_id)\ntrial = Trial(trial_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this trial. Matches with the folder in data/outputs/trials/\nn_replicates::Int: minimum number of simulations to ensure are part of each monad in each sampling in this trial.\nsampling_ids::Vector{Int}: array of sampling IDs belonging to this trial.\ninputs::Vector{InputFolders}: contains the folder info for each sampling in this trial.\nvariation_ids::Vector{Vector{VariationIDs}}: contains the variation IDs for each monad in each sampling in this trial.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTPruner/#VCTPruner","page":"VCTPruner","title":"VCTPruner","text":"","category":"section"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"Prune files from a simulation immediately after finishing the simulation.","category":"page"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"To motivate this functionality, consider the following scenario. A user has been testing their model, including making movies, and is ready to do a large virtual clinical trial with thousands of simulations. Saving all the SVGs will require gigabytes of storage, which is not ideal for the user. The user could choose to create a new variation on the SVG parameters (e.g., increase the SVG save interval), but then pcvct will not be able to reuse previous simulations as they have different variation IDs. Alternatively, the user can use the PruneOptions to delete the SVGs after each simulation is finished. This way, there are fewer variations in the database and more capability to reuse simulations.","category":"page"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"Modules = [pcvct]\nPages = [\"VCTPruner.jl\"]","category":"page"},{"location":"lib/VCTPruner/#pcvct.PruneOptions","page":"VCTPruner","title":"pcvct.PruneOptions","text":"PruneOptions\n\nAutomatically prune some of the generated output files from a simulation.\n\nFields\n\nprune_svg::Bool=false: Prune SVG files\nprune_txt::Bool=false: Prune TXT files\nprune_mat::Bool=false: Prune MAT files\nprune_initial::Bool=false: If any of the above are true, also prune the initial files for that type\nprune_final::Bool=false: If any of the above are true, also prune the final files for that type\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTCompilation/#VCTCompilation","page":"VCTCompilation","title":"VCTCompilation","text":"","category":"section"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"Compile a PhysiCell project in pcvct. Includes the necessary compiler macros and checks PhysiCell version by the commit hash of the PhysiCell repository.","category":"page"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"Modules = [pcvct]\nPages = [\"VCTCompilation.jl\"]","category":"page"},{"location":"lib/VCTCompilation/#pcvct.compilerFlags-Tuple{pcvct.AbstractSampling}","page":"VCTCompilation","title":"pcvct.compilerFlags","text":"compilerFlags(S::AbstractSampling)\n\nGenerate the compiler flags for the given sampling object S.\n\nGenerate the necessary compiler flags based on the system and the macros defined in the sampling object S. If the required macros differ from a previous compilation (as stored in macros.txt), then recompile.\n\nReturns\n\ncflags::String: The compiler flags as a string.\nrecompile::Bool: A boolean indicating whether recompilation is needed.\nclean::Bool: A boolean indicating whether cleaning is needed.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTCompilation/#pcvct.loadCustomCode-Tuple{pcvct.AbstractSampling}","page":"VCTCompilation","title":"pcvct.loadCustomCode","text":"loadCustomCode(S::AbstractSampling[; force_recompile::Bool=false])\n\nLoad and compile custom code for a simulation, monad, or sampling.\n\nDetermines if recompilation is necessary based on the previously used macros. If compilation is required, copy the PhysiCell directory to a temporary directory to avoid conflicts. Then, compile the project, recording the output and error in the custom_codes folder used. Move the compiled executable into the custom_codes folder and the temporary PhysiCell folder deleted.\n\n\n\n\n\n","category":"method"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Read Best practices before using pcvct.","category":"page"},{"location":"man/getting_started/#Install-pcvct","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/#Download-julia","page":"Getting started","title":"Download julia","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"See here for more options:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: this command also installs the JuliaUp installation manager, which will automatically install julia and help keep it up to date.","category":"page"},{"location":"man/getting_started/#Add-the-PCVCTRegistry","page":"Getting started","title":"Add the PCVCTRegistry","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Launch julia by running julia in a shell. Then, enter the Pkg REPL by pressing ]. Finally, add the PCVCTRegistry by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> registry add https://github.com/drbergman/PCVCTRegistry","category":"page"},{"location":"man/getting_started/#Install-pcvct-2","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Still in the Pkg REPL, run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> add pcvct","category":"page"},{"location":"man/getting_started/#Set-up-a-pcvct-project","page":"Getting started","title":"Set up a pcvct project","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Leave the Pkg REPL by pressing the delete or backspace key (if still in it from the previous step). Load the pcvct module by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using pcvct","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Then, create a new project by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> createProject(path_to_project_folder) # createProject() will use the current directory as the project folder","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This creates three folders inside the path_to_project_folder folder: data/, PhysiCell/, and VCT/. See Data directory structure for information about the data/ folder.","category":"page"},{"location":"man/getting_started/#(Optional)-Import-from-user_projects","page":"Getting started","title":"(Optional) Import from user_projects","text":"","category":"section"},{"location":"man/getting_started/#Inputs","page":"Getting started","title":"Inputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you have a project in the PhysiCell/user_projects/ folder that you would like to import, you can do so by running importProject:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder)","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The path_to_project_folder string can be either the absolute path (recommended) or the relative path (from the directory julia was launched) to the project folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: This function assumes your project files are in the standard PhysiCell/user_projects/ format. See the table below for the standard locations of the files. Note the Default location column shows the path relative to path_to_project_folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Input Default location Key Optional\nconfig config/PhysiCell_settings.xml config \nmain main.cpp main \nMakefile Makefile makefile \ncustom modules custom_modules/ custom_modules \nrules config/cell_rules.csv rules X\ncell initial conditions config/cells.csv ic_cell X\nsubstrate initial conditions config/substrates.csv ic_substrate X","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If any of these files are not located in the standard location, you can define a dictionary with keys taken from the table above to specify the location of each file. For example, if the config file is instead located at PhysiCell/user_projects/[project_name]/config/config.xml, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> src = Dict(\"config\" => \"config/config.xml\")","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Additional entries can be added in a comma-separated list into Dict or added later with src[key] = rel_path. Pass the dictionary in as the second argument as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder, src)","category":"page"},{"location":"man/getting_started/#Outputs","page":"Getting started","title":"Outputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you use this option, then the GenerateData.jl script must be updated to reflect the new project folders. By default, the folder names are taken from the name of the project with an integer appended if it already exists. If you want to use a different name, you can pass ","category":"page"},{"location":"man/getting_started/#Running-first-trial","page":"Getting started","title":"Running first trial","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The createProject() command creates three folder, including a VCT folder with a single file: VCT/GenerateData.jl. The name of this folder and this file are purely convention, change them as you like. To run your first pcvct trial, you can run the GenerateData.jl script from the shell:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: if you want to parallelize these 9 runs, you can set the shell environment variable PCVCT_NUM_PARALLEL_SIMS to the number of parallel simulations you want to run. For example, to run 9 parallel simulations, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ export PCVCT_NUM_PARALLEL_SIMS=9\n$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Or for a one-off solution:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ PCVCT_NUM_PARALLEL_SIMS=9 julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Alternatively, you can run the script via the REPL.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Run the script a second time and observe that no new simulations are run. This is because pcvct looks for matching simulations first before running new ones. The use_previous optional keyword argument can control this behavior if new simulations are desired.","category":"page"},{"location":"man/data_directory/#Data-directory-structure","page":"Data directory","title":"Data directory structure","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"To set up your pcvct-enabled repository within project-dir (the name of your project directory), create the following directory structure:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"project-dir/\n├── data/\n│   └── inputs/\n│       ├── configs/\n│       ├── custom_codes/\n│       ├── ics/\n│       │   ├── cells/\n│       │   ├── dcs/\n│       │   ├── ecms/\n│       │   └── substrates/\n│       ├── rulesets_collections/\n...","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Within each of the terminal subdirectories above within data/inputs/, add a subdirectory with a user-defined name with content described below. We will use the name \"default\" for all as an example.","category":"page"},{"location":"man/data_directory/#Configs","page":"Data directory","title":"Configs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/configs/default/ called PhysiCell_settings.xml with the base configuration file for your PhysiCell project.","category":"page"},{"location":"man/data_directory/#Custom-codes","page":"Data directory","title":"Custom codes","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add within data/inputs/custom_codes/default/ the following, each exactly as is used in a PhysiCell project:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"main.cpp\nMakefile\ncustom_modules/","category":"page"},{"location":"man/data_directory/#ICs","page":"Data directory","title":"ICs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"These folders are optional as not every model includes initial conditions as separate files. If your model does, for each initial condition add a subfolder. For example, if you have two initial cell position conditions, random_cells.csv and structured_cells.csv, the data/inputs/ics/cells/ directory would look like this:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"cells/\n├── random_cells/\n│   └── cells.csv\n└── structured_cells/\n    └── cells.csv","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Note: Place the files in their corresponding folders and rename to cells.csv.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Proceed similarly for dcs/, ecms/, and substrates/, renaming those files to dcs.csv, ecm.csv, and substrates.csv, respectively.","category":"page"},{"location":"man/data_directory/#Rulesets-collections","page":"Data directory","title":"Rulesets collections","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/rulesets_collections/default/ called base_rulesets.csv with the base ruleset collection for your PhysiCell project. If your project does not use rules, you can skip this step.","category":"page"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTPhysiCellStudio/#VCTPhysiCellStudio","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"","category":"section"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"Launch PhysiCell Studio for a simulation run in pcvct.","category":"page"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"Modules = [pcvct]\nPages = [\"VCTPhysiCellStudio.jl\"]","category":"page"},{"location":"lib/VCTPhysiCellStudio/#pcvct.runStudio-Tuple{Int64}","page":"VCTPhysiCellStudio","title":"pcvct.runStudio","text":"runStudio(simulation_id::Int; python_path::Union{Missing,String}=path_to_python, studio_path::Union{Missing,String}=path_to_studio)\n\nLaunch PhysiCell Studio for a given simulation.\n\nCreates temporary config and rules files to avoid overwriting the original files in the output folder. The intent of this function is to allow users to visualize the results of a simulation with Studio, rather than to modify the simulation itself.\n\nThe path to the python executable and the Studio folder must be set. pcvct will look for these in the environment variables PCVCT_PYTHON_PATH and PCVCT_STUDIO_PATH, respectively.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = pcvct","category":"page"},{"location":"#pcvct","page":"Home","title":"pcvct","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The pcvct (PhysiCell Virtual Clinical Trials) package is a Julia package that provides a framework for running virtual clinical trials using PhysiCell simulations. See Getting started for getting pcvct set up and running.","category":"page"},{"location":"#Issues","page":"Home","title":"Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Have an issue? First check the Known limitations and Best practices sections. If you still have an issue, please submit it here.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTUserAPI/#VCTUserAPI","page":"VCTUserAPI","title":"VCTUserAPI","text":"","category":"section"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"Main functions users will use to create and run simulations, monads, samplings, and trials.","category":"page"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"Modules = [pcvct]\nPages = [\"VCTUserAPI.jl\"]","category":"page"},{"location":"lib/VCTUserAPI/#Base.run-Tuple{pcvct.AddVariationMethod, Vararg{Any}}","page":"VCTUserAPI","title":"Base.run","text":"run(args...; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions(), kwargs...)\n\nRun a simulation, monad, sampling, or trial with the same signatures available to createTrial.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTUserAPI/#pcvct.createTrial","page":"VCTUserAPI","title":"pcvct.createTrial","text":"createTrial([method=GridVariation()], inputs::InputFolders, avs::Vector{<:AbstractVariation}=AbstractVariation[];\n            n_replicates::Integer=1, use_previous::Bool=true)\n\nReturn an object of type <:AbstractTrial (simulation, monad, sampling, trial) with the given input folders and elementary variations.\n\nUses the avs and n_replicates to determine whether to create a simulation, monad, or sampling. Despite its name, trials cannot yet be created by this function. If n_replicates is 0, and each variation has a single value, a simulation will be created.\n\nBy default, the method is GridVariation(), which creates a grid of variations from the vector avs. Other methods are: LHSVariation, SobolVariation, and RBDVariation.\n\nAlternate forms (all work with the optional method argument in the first position): Only supplying a single AbstractVariation:\n\ncreateTrial(inputs::InputFolders, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nUsing a reference simulation or monad:\n\ncreateTrial(reference::AbstractMonad, avs::Vector{<:AbstractVariation}=AbstractVariation[]; n_replicates::Integer=1,\n            use_previous::Bool=true)\n\ncreateTrial(reference::AbstractMonad, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nExamples\n\ninputs = InputFolders(config_folder, custom_code_folder)\ndv_max_time = DiscreteVariation([\"overall\", \"max_time\"], 1440)\ndv_apoptosis = DiscreteVariation([pcvct.apoptosisPath(cell_type); \"rate\"], [1e-6, 1e-5])\nsimulation = createTrial(inputs, dv_max_time)\nmonad = createTrial(inputs, dv_max_time; n_replicates=2)\nsampling = createTrial(monad, dv_apoptosis; n_replicates=2) # uses the max time defined for monad\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTModule/#VCTModule","page":"VCTModule","title":"VCTModule","text":"","category":"section"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"Core functionality for pcvct.","category":"page"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"Modules = [pcvct]\nPages = [\"VCTModule.jl\"]","category":"page"},{"location":"lib/VCTModule/#pcvct.getSimulationIDs-Tuple{}","page":"VCTModule","title":"pcvct.getSimulationIDs","text":"getSimulationIDs()\n\nReturn a vector of all simulation IDs in the database.\n\nAlternate forms take a simulation, monad, sampling, or trial object (or an array of any combination of them) and return the corresponding simulation IDs.\n\nExamples\n\ngetSimulationIDs() # all simulation IDs in the database\ngetSimulationIDs(simulation) # just a vector with the simulation ID, i.e. [simulation.id]\ngetSimulationIDs(monad) # all simulation IDs in a monad\ngetSimulationIDs(sampling) # all simulation IDs in a sampling\ngetSimulationIDs(trial) # all simulation IDs in a trial\ngetSimulationIDs([trial1, trial2]) # all simulation IDs between trial1 and trial2\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.initializeVCT-Tuple{String, String}","page":"VCTModule","title":"pcvct.initializeVCT","text":"initializeVCT(path_to_physicell::String, path_to_data::String)\n\nInitialize the VCT environment by setting the paths to PhysiCell and data directories, and initializing the database.\n\nArguments\n\npath_to_physicell::String: Path to the PhysiCell directory as either an absolute or relative path.\npath_to_data::String: Path to the data directory as either an absolute or relative path.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.pcvctLogo-Tuple{}","page":"VCTModule","title":"pcvct.pcvctLogo","text":"pcvctLogo()\n\nReturn a string representation of the awesome pcvct logo.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.setNumberOfParallelSims-Tuple{Int64}","page":"VCTModule","title":"pcvct.setNumberOfParallelSims","text":"setNumberOfParallelSims(n::Int)\n\nSet the maximum number of parallel simulations to n.\n\n\n\n\n\n","category":"method"}]
}
