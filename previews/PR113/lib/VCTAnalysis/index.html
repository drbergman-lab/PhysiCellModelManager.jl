<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>VCTAnalysis · pcvct</title><meta name="title" content="VCTAnalysis · pcvct"/><meta property="og:title" content="VCTAnalysis · pcvct"/><meta property="twitter:title" content="VCTAnalysis · pcvct"/><meta name="description" content="Documentation for pcvct."/><meta property="og:description" content="Documentation for pcvct."/><meta property="twitter:description" content="Documentation for pcvct."/><meta property="og:url" content="https://drbergman.github.io/pcvct/lib/VCTAnalysis/"/><meta property="twitter:url" content="https://drbergman.github.io/pcvct/lib/VCTAnalysis/"/><link rel="canonical" href="https://drbergman.github.io/pcvct/lib/VCTAnalysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">pcvct</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/best_practices/">Best practices</a></li><li><a class="tocitem" href="../../man/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../man/covariations/">CoVariations</a></li><li><a class="tocitem" href="../../man/data_directory/">Data directory</a></li><li><a class="tocitem" href="../../man/intracellular_inputs/">Intracellular inputs</a></li><li><a class="tocitem" href="../../man/known_limitations/">Known limitations</a></li><li><a class="tocitem" href="../../man/physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../../man/sensitivity_analysis/">Sensitivity analysis</a></li><li><a class="tocitem" href="../../man/analyzing_output/">Analyzing output</a></li><li><a class="tocitem" href="../../man/developer_guide/">Developer guide</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li class="is-active"><a class="tocitem" href>VCTAnalysis</a></li><li><a class="tocitem" href="../VCTClasses/">VCTClasses</a></li><li><a class="tocitem" href="../VCTCompilation/">VCTCompilation</a></li><li><a class="tocitem" href="../VCTComponents/">VCTComponents</a></li><li><a class="tocitem" href="../VCTConfiguration/">VCTConfiguration</a></li><li><a class="tocitem" href="../VCTCreation/">VCTCreation</a></li><li><a class="tocitem" href="../VCTDatabase/">VCTDatabase</a></li><li><a class="tocitem" href="../VCTDeletion/">VCTDeletion</a></li><li><a class="tocitem" href="../VCTExport/">VCTExport</a></li><li><a class="tocitem" href="../VCTHPC/">VCTHPC</a></li><li><a class="tocitem" href="../VCTICCell/">VCTICCell</a></li><li><a class="tocitem" href="../VCTICECM/">VCTICECM</a></li><li><a class="tocitem" href="../VCTImport/">VCTImport</a></li><li><a class="tocitem" href="../VCTLoader/">VCTLoader</a></li><li><a class="tocitem" href="../VCTModule/">VCTModule</a></li><li><a class="tocitem" href="../VCTMovie/">VCTMovie</a></li><li><a class="tocitem" href="../VCTPhysiCellStudio/">VCTPhysiCellStudio</a></li><li><a class="tocitem" href="../VCTPruner/">VCTPruner</a></li><li><a class="tocitem" href="../VCTRunner/">VCTRunner</a></li><li><a class="tocitem" href="../VCTSensitivity/">VCTSensitivity</a></li><li><a class="tocitem" href="../VCTUserAPI/">VCTUserAPI</a></li><li><a class="tocitem" href="../VCTVariations/">VCTVariations</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../../misc/database_upgrades/">Database upgrades</a></li><li><a class="tocitem" href="../../misc/renaming/">Renaming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href>VCTAnalysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>VCTAnalysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct/blob/main/docs/src/lib/VCTAnalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="VCTAnalysis"><a class="docs-heading-anchor" href="#VCTAnalysis">VCTAnalysis</a><a id="VCTAnalysis-1"></a><a class="docs-heading-anchor-permalink" href="#VCTAnalysis" title="Permalink"></a></h1><p>Analyze output from a pcvct project. It is anticipated that this will eventually be split off into its own module or even package. Possibly with VCTLoader.jl.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.motilityStatistics-Tuple{Integer}" href="#pcvct.motilityStatistics-Tuple{Integer}"><code>pcvct.motilityStatistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">motilityStatistics(simulation_id::Integer[; direction=:any])</code></pre><p>Return the mean speed, distance traveled, and time alive for each cell in the simulation, broken down by cell type in the case of cell type transitions.</p><p>The time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first. If the cell transitions to a new cell type during the simulation, the time is counted for each cell type separately. Each cell type taken on by a given cell will be a key in the dictionary returned at that entry.</p><p><strong>Arguments</strong></p><ul><li><code>simulation_id::Integer</code>: The ID of the PhysiCell simulation.</li><li><code>direction::Symbol</code>: The direction to compute the mean speed. Can be <code>:x</code>, <code>:y</code>, <code>:z</code>, or <code>:any</code> (default). If <code>:x</code>, for example, the mean speed is calculated using only the x component of the cell&#39;s movement.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Dict{String, NamedTuple}}</code>: A vector of dictionaries, one per cell in the simulation. Each dictionary has keys for each cell type taken on by the cell. The values are NamedTuples with fields <code>:time</code>, <code>:distance</code>, and <code>:speed</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ms = motilityStatistics(1) # a vector of dictionaries, one per cell in the simulation
ms[1][&quot;epithelial&quot;] # NamedTuple with fields :time, :distance, :speed for the first cell in the simulation corresponding to its time as an `epithelial` cell
ms[1][&quot;mesenchymal&quot;].time # time spent as a `mesenchymal` cell for the first cell in the simulation
ms[1][&quot;mesenchymal&quot;].distance # distance traveled as a `mesenchymal` cell for the first cell in the simulation
ms[1][&quot;mesenchymal&quot;].speed # mean speed as a `mesenchymal` cell for the first cell in the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/motility.jl#L41-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.PCFResult" href="#pcvct.PCFResult"><code>pcvct.PCFResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PCFResult</code></pre><p>A struct to hold the results of the pair correlation function (PCF) calculation.</p><p>The start and end radii for each annulus are stored in the <code>radii</code> field. Thus, there is one more radius than there are annuli, i.e. <code>length(radii) == size(g, 1) + 1</code>. Each column of <code>g</code> corresponds to a time point in the <code>time</code> field, hence <code>size(g, 2) == length(time)</code>.</p><p><strong>Fields</strong></p><ul><li><code>time::Vector{Float64}</code>: The time points at which the PCF was calculated.</li><li><code>pcf_result::PairCorrelationFunction.PCFResult</code>: The result of the PCF calculation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using pcvct, PairCorrelationFunction
time = 12.0
radii = [0.0, 1.0, 2.0]
g = [0.5, 1.2]
pcvct.PCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCFResult:
  Time: 12.0
  Radii: 0.0 - 2.0 with 2 annuli
  g: 0.5 - 1.2 (min - max)</code></pre><pre><code class="language-julia hljs">using pcvct, PairCorrelationFunction
time = [12.0; 24.0; 36.0]
radii = [0.0, 1.0, 2.0]
g = [0.5 0.6 0.4; 1.2 1.15 1.4]
pcvct.PCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCFResult:
  Time: 12.0 - 36.0 (n = 3)
  Radii: 0.0 - 2.0 with 2 annuli
  g: 0.4 - 1.4 (min - max)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/pcf.jl#L5-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PairCorrelationFunction.pcf" href="#PairCorrelationFunction.pcf"><code>PairCorrelationFunction.pcf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcf(snapshot::PhysiCellSnapshot, center_cell_types::Vector{String}, target_cell_types::Vector{String}=center_cell_type; include_dead::Union{Bool,Tuple{Bool,Bool}}=false, dr::Float64=20.0)</code></pre><p>Calculate the pair correlation function (PCF) between two sets of cell types in a PhysiCell simulation snapshot.</p><p>The <code>center_cell_types</code> and <code>target_cell_types</code> can be strings or vectors of strings. This will compute one PCF rather than one for each pair of (center, target) cell types, i.e., all centers are compared to all targets. If omitted, the target<em>cell</em>types will be the same as the center<em>cell</em>types, i.e., not a cross-PCF. The <code>include_dead</code> argument can be a boolean or a tuple of booleans to indicate whether to include the dead centers and/or targets, respectively. The <code>dr</code> argument specifies the bin size (thickness of each annulus) for the PCF calculation.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot of the PhysiCell simulation.</li><li><code>center_cell_types::Vector{String}</code>: The cell types to use as the center of the PCF.</li><li><code>target_cell_types::Vector{String}</code>: The cell types to use as the target of the PCF.</li><li><code>include_dead::Union{Bool,Tuple{Bool,Bool}}</code>: Whether to include dead cells in the PCF calculation. If a tuple, the first element indicates whether to include dead centers and the second element indicates whether to include dead targets.</li><li><code>dr::Float64</code>: The bin size for the PCF calculation.</li></ul><p><strong>Returns</strong></p><ul><li><code>PCFResult</code>: A struct containing the time, radii, and g values of the PCF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/pcf.jl#L77-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PairCorrelationFunction.pcf-Tuple{PhysiCellSequence, Any, Any}" href="#PairCorrelationFunction.pcf-Tuple{PhysiCellSequence, Any, Any}"><code>PairCorrelationFunction.pcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcf(sequence::PhysiCellSequence, center_cell_types::Vector{String}, target_cell_types::Vector{String}=center_cell_types; kwargs...)</code></pre><p>Calculate the pair correlation function (PCF) across all snapshots in a PhysiCell simulation sequence.</p><p><strong>Returns</strong></p><ul><li><code>PCFResult</code>: A struct containing the times, radii, and g values as a (length(radii)-1 x length(time)) matrix of the PCF.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/pcf.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.MonadPopulationTimeSeries" href="#pcvct.MonadPopulationTimeSeries"><code>pcvct.MonadPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MonadPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a monad&#39;s population time series.</p><p>Note: unlike <code>SimulationPopulationTimeSeries</code>, this type does not save the data to a file.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">mpts = MonadPopulationTimeSeries(1)
mpts = MonadPopulationTimeSeries(monad(1))</code></pre><p><strong>Fields</strong></p><ul><li><code>monad_id::Int</code>: The ID of the monad.</li><li><code>monad_length::Int</code>: The number of simulations in the monad.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, NamedTuple}</code>: A dictionary where keys are cell type names and values are NamedTuples with fields <code>:counts</code>, <code>:mean</code>, and <code>:std</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/population.jl#L152-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.SimulationPopulationTimeSeries" href="#pcvct.SimulationPopulationTimeSeries"><code>pcvct.SimulationPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulationPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a simulation&#39;s population time series.</p><p>If constructed using a <code>Simulation</code> or an <code>Integer</code> (representing a simulation ID), it will save the time series inside the <code>simulations/simulation_id/summary/</code> folder. It will also look for previously computed time series there to avoid recomputing them.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">spts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has &quot;_include_dead&quot; appended</code></pre><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the simulation.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, Vector{Integer}}</code>: A dictionary where keys are cell type names and values are vectors of cell counts over time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/population.jl#L25-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.finalPopulationCount" href="#pcvct.finalPopulationCount"><code>pcvct.finalPopulationCount</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])</code></pre><p>Return the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.</p><p>Also works with the simulation ID:</p><pre><code class="nohighlight hljs">fpc = finalPopulationCount(1)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs">fpc = finalPopulationCount(simulation)
final_default_count = fpc[&quot;default&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/population.jl#L125-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.plotbycelltype" href="#pcvct.plotbycelltype"><code>pcvct.plotbycelltype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotbycelltype(T::AbstractTrial; include_dead::Bool=false, include_cell_types=:all, exclude_cell_types=String[])</code></pre><p>Plot the population time series of a trial by cell type.</p><p>Each cell type gets its own subplot. Each monad gets its own series within each subplot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/population.jl#L338-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}" href="#pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}"><code>pcvct.populationTimeSeries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])</code></pre><p>Return the population time series of a simulation or a monad.</p><p>See <code>SimulationPopulationTimeSeries</code> and <code>MonadPopulationTimeSeries</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/population.jl#L236-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.AverageSubstrateTimeSeries" href="#pcvct.AverageSubstrateTimeSeries"><code>pcvct.AverageSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AverageSubstrateTimeSeries</code></pre><p>A struct to hold the average substrate concentrations over time for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>substrate_concentrations::Dict{String, Vector{Real}}</code>: A dictionary mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><p>```julia asts = AverageSubstrateTimeSeries(1) # Load average substrate time series for Simulation 1 asts.time # Get the time points asts[&quot;time&quot;] # alternative way to get the time points asts[&quot;oxygen&quot;] # Get the oxygen concentration over time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/substrate.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.ExtracellularSubstrateTimeSeries" href="#pcvct.ExtracellularSubstrateTimeSeries"><code>pcvct.ExtracellularSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtracellularSubstrateTimeSeries</code></pre><p>A struct to hold the mean extracellular substrate concentrations per cell type over time for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>data::Dict{String, Dict{String, Vector{Real}}}</code>: A dictionary mapping cell type names to dictionaries mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ests = ExtracellularSubstrateTimeSeries(1) # Load extracellular substrate time series for Simulation 1
ests.time # Get the time points
ests[&quot;cancer&quot;][&quot;oxygen&quot;] # Get the oxygen concentration over time for the cancer cell type

ests = ExtracellularSubstrateTimeSeries(simulation; include_dead=true) # Load extracellular substrate time series for a Simulation object, including dead cells
ests[&quot;time&quot;] # Alternate way to get the time points
ests[&quot;cd8&quot;][&quot;IFNg&quot;] # Get the interferon gamma concentration over time for the CD8 cell type</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/9cd6bbaea63d285f0c230ca7c8847df4438fa854/src/VCTAnalysis/substrate.jl#L145-L165">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/developer_guide/">« Developer guide</a><a class="docs-footer-nextpage" href="../VCTClasses/">VCTClasses »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 3 April 2025 11:26">Thursday 3 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
