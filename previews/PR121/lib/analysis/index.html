<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · pcvct</title><meta name="title" content="Analysis · pcvct"/><meta property="og:title" content="Analysis · pcvct"/><meta property="twitter:title" content="Analysis · pcvct"/><meta name="description" content="Documentation for pcvct."/><meta property="og:description" content="Documentation for pcvct."/><meta property="twitter:description" content="Documentation for pcvct."/><meta property="og:url" content="https://drbergman.github.io/pcvct/lib/analysis/"/><meta property="twitter:url" content="https://drbergman.github.io/pcvct/lib/analysis/"/><link rel="canonical" href="https://drbergman.github.io/pcvct/lib/analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">pcvct</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/best_practices/">Best practices</a></li><li><a class="tocitem" href="../../man/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../man/covariations/">CoVariations</a></li><li><a class="tocitem" href="../../man/data_directory/">Data directory</a></li><li><a class="tocitem" href="../../man/intracellular_inputs/">Intracellular inputs</a></li><li><a class="tocitem" href="../../man/known_limitations/">Known limitations</a></li><li><a class="tocitem" href="../../man/physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../../man/sensitivity_analysis/">Sensitivity analysis</a></li><li><a class="tocitem" href="../../man/analyzing_output/">Analyzing output</a></li><li><a class="tocitem" href="../../man/developer_guide/">Developer guide</a></li><li><a class="tocitem" href="../../man/">Index</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li class="is-active"><a class="tocitem" href>Analysis</a></li><li><a class="tocitem" href="../classes/">Classes</a></li><li><a class="tocitem" href="../compilation/">Compilation</a></li><li><a class="tocitem" href="../components/">Components</a></li><li><a class="tocitem" href="../configuration/">Configuration</a></li><li><a class="tocitem" href="../creation/">Creation</a></li><li><a class="tocitem" href="../database/">Database</a></li><li><a class="tocitem" href="../deletion/">Deletion</a></li><li><a class="tocitem" href="../export/">Export</a></li><li><a class="tocitem" href="../hpc/">HPC</a></li><li><a class="tocitem" href="../ic_cell/">Cell Initial Conditions</a></li><li><a class="tocitem" href="../ic_ecm/">ECM Initial Conditions</a></li><li><a class="tocitem" href="../import/">Import</a></li><li><a class="tocitem" href="../loader/">Loader</a></li><li><a class="tocitem" href="../movie/">Movie</a></li><li><a class="tocitem" href="../pcvct/">Core</a></li><li><a class="tocitem" href="../physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../pruner/">Pruner</a></li><li><a class="tocitem" href="../runner/">Runner</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity</a></li><li><a class="tocitem" href="../user_api/">User API</a></li><li><a class="tocitem" href="../variations/">Variations</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../../misc/database_upgrades/">Database upgrades</a></li><li><a class="tocitem" href="../../misc/renaming/">Renaming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct/blob/main/docs/src/lib/analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><p>Analyze output from a pcvct project. It is anticipated that this will eventually be split off into its own module or even package. Possibly with loader.jl.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct._connectedComponents-Tuple{MetaGraphsNext.MetaGraph}" href="#pcvct._connectedComponents-Tuple{MetaGraphsNext.MetaGraph}"><code>pcvct._connectedComponents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_connectedComponents(G::MetaGraph)</code></pre><p>Find the connected components of a graph.</p><p>First compute the transitive closure of the underlying <code>Graphs.Graph</code> object. Then, update the edge data of the <code>MetaGraph</code> object to reflect the new edges. Finally, loop over vertex labels and find the vertices they are connected to until all vertices are accounted for. Returns a list of connected components, where each component is represented as a vector of vertex labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/graphs.jl#L97-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.connectedComponents" href="#pcvct.connectedComponents"><code>pcvct.connectedComponents</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">connectedComponents(snapshot::PhysiCellSnapshot, graph=:neighbors; include_cell_types=:all_in_one, exclude_cell_types::String[], include_dead::Bool=false)</code></pre><p>Find the connected components of a graph in a PhysiCell snapshot.</p><p>The computation can be done on subsets of cells based on their cell types.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: the snapshot to analyze</li><li><code>graph</code>: the graph data to use (default is <code>:neighbors</code>); must be one of <code>:neighbors</code>, <code>:attachments</code>, or <code>:spring_attachments</code>; can also be a string</li><li><code>include_cell_types</code>: the cell types to include in the analysis (default is <code>:all_in_one</code>). Full list of options:<ul><li><code>:all</code> - compute connected components for all cell types individually</li><li><code>:all_in_one</code> - compute connected components for all cell types together</li><li><code>&quot;cell_type_1&quot;</code> - compute connected components only for the cells of type <code>cell_type_1</code></li><li><code>[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> separately</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> together</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;], &quot;cell_type_3&quot;]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> together, and for the cells of type <code>cell_type_3</code> separately</li></ul></li><li><code>exclude_cell_types</code>: the cell types to exclude from the analysis (default is <code>String[]</code>); can be a single string or a vector of strings</li><li><code>include_dead</code>: whether to include dead cells in the analysis (default is <code>false</code>)</li></ul><p><strong>Returns</strong></p><p>A dictionary in which each key is one of the following:</p><ul><li>cell type name (String)</li><li>list of cell type names (Vector{String})</li><li>list of cell type names followed by the symbol :include_dead (Vector{Any})</li></ul><p>For each key, the value is a list of connected components in the graph. Each component is represented as a vector of vertex labels. As of this writing, the vertex labels are the simple <code>AgentID</code> class that wraps the cell ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/graphs.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct._motilityStatistics-Tuple{Any}" href="#pcvct._motilityStatistics-Tuple{Any}"><code>pcvct._motilityStatistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_motilityStatistics(p[; direction=:any])</code></pre><p>Compute the motility statistics for a single cell in the PhysiCell simulation.</p><p>Accounts for cell type transitions and computes the distance traveled, time spent, and mean speed for each cell type the given cell has taken on during the simulation. The speed can be restricted to a specific direction (x, y, z) or calculated in any direction. In either case, the distance is unsigned.</p><p>This function is used internally by <a href="#pcvct.motilityStatistics-Tuple{Integer}"><code>motilityStatistics</code></a>.</p><p><strong>Returns</strong></p><p>A <code>Dict{String, NamedTuple}</code> where each key is a cell type name visited by the cell and the value is a <code>NamedTuple</code> with fields <code>:time</code>, <code>:distance</code>, and <code>:speed</code>. The values in this named tuple are the time, distance traveled, and mean speed for the cell in that cell type, i.e., all scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/motility.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.motilityStatistics-Tuple{Integer}" href="#pcvct.motilityStatistics-Tuple{Integer}"><code>pcvct.motilityStatistics</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">motilityStatistics(simulation_id::Integer[; direction=:any])</code></pre><p>Return the mean speed, distance traveled, and time alive for each cell in the simulation, broken down by cell type in the case of cell type transitions.</p><p>The time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first. If the cell transitions to a new cell type during the simulation, the time is counted for each cell type separately. Each cell type taken on by a given cell will be a key in the dictionary returned at that entry.</p><p><strong>Arguments</strong></p><ul><li><code>simulation_id::Integer</code>: The ID of the PhysiCell simulation. A <code>Simulation</code> object can also be passed in.</li><li><code>direction::Symbol</code>: The direction to compute the mean speed. Can be <code>:x</code>, <code>:y</code>, <code>:z</code>, or <code>:any</code> (default). If <code>:x</code>, for example, the mean speed is calculated using only the x component of the cell&#39;s movement.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Dict{String, NamedTuple}}</code>: A vector of dictionaries, one per cell in the simulation. Each dictionary has keys for each cell type taken on by the cell. The values are NamedTuples with fields <code>:time</code>, <code>:distance</code>, and <code>:speed</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ms = motilityStatistics(1) # a vector of dictionaries, one per cell in the simulation
ms[1][&quot;epithelial&quot;] # NamedTuple with fields :time, :distance, :speed for the first cell in the simulation corresponding to its time as an `epithelial` cell
ms[1][&quot;mesenchymal&quot;].time # time spent as a `mesenchymal` cell for the first cell in the simulation
ms[1][&quot;mesenchymal&quot;].distance # distance traveled as a `mesenchymal` cell for the first cell in the simulation
ms[1][&quot;mesenchymal&quot;].speed # mean speed as a `mesenchymal` cell for the first cell in the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/motility.jl#L56-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.PCVCTPCFResult" href="#pcvct.PCVCTPCFResult"><code>pcvct.PCVCTPCFResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PCVCTPCFResult</code></pre><p>A struct to hold the results of the pair correlation function (PCF) calculation.</p><p>The start and end radii for each annulus are stored in the <code>radii</code> field. Thus, there is one more radius than there are annuli, i.e. <code>length(radii) == size(g, 1) + 1</code>. Each column of <code>g</code> corresponds to a time point in the <code>time</code> field, hence <code>size(g, 2) == length(time)</code>.</p><p><strong>Fields</strong></p><ul><li><code>time::Vector{Float64}</code>: The time points at which the PCF was calculated.</li><li><code>pcf_result::PairCorrelationFunction.PCFResult</code>: The result of the PCF calculation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PairCorrelationFunction
time = 12.0
radii = [0.0, 1.0, 2.0]
g = [0.5, 1.2]
pcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCVCTPCFResult:
  Time: 12.0
  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0
  g: 0.5 - 1.2 (min - max)</code></pre><pre><code class="language-julia hljs">using PairCorrelationFunction
time = [12.0; 24.0; 36.0]
radii = [0.0, 1.0, 2.0]
g = [0.5 0.6 0.4; 1.2 1.15 1.4]
pcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCVCTPCFResult:
  Time: 12.0 - 36.0 (n = 3)
  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0
  g: 0.4 - 1.4 (min - max)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PairCorrelationFunction.pcf" href="#PairCorrelationFunction.pcf"><code>PairCorrelationFunction.pcf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcf(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types=center_cell_types; include_dead::Union{Bool,Tuple{Bool,Bool}}=false, dr::Float64=20.0)</code></pre><p>Calculate the pair correlation function (PCF) between two sets of cell types in a PhysiCell simulation snapshot or sequence.</p><p>The <code>center_cell_types</code> and <code>target_cell_types</code> can be strings or vectors of strings. This will compute one PCF rather than one for each pair of (center, target) cell types, i.e., all centers are compared to all targets. If omitted, the target<em>cell</em>types will be the same as the center<em>cell</em>types, i.e., not a cross-PCF. The <code>include_dead</code> argument can be a boolean or a tuple of booleans to indicate whether to include the dead centers and/or targets, respectively. The <code>dr</code> argument specifies the bin size (thickness of each annulus) for the PCF calculation.</p><p><strong>Arguments</strong></p><ul><li><code>S::AbstractPhysiCellSequence</code>: A <a href="../../man/analyzing_output/#PhysiCellSnapshot"><code>PhysiCellSnapshot</code></a> or <a href="../../man/analyzing_output/#PhysiCellSequence"><code>PhysiCellSequence</code></a> object.</li><li><code>center_cell_types</code>: The cell type name(s) to use as the center of the PCF.</li><li><code>target_cell_types</code>: The cell type name(s) to use as the target of the PCF.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Union{Bool,Tuple{Bool,Bool}}</code>: Whether to include dead cells in the PCF calculation. If a tuple, the first element indicates whether to include dead centers and the second element indicates whether to include dead targets.</li><li><code>dr::Float64</code>: The bin size for the PCF calculation.</li></ul><p><strong>Alternate methods</strong></p><ul><li><code>pcf(simulation::Simulation, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for a specific snapshot in a simulation.</li><li><code>pcf(simulation_id::Integer, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for a specific snapshot in a simulation by ID.</li><li><code>pcf(simulation_id::Integer, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for all snapshots in a simulation by ID.</li><li><code>pcf(simulation::Simulation, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for all snapshots in a simulation.</li></ul><p><strong>Returns</strong></p><p>A <a href="#pcvct.PCVCTPCFResult"><code>PCVCTPCFResult</code></a> object containing the time, radii, and g values of the PCF. Regardless of the type of <code>S</code>, the time and radii will always be vectors. If <code>S</code> is a snapshot, the g values will be a vector of the PCF. If <code>S</code> is a sequence, the g values will be a (length(radii)-1 x length(time)) matrix of the PCF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L87-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.getCellPositionsForPCF-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, Int64}, Bool, Bool}" href="#pcvct.getCellPositionsForPCF-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, Int64}, Bool, Bool}"><code>pcvct.getCellPositionsForPCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getCellPositionsForPCF(cells::DataFrame, cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Bool, is_3d::Bool)</code></pre><p>Get the positions of the cells for the PCF calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.isCrossPCF-Tuple{Vector{String}, Vector{String}}" href="#pcvct.isCrossPCF-Tuple{Vector{String}, Vector{String}}"><code>pcvct.isCrossPCF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isCrossPCF(center_cell_types::Vector{String}, target_cell_types::Vector{String})</code></pre><p>Check if the center and target cell types are the same (PCF) or disjoint (cross-PCF); if neither, throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.pcfConstants-Tuple{PhysiCellSnapshot, Float64}" href="#pcvct.pcfConstants-Tuple{PhysiCellSnapshot, Float64}"><code>pcvct.pcfConstants</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcfConstants(S::AbstractPhysiCellSequence, dr::Float64)</code></pre><p>Create a <code>Constants</code> object for the PCF calculation based on the mesh of the snapshot or sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.pcfSnapshotCalculation-Tuple{PhysiCellSnapshot, Vector{String}, Vector{String}, Dict{String, Int64}, Union{Bool, Tuple{Bool, Bool}}, Bool, PairCorrelationFunction.Constants}" href="#pcvct.pcfSnapshotCalculation-Tuple{PhysiCellSnapshot, Vector{String}, Vector{String}, Dict{String, Int64}, Union{Bool, Tuple{Bool, Bool}}, Bool, PairCorrelationFunction.Constants}"><code>pcvct.pcfSnapshotCalculation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcfSnapshotCalculation(snapshot::PhysiCellSnapshot, center_cell_types::Vector{String}, target_cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Union{Bool,Tuple{Bool,Bool}}, is_cross_pcf::Bool, constants::Constants)</code></pre><p>Calculate the pair correlation function (PCF) for a given snapshot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.preparePCF!-Tuple{pcvct.AbstractPhysiCellSequence, Any, Any, Union{Bool, Tuple{Bool, Bool}}, Float64}" href="#pcvct.preparePCF!-Tuple{pcvct.AbstractPhysiCellSequence, Any, Any, Union{Bool, Tuple{Bool, Bool}}, Float64}"><code>pcvct.preparePCF!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparePCF!(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types, include_dead::Union{Bool,Tuple{Bool,Bool}}, dr::Float64)</code></pre><p>Prepare the arguments for the PCF calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.preparePCFPlot-Tuple{Vector{pcvct.PCVCTPCFResult}}" href="#pcvct.preparePCFPlot-Tuple{Vector{pcvct.PCVCTPCFResult}}"><code>pcvct.preparePCFPlot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preparePCFPlot(results::Vector{PCVCTPCFResult}; time_unit=:min, distance_unit=:um)</code></pre><p>Prepare the time and radii for the PCF plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.processDistance-Tuple{Any, Any}" href="#pcvct.processDistance-Tuple{Any, Any}"><code>pcvct.processDistance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processDistance(distance::Vector{Float64}, distance_unit::Symbol)</code></pre><p>Process the distance vector to convert it to the desired distance unit. Options are :um, :mm, and :cm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L310-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.processPCFCellTypes-Tuple{Any}" href="#pcvct.processPCFCellTypes-Tuple{Any}"><code>pcvct.processPCFCellTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processPCFCellTypes(cell_types)</code></pre><p>Process the cell types for the PCF calculation so that they are always a vector of strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.processTime-Tuple{Any, Any}" href="#pcvct.processTime-Tuple{Any, Any}"><code>pcvct.processTime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processTime(time::Vector{Float64}, time_unit::Symbol)</code></pre><p>Process the time vector to convert it to the desired time unit. Options are :min, :s, :h, :d, :w, :mo, and :y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/pcf.jl#L283-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.MonadPopulationTimeSeries" href="#pcvct.MonadPopulationTimeSeries"><code>pcvct.MonadPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MonadPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a monad&#39;s population time series.</p><p>Note: unlike <code>SimulationPopulationTimeSeries</code>, this type does not save the data to a file.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">mpts = MonadPopulationTimeSeries(1)
mpts = MonadPopulationTimeSeries(monad(1))</code></pre><p><strong>Fields</strong></p><ul><li><code>monad_id::Int</code>: The ID of the monad.</li><li><code>monad_length::Int</code>: The number of simulations in the monad.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, NamedTuple}</code>: A dictionary where keys are cell type names and values are NamedTuples with fields <code>:counts</code>, <code>:mean</code>, and <code>:std</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L178-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.SimulationPopulationTimeSeries" href="#pcvct.SimulationPopulationTimeSeries"><code>pcvct.SimulationPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulationPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a simulation&#39;s population time series.</p><p>If constructed using a <code>Simulation</code> or an <code>Integer</code> (representing a simulation ID), it will save the time series inside the <code>simulations/simulation_id/summary/</code> folder. It will also look for previously computed time series there to avoid recomputing them.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">spts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has &quot;_include_dead&quot; appended</code></pre><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the simulation.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, Vector{Integer}}</code>: A dictionary where keys are cell type names and values are vectors of cell counts over time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L43-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.finalPopulationCount" href="#pcvct.finalPopulationCount"><code>pcvct.finalPopulationCount</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])</code></pre><p>Return the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.</p><p>Also works with the simulation ID:</p><pre><code class="nohighlight hljs">fpc = finalPopulationCount(1)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs">fpc = finalPopulationCount(simulation)
final_default_count = fpc[&quot;default&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L151-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.formatTimeRange-Tuple{Any}" href="#pcvct.formatTimeRange-Tuple{Any}"><code>pcvct.formatTimeRange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">formatTimeRange(v::Vector{Real})</code></pre><p>Format a vector of time points into a string representation.</p><p>Used only for printing certain classes to the console.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.getMeanCounts-Tuple{pcvct.SimulationPopulationTimeSeries}" href="#pcvct.getMeanCounts-Tuple{pcvct.SimulationPopulationTimeSeries}"><code>pcvct.getMeanCounts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getMeanCounts(apts::AbstractPopulationTimeSeries)</code></pre><p>Return the mean counts of a population time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L277-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.plotbycelltype" href="#pcvct.plotbycelltype"><code>pcvct.plotbycelltype</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plotbycelltype(T::AbstractTrial; include_dead::Bool=false, include_cell_types=:all, exclude_cell_types=String[])</code></pre><p>Plot the population time series of a trial by cell type.</p><p>Each cell type gets its own subplot. Each monad gets its own series within each subplot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L368-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.populationCount" href="#pcvct.populationCount"><code>pcvct.populationCount</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populationCount(snapshot, cell_type_to_name_dict::Dict{Int,String}=Dict{Int,String}(), labels::Vector{String}=String[]; include_dead::Bool=false)</code></pre><p>Return the population count of a snapshot as a dictionary with cell type names as keys and their counts as values.</p><p>If the snapshot is missing, it will return missing. This helps in cases where the files have been deleted, for example by pruning.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to count the cells in.</li><li><code>cell_type_to_name_dict::Dict{Int,String}</code>: A dictionary mapping cell type IDs to names (default is an empty dictionary). If not provided, it is read from the snapshot files.</li><li><code>labels::Vector{String}</code>: The labels to identify the cell data. If not provided, it is read from the snapshot files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Bool</code>: Whether to include dead cells in the count. Default is <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}" href="#pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}"><code>pcvct.populationTimeSeries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])</code></pre><p>Return the population time series of a simulation or a monad.</p><p>See <code>SimulationPopulationTimeSeries</code> and <code>MonadPopulationTimeSeries</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/population.jl#L261-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.processExcludeCellTypes-Tuple{Any}" href="#pcvct.processExcludeCellTypes-Tuple{Any}"><code>pcvct.processExcludeCellTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processExcludeCellTypes(exclude_cell_types)</code></pre><p>Process the <code>exclude_cell_types</code> argument to ensure it is in the correct format.</p><p>If <code>exclude_cell_types</code> is a string, it is converted to a single-element vector. If it is a vector, it is returned as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/preprocessing.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.processIncludeCellTypes-Tuple{Any, Vector{String}}" href="#pcvct.processIncludeCellTypes-Tuple{Any, Vector{String}}"><code>pcvct.processIncludeCellTypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">processIncludeCellTypes(include_cell_types, all_cell_types::Vector{String})</code></pre><p>Process the <code>include_cell_types</code> argument to ensure it is in the correct format.</p><p>Uses the <code>all_cell_types</code> vector to determine the valid cell types.</p><p><strong>Arguments</strong></p><ul><li><code>include_cell_types</code>: the cell types to include in the analysis (default is <code>:all_in_one</code>). Full list of options:<ul><li><code>:all</code> - return the vector of all cell types</li><li><code>:all_in_one</code> - return a vector with a single element, which is a vector of all cell types</li><li><code>&quot;cell_type_1&quot;</code> - return [&quot;cell<em>type</em>1&quot;]</li><li><code>[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]</code> - return [&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;]</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]]</code> - return [[&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;]]</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;], &quot;cell_type_3&quot;]</code> - return [[&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;], &quot;cell<em>type</em>3&quot;]</li></ul></li><li><code>all_cell_types</code>: a vector of all cell types in the simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/preprocessing.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.AverageSubstrateTimeSeries" href="#pcvct.AverageSubstrateTimeSeries"><code>pcvct.AverageSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AverageSubstrateTimeSeries</code></pre><p>A struct to hold the average substrate concentrations over time for a PhysiCell simulation.</p><p>Constructed using <code>AverageSubstrateTimeSeries(x)</code> where <code>x</code> is any of the following: <code>Integer</code> (simulation ID), <code>PhysiCellSequence</code>, or <code>Simulation</code>.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>substrate_concentrations::Dict{String, Vector{Real}}</code>: A dictionary mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><p>```julia asts = pcvct.AverageSubstrateTimeSeries(1) # Load average substrate time series for Simulation 1 asts.time # Get the time points asts[&quot;time&quot;] # alternative way to get the time points asts[&quot;oxygen&quot;] # Get the oxygen concentration over time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.ExtracellularSubstrateTimeSeries" href="#pcvct.ExtracellularSubstrateTimeSeries"><code>pcvct.ExtracellularSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtracellularSubstrateTimeSeries</code></pre><p>A struct to hold the mean extracellular substrate concentrations per cell type over time for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>data::Dict{String, Dict{String, Vector{Real}}}</code>: A dictionary mapping cell type names to dictionaries mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ests = pcvct.ExtracellularSubstrateTimeSeries(1) # Load extracellular substrate time series for Simulation 1
ests.time # Get the time points
ests[&quot;cancer&quot;][&quot;oxygen&quot;] # Get the oxygen concentration over time for the cancer cell type

ests = pcvct.ExtracellularSubstrateTimeSeries(simulation; include_dead=true) # Load extracellular substrate time series for a Simulation object, including dead cells
ests[&quot;time&quot;] # Alternate way to get the time points
ests[&quot;cd8&quot;][&quot;IFNg&quot;] # Get the interferon gamma concentration over time for the CD8 cell type

ests = pcvct.ExtracellularSubstrateTimeSeries(sequence) # Load extracellular substrate time series for a PhysiCellSequence object</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L219-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.VoxelWeights" href="#pcvct.VoxelWeights"><code>pcvct.VoxelWeights</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VoxelWeights</code></pre><p>A struct to hold the voxel weights for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>use_weights::Bool</code>: Whether to use weights for the voxel volumes. If all voxel volumes are the same, this is set to <code>false</code>.</li><li><code>weights::Vector{Real}</code>: The weights for the voxel volumes.</li><li><code>weight_total::Real</code>: The total weight of the voxel volumes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.averageExtracellularSubstrate" href="#pcvct.averageExtracellularSubstrate"><code>pcvct.averageExtracellularSubstrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">averageExtracellularSubstrate(snapshot::PhysiCellSnapshot, cell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(), substrate_names::Vector{String}=String[], labels::Vector{String}=String[]; include_dead::Bool=false)</code></pre><p>Compute the average extracellular substrate concentrations for each cell type in a PhysiCell snapshot.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to analyze.</li><li><code>cell_type_to_name_dict::Dict{Int, String}</code>: A dictionary mapping cell type IDs to their names. If not provided, it is read from the snapshot files.</li><li><code>substrate_names::Vector{String}</code>: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.</li><li><code>labels::Vector{String}</code>: The labels to use for the cells. If not provided, it is read from the snapshot files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Bool</code>: Whether to include dead cells in the analysis (default is <code>false</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, Dict{String, Real}}</code>: A dictionary mapping cell type names to dictionaries mapping substrate names to their average concentrations.</li></ul><p>That is, if <code>aes</code> is the output of this function, then <code>aes[&quot;cell_type_name&quot;][&quot;substrate_name&quot;]</code> is the average concentration of <code>substrate_name</code> for cells of type <code>cell_type_name</code> in the snapshot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L147-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.averageSubstrate" href="#pcvct.averageSubstrate"><code>pcvct.averageSubstrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">averageSubstrate(snapshot::PhysiCellSnapshot, substrate_names::Vector{String}=String[], voxel_weights::VoxelWeights=VoxelWeights(snapshot))</code></pre><p>Compute the average substrate concentrations for every substrate in a PhysiCell snapshot.</p><p>The voxel volumes are used as weights if they are not all the same.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to analyze.</li><li><code>substrate_names::Vector{String}</code>: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.</li><li><code>voxel_weights::VoxelWeights</code>: The voxel weights to use. If not provided, it is computed from the snapshot.</li></ul><p><strong>Returns</strong></p><ul><li><code>data::Dict{String, Real}</code>: A dictionary mapping substrate names to their average concentrations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L31-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.computeVoxelIndices-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}" href="#pcvct.computeVoxelIndices-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><code>pcvct.computeVoxelIndices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">computeVoxelIndices(cells::DataFrame, mesh::Dict{String, Vector{Float64}})</code></pre><p>Compute the voxel (linear) indices (1-nx<em>ny</em>nz) for a set of cells in a PhysiCell simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="pcvct.computeVoxelSubscripts-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}" href="#pcvct.computeVoxelSubscripts-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><code>pcvct.computeVoxelSubscripts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">computeVoxelSubscripts(cells::DataFrame, mesh::Dict{String, Vector{Float64}})</code></pre><p>Compute the voxel subscripts (1-nx, 1-ny, 1-nz) for a set of cells in a PhysiCell simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman/pcvct/blob/4a42256a6ae4475da17d4ee6e7527ba08787c2ec/src/analysis/substrate.jl#L190-L194">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/">« Index</a><a class="docs-footer-nextpage" href="../classes/">Classes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 5 May 2025 22:26">Monday 5 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
