<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analyzing output · pcvct</title><meta name="title" content="Analyzing output · pcvct"/><meta property="og:title" content="Analyzing output · pcvct"/><meta property="twitter:title" content="Analyzing output · pcvct"/><meta name="description" content="Documentation for pcvct."/><meta property="og:description" content="Documentation for pcvct."/><meta property="twitter:description" content="Documentation for pcvct."/><meta property="og:url" content="https://drbergman.github.io/pcvct/man/analyzing_output/"/><meta property="twitter:url" content="https://drbergman.github.io/pcvct/man/analyzing_output/"/><link rel="canonical" href="https://drbergman.github.io/pcvct/man/analyzing_output/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">pcvct</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../best_practices/">Best practices</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../covariations/">CoVariations</a></li><li><a class="tocitem" href="../data_directory/">Data directory</a></li><li><a class="tocitem" href="../intracellular_inputs/">Intracellular inputs</a></li><li><a class="tocitem" href="../known_limitations/">Known limitations</a></li><li><a class="tocitem" href="../physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../sensitivity_analysis/">Sensitivity analysis</a></li><li class="is-active"><a class="tocitem" href>Analyzing output</a><ul class="internal"><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#Loading-output"><span>Loading output</span></a></li><li><a class="tocitem" href="#Population-plots"><span>Population plots</span></a></li><li><a class="tocitem" href="#Substrate-analysis"><span>Substrate analysis</span></a></li><li><a class="tocitem" href="#Motility-analysis"><span>Motility analysis</span></a></li><li><a class="tocitem" href="#Pair-correlation-function-(PCF)"><span>Pair correlation function (PCF)</span></a></li></ul></li><li><a class="tocitem" href="../developer_guide/">Developer guide</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../../lib/classes/">Classes</a></li><li><a class="tocitem" href="../../lib/compilation/">Compilation</a></li><li><a class="tocitem" href="../../lib/components/">Components</a></li><li><a class="tocitem" href="../../lib/configuration/">Configuration</a></li><li><a class="tocitem" href="../../lib/creation/">Creation</a></li><li><a class="tocitem" href="../../lib/database/">Database</a></li><li><a class="tocitem" href="../../lib/deletion/">Deletion</a></li><li><a class="tocitem" href="../../lib/export/">Export</a></li><li><a class="tocitem" href="../../lib/hpc/">HPC</a></li><li><a class="tocitem" href="../../lib/ic_cell/">Cell Initial Conditions</a></li><li><a class="tocitem" href="../../lib/ic_ecm/">ECM Initial Conditions</a></li><li><a class="tocitem" href="../../lib/import/">Import</a></li><li><a class="tocitem" href="../../lib/loader/">Loader</a></li><li><a class="tocitem" href="../../lib/movie/">Movie</a></li><li><a class="tocitem" href="../../lib/pcvct/">Core</a></li><li><a class="tocitem" href="../../lib/physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../../lib/physicell_version/">PhysiCell Version</a></li><li><a class="tocitem" href="../../lib/pruner/">Pruner</a></li><li><a class="tocitem" href="../../lib/recorder/">Recorder</a></li><li><a class="tocitem" href="../../lib/runner/">Runner</a></li><li><a class="tocitem" href="../../lib/sensitivity/">Sensitivity</a></li><li><a class="tocitem" href="../../lib/user_api/">User API</a></li><li><a class="tocitem" href="../../lib/variations/">Variations</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../../misc/database_upgrades/">Database upgrades</a></li><li><a class="tocitem" href="../../misc/renaming/">Renaming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Analyzing output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analyzing output</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/drbergman/pcvct/blob/main/docs/src/man/analyzing_output.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Analyzing-output"><a class="docs-heading-anchor" href="#Analyzing-output">Analyzing output</a><a id="Analyzing-output-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-output" title="Permalink"></a></h1><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>Julia has several packages for plotting. Here, we will use <code>Plots.jl</code> which you can install with</p><pre><code class="language-julia-repl hljs">pkg&gt; add Plots</code></pre><h2 id="Loading-output"><a class="docs-heading-anchor" href="#Loading-output">Loading output</a><a id="Loading-output-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-output" title="Permalink"></a></h2><h3 id="PhysiCellSnapshot"><a class="docs-heading-anchor" href="#PhysiCellSnapshot"><code>PhysiCellSnapshot</code></a><a id="PhysiCellSnapshot-1"></a><a class="docs-heading-anchor-permalink" href="#PhysiCellSnapshot" title="Permalink"></a></h3><p>The base unit of PhysiCell output is the <code>PhysiCellSnapshot</code>. These are currently considered pcvct internals and so the API may change. Each snapshot records the path to the PhysiCell output folder, its index in the sequence of outputs, the time of the snapshot in the simulation, and optionally the cell, substrate, and mesh data at that snapshot.</p><h3 id="PhysiCellSequence"><a class="docs-heading-anchor" href="#PhysiCellSequence"><code>PhysiCellSequence</code></a><a id="PhysiCellSequence-1"></a><a class="docs-heading-anchor-permalink" href="#PhysiCellSequence" title="Permalink"></a></h3><p>A <code>PhysiCellSequence</code> is the full sequence of snapshots corresponding to a single PhysiCell simulation. As with <code>PhysiCellSnapshot</code>&#39;s, these are currently considered internals and their API may change. In addition to the path to the PhysiCell output folder and the vector of <code>PhysiCellSnapshot</code>&#39;s, it holds metadata for the simulation.</p><h3 id="getCellDataSequence"><a class="docs-heading-anchor" href="#getCellDataSequence"><code>getCellDataSequence</code></a><a id="getCellDataSequence-1"></a><a class="docs-heading-anchor-permalink" href="#getCellDataSequence" title="Permalink"></a></h3><p>The main function to get sequences of cell data is <code>getCellDataSequence</code>. It accepts any of a simulation ID (<code>&lt;:Integer</code>), a simulation (<code>::Simulation</code>), or a sequence (<code>::PhysiCellSequence</code>) and either a single label (<code>::String</code>) or a vector of labels (<code>::Vector{String}</code>). For each cell in the simulation (as determined by the cell ID), the output creates a dictionary entry (the key is the integer cell ID) whose value is a named tuple with the input labels as keys as well as <code>:time</code>. This means that if one sets</p><pre><code class="language-julia hljs">data = getCellDataSequence(1, &quot;position&quot;)</code></pre><p>Then one can access the positions of the cell with ID 78 by</p><pre><code class="language-julia hljs">cell_78_positions = data[78].position # an Nx3 matrix for the N integer-indexed outputs (ignores the `initial_*` and `final_*` files)</code></pre><p>and plot the x-coordinates of this cell over time using</p><pre><code class="language-julia hljs">cell_78_times = data[78].time

using Plots
plot(cell_78_times, cell_78_positions[:,1])</code></pre><p><strong>Note</strong>: Each call to <code>getCellDataSequence</code> will load <em>all</em> the data unless a <code>PhysiCellSequence</code> is passed in. Plan your analyses accordingly as loading simulation data is not fast.</p><h2 id="Population-plots"><a class="docs-heading-anchor" href="#Population-plots">Population plots</a><a id="Population-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Population-plots" title="Permalink"></a></h2><h3 id="Group-by-Monad"><a class="docs-heading-anchor" href="#Group-by-Monad">Group by Monad</a><a id="Group-by-Monad-1"></a><a class="docs-heading-anchor-permalink" href="#Group-by-Monad" title="Permalink"></a></h3><p>Plotting population plots is one the most basic analysis tasks and pcvct makes it super easy! If you call <code>plot</code> on a <code>Simulation</code>, <code>Monad</code>, <code>Sampling</code>, or the return value of a call to <code>run</code> (though not for a sensitivity analysis), then a sequence of panels will be generated in a single figure. Each panel will correspond to a <code>Monad</code> (replicates using the same parameter values) and will plot mean +/- SD for each cell type.</p><p>Finer-grained control of the output is possible, too!</p><ul><li>to include dead cells in your counts: <code>plot(...; ..., include_dead=true, ...)</code></li><li>select a subset of cell types to include: <code>plot(...; ..., include_cell_types=&quot;cancer&quot;, ...)</code></li><li>select a subset of cell types to exclude: <code>plot(...; ..., exclude_cell_types=&quot;cancer&quot;, ...)</code></li></ul><p>The <code>include_cell_types</code> and <code>exclude_cell_types</code> can also accept a <code>Vector{String}</code> to include or exclude certain cell types, respectively. Furthermore, if the value of <code>include_cell_types</code> is a <code>Vector</code> and one of its entries is a <code>Vector{String}</code>, pcvct will interpret this to sum up those cell types. In other words, to get the total tumor cell count in addition to the epithelial (<code>&quot;epi&quot;</code>) and mesenchymal (<code>&quot;mes&quot;</code>) components, you could use</p><pre><code class="language-julia hljs">using Plots
plot(Monad(1); include_cell_types=[&quot;epi&quot;, &quot;mes&quot;, [&quot;epi&quot;, &quot;mes&quot;]])</code></pre><p>Finally, this makes use of Julia&#39;s Plot Recipes (see <a href="https://docs.juliaplots.org/stable/RecipesBase/">RecipesBase.jl</a>) so any standard plotting keywords can be passed in:</p><pre><code class="language-julia hljs">using Plots
colors = [:blue :red] # Note the absence of a `,` or `;`. This is how Julia requires different series parameters to be passed in 
plot(Simulation(1); color=colors, include_cell_types=[&quot;cd8&quot;, &quot;cancer&quot;]) # will plot cd8s in blue and cancer in red.</code></pre><h3 id="Group-by-cell-type"><a class="docs-heading-anchor" href="#Group-by-cell-type">Group by cell type</a><a id="Group-by-cell-type-1"></a><a class="docs-heading-anchor-permalink" href="#Group-by-cell-type" title="Permalink"></a></h3><p>Invert the above by including all data for a single cell type across all monads in a single panel with a call to <code>plotbycelltype</code>. This function works on any <code>T&lt;:AbstractTrial</code> (<code>Simulation</code>, <code>Monad</code>, <code>Sampling</code>, or <code>Trial</code>) as well as any <code>PCVCTOutput</code> object (the return value to <code>run</code>). Everything above for <code>plot</code> applies here.</p><pre><code class="language-julia hljs">using Plots
plotbycelltype(Sampling(1); include_cell_types=[&quot;epi&quot;, &quot;mes&quot;, [&quot;epi&quot;, &quot;mes&quot;]], color=[:blue :red :purple], labels=[&quot;epi&quot; &quot;mes&quot; &quot;both&quot;], legend=true)</code></pre><h2 id="Substrate-analysis"><a class="docs-heading-anchor" href="#Substrate-analysis">Substrate analysis</a><a id="Substrate-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Substrate-analysis" title="Permalink"></a></h2><p>pcvct supports two ways to summarize substrate information over time.</p><h3 id="AverageSubstrateTimeSeries"><a class="docs-heading-anchor" href="#AverageSubstrateTimeSeries"><code>AverageSubstrateTimeSeries</code></a><a id="AverageSubstrateTimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#AverageSubstrateTimeSeries" title="Permalink"></a></h3><p>An <code>AverageSubstrateTimeSeries</code> gives the time series for the average substrate across the entire domain.</p><pre><code class="language-julia hljs">simulation_id = 1
asts = pcvct.AverageSubstrateTimeSeries(simulation_id)
using Plots
plot(asts.time, asts[&quot;oxygen&quot;])</code></pre><h3 id="ExtracellularSubstrateTimeSeries"><a class="docs-heading-anchor" href="#ExtracellularSubstrateTimeSeries"><code>ExtracellularSubstrateTimeSeries</code></a><a id="ExtracellularSubstrateTimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#ExtracellularSubstrateTimeSeries" title="Permalink"></a></h3><p>An <code>ExtracellularSubstrateTimeSeries</code> gives the time series for the average substrate concentration in the extracellular space neighboring all cells of a given cell type. In a simulation with <code>cd8</code> cells and <code>IFNg</code> diffusible substrate, plot the average concentration of IFNg experienced by CD8+ T cells using the following:</p><pre><code class="language-julia hljs">simulation_id = 1
ests = pcvct.ExtracellularSubstrateTimeSeries(simulation_id)
using Plots
plot(ests.time, ests[&quot;cd8&quot;][&quot;IFNg&quot;])</code></pre><h2 id="Motility-analysis"><a class="docs-heading-anchor" href="#Motility-analysis">Motility analysis</a><a id="Motility-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Motility-analysis" title="Permalink"></a></h2><p>The <code>motilityStatistics</code> function returns the time alive, distance traveled, and mean speed for each cell in the simulation. For each cell, these values are split amongst the cell types the given cell assumed throughout (or at least at the save times). To calculate these values, the cell type at the start of the save interval is used and the net displacement is used to calculate the speed. Optionally, users can pass in a coordinate direction to only consider speed in a given axis.</p><pre><code class="language-julia hljs">simulation_id = 1
mss = motilityStatistics(simulation_id)
all_mean_speeds_as_mes = [ms[&quot;mes&quot;].speed for ms in mss if haskey(ms, &quot;mes&quot;)] # concatenate all speeds as a &quot;mes&quot; cell type (if the given cell ever was a &quot;mes&quot;)
all_times_as_mes = [ms[&quot;mes&quot;].time for ms in mss if haskey(ms, &quot;mes&quot;)] # similarly, get the time spent in the &quot;mes&quot; state
mean_mes_speed = all_mean_speeds_as_mes .* all_times_as_mes |&gt; sum # start computing the weighted average of their speeds
mean_mes_speed /= sum(all_times_as_mes) # finish computing weighted average</code></pre><pre><code class="language-julia hljs">mss = motilityStatistics(simulation_id; direction=:x) # only consider the movement in the x direction</code></pre><h2 id="Pair-correlation-function-(PCF)"><a class="docs-heading-anchor" href="#Pair-correlation-function-(PCF)">Pair correlation function (PCF)</a><a id="Pair-correlation-function-(PCF)-1"></a><a class="docs-heading-anchor-permalink" href="#Pair-correlation-function-(PCF)" title="Permalink"></a></h2><p>Sometimes referred to as radial distribution functions, the pair correlation function (PCF) computes the density of target cells around center cells. If the two sets of cells are the same (centers = targets), this is called PCF. If the two are not equal, this is sometimes called cross-PCF. Both can be computed with a call to <code>pcvct.pcf</code> (or just <code>pcf</code> if <code>using PairCorrelationFunction</code> has been called).</p><h3 id="Arguments"><a class="docs-heading-anchor" href="#Arguments">Arguments</a><a id="Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Arguments" title="Permalink"></a></h3><p>PCF computations can readily be called on <code>PhysiCellSnapshot</code>&#39;s, <code>PhysiCellSequence</code>&#39;s, or <code>Simulation</code>&#39;s. If the first argument in a call to <code>pcf</code> is an <code>Integer</code>, this is treated as a simulation ID. If this is followed by an index (of type <code>Integer</code> or value <code>:initial</code> or <code>:final</code>), this is treated as a snapshot; otherwise, it computes the PCF for the entire simulation.</p><p>The next argument is the cell type to use as the center cells as either a <code>String</code> or <code>Vector{String}</code>, representing the name of the cell type(s). If the target cells are different from the center cells, the next argument is the target cell type as either a <code>String</code> or <code>Vector{String}</code>. If omitted, the target cell type is the same as the center cell type and a (non-cross) PCF is computed. The resulting sets of center and target cell types must either be identical or have no overlap.</p><h3 id="Keyword-arguments"><a class="docs-heading-anchor" href="#Keyword-arguments">Keyword arguments</a><a id="Keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-arguments" title="Permalink"></a></h3><p>The following keyword arguments are available:</p><ul><li><code>include_dead::Union{Bool, Tuple{Bool,Bool}} = false</code>: whether to include dead cells in the PCF computation.<ul><li>If <code>true</code>, all cells are included.</li><li>If <code>false</code>, only live cells are included.</li><li>If a tuple, the first value is for the center cells and the second is for the target cells.</li></ul></li><li><code>dr::Float64 = 20.0</code>: the step size for the radial bins in micrometers.</li></ul><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p>The output of <code>pcf</code> is a <code>PCVCTPCFResult</code> object which has two fields: <code>time</code> and <code>pcf_result</code>. The <code>time</code> field is always a vector of the time points at which the PCF was computed, even if computing PCF for a single snapshot. The <code>pcf_result</code> is of type <code>PairCorrelationFunction.PCFResult</code> and has two fields: <code>radii</code> and <code>g</code>. The <code>radii</code> is the set of cutoffs used to compute the PCF and <code>g</code> is either a vector or a matrix of the PCF values of size <code>length(radii)-1</code> by <code>length(time)</code>.</p><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><p>An API to make use of the <code>PairCorrelationFunction</code> package plotting interface is available through the <code>plot</code> function. Simply pass in the <code>PCVCTPCFResult</code>! You can pass in as many such objects as you like or pass in a <code>Vector{PCVCTPCFResult}</code>. In this case, these are interpreted as stochastic realizations of the same PCF and summary statistics are used to plot. See the <code>PairCorrelationFunction</code> documentation for more details.</p><p>The pcvct implementation supports two keyword arguments:</p><ul><li><code>time_unit::Symbol = :min</code>: the time unit to use for the time axis (only relevant if the <code>PCVCTPCFResult</code> has more than one time point).<ul><li>The default is <code>:min</code> and the other options are <code>:s</code>, <code>:h</code>, <code>:d</code>, <code>:w</code>, <code>:mo</code>, <code>:y</code>.</li></ul></li><li><code>distance_unit::Symbol = :um</code>: the distance unit to use for the distance axis.<ul><li>The default is <code>:um</code> and the other options are <code>:mm</code> and <code>:cm</code>.</li></ul></li></ul><p>Finally, a keyword argument supported by <code>PairCorrelationFunction</code> is <code>colorscheme</code> which can be used to change the colorscheme of the color map. pcvct overrides the default from <code>PairCorrelationFunction</code> (<code>:tofino</code>) with <code>:cork</code> to use white to represent values near one.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs">using pcvct
simulation_id = 1
result = pcvct.pcf(simulation_id, &quot;cancer&quot;, &quot;cd8&quot;) #! using PairCorrelationFunction will obviate the need to prefix with `pcvct`
plot(result) #! heatmap of proximity of (living) cd8s to (living) cancer cells throughout simulation 1</code></pre><pre><code class="language-julia hljs">using pcvct
monad = Monad(1) #! let&#39;s assume that there are &gt;1 simulations in this monad
results = [pcvct.pcf(simulation_id, :final, &quot;cancer&quot;, &quot;cd8&quot;) for simulation_id in getSimulationIDs(monad)] #! one vector of PCF values for each simulation at the final snapshot
plot(results) #! line plot of average PCF values against radius across the monad +/- 1 SD</code></pre><pre><code class="language-julia hljs">using pcvct
monad = Monad(1) #! let&#39;s assume that there are &gt;1 simulations in this monad
results = [pcvct.pcf(simulation_id, &quot;cancer&quot;, &quot;cd8&quot;) for simulation_id in getSimulationIDs(monad)] #! one matrix of PCF values for each simulation across all time points
plot(results) #! heatmap of average PCF values with time on the x-axis and radius on the y-axis; averages omit NaN values that can occur at higher radii</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sensitivity_analysis/">« Sensitivity analysis</a><a class="docs-footer-nextpage" href="../developer_guide/">Developer guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 8 May 2025 10:27">Thursday 8 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
