var documenterSearchIndex = {"docs":
[{"location":"lib/components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"lib/components/","page":"Components","title":"Components","text":"Allows for combining PhysiCell input components into whole inputs.","category":"page"},{"location":"lib/components/","page":"Components","title":"Components","text":"Currently, only supports this for intracellular ODE (libRoadRunner) models.","category":"page"},{"location":"lib/components/#pcvct.PhysiCellComponent","page":"Components","title":"pcvct.PhysiCellComponent","text":"PhysiCellComponent\n\nA struct to hold the information about a component that is used to assemble an input of PhysiCell.\n\nThe type and name are the only fields that are compared for equality. The type represents the type of component that it is. Currently, only \"roadrunner\" is supported. The name is the name of the file inside the components/type/ directory. The id is the id of the component, which will be -1 to indicate it is not yet set. The id is used to link which cell definition(s) use which component(s).\n\nFields\n\ntype::String: The type of the component (e.g., \"roadrunner\", \"dfba\", \"maboss\").\nname::String: The name of the component (e.g., \"component.xml\").\nid::Int: The id of the component (e.g., 1, 2, 3). This is used to link which cell definition(s) use which component(s). A value of -1 indicates that the id is not yet set.\n\nExamples\n\njulia> PhysiCellComponent(\"roadrunner\", \"test.xml\")\nPhysiCellComponent(\"roadrunner\", \"test.xml\", -1)\n\n```jldoctest component = PhysiCellComponent(\"roadrunner\", \"test.xml\") PhysiCellComponent(component, 78) # set the id to 78; users should not need to do this\n\noutput\n\nPhysiCellComponent(\"roadrunner\", \"test.xml\", 78)\n\n\n\n\n\n","category":"type"},{"location":"lib/components/#pcvct.assembleIntracellular!-Tuple{Dict{String, <:Union{PhysiCellComponent, Vector{PhysiCellComponent}}}}","page":"Components","title":"pcvct.assembleIntracellular!","text":"assembleIntracellular!(cell_to_components_dict::Dict{String,<:Union{PhysiCellComponent,Vector{PhysiCellComponent}}}; kwargs...)\n\nHelper function to ensure the values of each entry is a vector of PhysiCellComponents.\n\n\n\n\n\n","category":"method"},{"location":"lib/components/#pcvct.assembleIntracellular!-Tuple{Dict{String, Vector{PhysiCellComponent}}}","page":"Components","title":"pcvct.assembleIntracellular!","text":"assembleIntracellular!(cell_to_components_dict::Dict{String,Vector{PhysiCellComponent}}; name::String=\"assembled\", skip_db_insert::Bool=false)\n\nAssembles the intracellular components for the given cell types into a single file.\n\nFirst, check if the components have been previously assembled. If so, return that folder name. If not, create a new folder and save the components there as a single file along with the assembly manifest; finally, update the database with the new folder.\n\nArguments\n\ncell_to_components_dict::Dict{String,Vector{PhysiCellComponent}}: A dictionary mapping cell types to their components.\nname::String: The name of the folder to create (default is \"assembled\").\nskip_db_insert::Bool: If true, skip the database insert (default is false). Skipped when importing a project. Users should not need to set this.\n\nReturns\n\nfolder::String: The name of the folder where the components were assembled.\n\n\n\n\n\n","category":"method"},{"location":"lib/components/#pcvct.findComponentID-Tuple{Dict, PhysiCellComponent}","page":"Components","title":"pcvct.findComponentID","text":"findComponentID(assembly_manifest::Dict, component::PhysiCellComponent)\n\nFind the ID of the given component in the assembly manifest.\n\n\n\n\n\n","category":"method"},{"location":"lib/components/#pcvct.getIntracellularFolder-Tuple{Dict}","page":"Components","title":"pcvct.getIntracellularFolder","text":"getIntracellularFolder(assembly_manifest::Dict)\n\nGet the folder that contains the intracellular assembly manifest that is equivalent to the given assembly manifest, if one exists.\n\nIf no such folder exists, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/components/#pcvct.intracellularAssemblyManifestsEquivalent-Tuple{Dict, Dict}","page":"Components","title":"pcvct.intracellularAssemblyManifestsEquivalent","text":"intracellularAssemblyManifestsEquivalent(A::Dict, B::Dict)\n\nCompare two intracellular assembly manifests to see if they are equivalent.\n\nTwo manifests may assign different IDs to the same components. This function compares the component files to see if the manifests are equivalent.\n\n\n\n\n\n","category":"method"},{"location":"lib/components/#pcvct.updateIntracellularComponentIDs!-Tuple{Dict{String, Vector{PhysiCellComponent}}, String}","page":"Components","title":"pcvct.updateIntracellularComponentIDs!","text":"updateIntracellularComponentIDs!(cell_to_components_dict::Dict{String,Vector{PhysiCellComponent}}, path_to_folder::String)\n\nUpdate the IDs of the components in the given dictionary to match those in the assembly manifest in the given folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"lib/configuration/","page":"Configuration","title":"Configuration","text":"Interface with the configuration file necessary for PhysiCell simulations.","category":"page"},{"location":"lib/configuration/","page":"Configuration","title":"Configuration","text":"Provide functionality for accessing and modifying elements in any XML, including the PhysiCell configuration file, XML rules file, combined intracellular XML file, XML IC cell file, and XML IC ECM file.","category":"page"},{"location":"lib/configuration/#pcvct.project_locations","page":"Configuration","title":"pcvct.project_locations","text":"project_locations::ProjectLocations\n\nThe global ProjectLocations object that contains information about the locations of input files in the project.\n\n\n\n\n\n","category":"constant"},{"location":"lib/configuration/#pcvct.ProjectLocations","page":"Configuration","title":"pcvct.ProjectLocations","text":"ProjectLocations\n\nA struct that contains information about the locations of input files in the project.\n\nThe global instance of this struct is project_locations and is created by reading the inputs.toml file in the data_dir directory. It is instantiated with the parseProjectInputsConfigurationFile function.\n\nFields\n\nall::NTuple{L,Symbol}: A tuple of all locations in the project.\nrequired::NTuple{M,Symbol}: A tuple of required locations in the project.\nvaried::NTuple{N,Symbol}: A tuple of varied locations in the project.\n\n\n\n\n\n","category":"type"},{"location":"lib/configuration/#pcvct.apoptosisPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.apoptosisPath","text":"apoptosisPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the apoptosis for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.attackRatesPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.attackRatesPath","text":"attackRatesPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the attack rates for the given cell definition (or deeper if more path elements are given).\n\nThe first optional path element identifies the name of the cell type to attack. This can be provided in either of the following formats:\n\npcvct.attackRatesPath(\"cd8\", \"cancer\")\npcvct.attackRatesPath(\"cd8\", \"attack_rate:name:cancer\")\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.cellDefinitionPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.cellDefinitionPath","text":"cellDefinitionPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the cell definition or deeper if more path elements are given.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.cellInteractionsPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.cellInteractionsPath","text":"cellInteractionsPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the cell interactions for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.columnName-Tuple{Vector{<:AbstractString}}","page":"Configuration","title":"pcvct.columnName","text":"columnName(xml_path)\n\nReturn the column name corresponding to the given XML path.\n\nWorks on a vector of strings, an XMLPath object, or a ElementaryVariation object. Inverse of columnNameToXMLPath.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.columnNameToXMLPath-Tuple{String}","page":"Configuration","title":"pcvct.columnNameToXMLPath","text":"columnNameToXMLPath(column_name::String)\n\nReturn the XML path corresponding to the given column name.\n\nInverse of columnName.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.createInputsTOMLTemplate-Tuple{String}","page":"Configuration","title":"pcvct.createInputsTOMLTemplate","text":"createInputsTOMLTemplate(path_to_toml::String)\n\nCreate a template TOML file for the inputs configuration at the specified path.\n\nThis is something users should not be changing. It is something in the codebase to hopefully facilitate extending this framework to other ABM frameworks.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.createXMLFile-Tuple{Symbol, pcvct.AbstractMonad}","page":"Configuration","title":"pcvct.createXMLFile","text":"createXMLFile(location::Symbol, M::AbstractMonad)\n\nCreate XML file for the given location and variation_id in the given monad.\n\nThe file is placed in $(location)_variations and can be accessed from there to run the simulation(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.customDataPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.customDataPath","text":"customDataPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the custom data for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.cyclePath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.cyclePath","text":"cyclePath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the cycle for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.deathPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.deathPath","text":"deathPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the death for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.folderIsVaried-Tuple{Symbol, String}","page":"Configuration","title":"pcvct.folderIsVaried","text":"folderIsVaried(location::Symbol, folder::String)\n\nReturn true if the location folder allows for varying the input files, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getCellParameterName-Tuple{String}","page":"Configuration","title":"pcvct.getCellParameterName","text":"getCellParameterName(column_name::String)\n\nReturn the short name of the varied parameter associated with a cell definition for the given column name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getChildByAttribute-Tuple{LightXML.XMLElement, Vector{<:AbstractString}}","page":"Configuration","title":"pcvct.getChildByAttribute","text":"getChildByAttribute(parent_element::XMLElement, path_element_split::Vector{<:AbstractString})\n\nGet the child element of parent_element that matches the given tag and attribute.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getContent-Tuple{LightXML.XMLDocument, Vector{<:AbstractString}}","page":"Configuration","title":"pcvct.getContent","text":"getContent(xml_doc::XMLDocument, xml_path::Vector{<:AbstractString}; required::Bool=true)\n\nGet the content of the element in the XML document that matches the given path. See retrieveElement.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getICCellParameterName-Tuple{String}","page":"Configuration","title":"pcvct.getICCellParameterName","text":"getICCellParameterName(name::String)\n\nReturn the short name of the varied parameter associated with a cell patch for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getICECMParameterName-Tuple{String}","page":"Configuration","title":"pcvct.getICECMParameterName","text":"getICECMParameterName(name::String)\n\nReturn the short name of the varied parameter associated with a ECM patch for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.getRuleParameterName-Tuple{String}","page":"Configuration","title":"pcvct.getRuleParameterName","text":"getRuleParameterName(name::String)\n\nReturn the short name of the varied parameter associated with a ruleset for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.icCellsPath-Tuple{String, String, Any, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.icCellsPath","text":"icCellsPath(cell_definition::AbstractString, patch_type::AbstractString, patch_id path_elements::Vararg{AbstractString})\n\nReturn the XML path to the IC cell patch for the given cell definition, patch type, and patch ID. Optionally, add more path_elements to the path as extra arguments.\n\nExample\n\njulia> icCellsPath(\"default\", \"disc\", 1)\n3-element Vector{String}:\n \"cell_patches:name:default\"\n \"patch_collection:type:disc\"\n \"patch:ID:1\"\n\njulia> icCellsPath(\"default\", \"disc\", 1, \"x0\")\n4-element Vector{String}:\n \"cell_patches:name:default\"\n \"patch_collection:type:disc\"\n \"patch:ID:1\"\n \"x0\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.icECMPath-Tuple{Any, AbstractString, Any, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.icECMPath","text":"icECMPath(layer_id::Int, patch_type::AbstractString, patch_id, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the IC ECM patch for the given layerid, patchtype, and patchid. Optionally, add more pathelements to the path as extra arguments.\n\nExample\n\njulia> icECMPath(2, \"ellipse\", 1)\n3-element Vector{String}:\n \"layer:ID:2\"\n \"patch_collection:type:ellipse\"\n \"patch:ID:1\"\n\njulia> icECMPath(2, \"elliptical_disc\", 1, \"density\")\n4-element Vector{String}:\n \"layer:ID:2\"\n \"patch_collection:type:elliptical_disc\"\n \"patch:ID:1\"\n \"density\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationIDName-Tuple{Union{String, Symbol}}","page":"Configuration","title":"pcvct.locationIDName","text":"locationIDName(location)\n\nReturn the name of the ID column for the location (as either a String or Symbol).\n\nExamples\n\njulia> pcvct.locationIDName(:config)\n\"config_id\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationIDNames-Tuple{}","page":"Configuration","title":"pcvct.locationIDNames","text":"locationIDNames()\n\nReturn the names of the ID columns for all locations.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationPath","page":"Configuration","title":"pcvct.locationPath","text":"locationPath(location::Symbol, folder=missing)\n\nReturn the path to the location folder in the inputs directory.\n\nIf folder is not specified, the path to the location folder is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/configuration/#pcvct.locationPath-Tuple{Symbol, pcvct.AbstractSampling}","page":"Configuration","title":"pcvct.locationPath","text":"locationPath(location::Symbol, S::AbstractSampling)\n\nReturn the path to the location folder in the inputs directory for the AbstractSampling object.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationPath-Tuple{pcvct.InputFolder}","page":"Configuration","title":"pcvct.locationPath","text":"locationPath(input_folder::InputFolder)\n\nReturn the path to the location folder in the inputs directory for the InputFolder object.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationVariationIDName-Tuple{Union{String, Symbol}}","page":"Configuration","title":"pcvct.locationVariationIDName","text":"locationVariationIDName(location)\n\nReturn the name of the variation ID column for the location (as either a String or Symbol).\n\nExamples\n\njulia> pcvct.locationVariationIDName(:config)\n\"config_variation_id\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.locationVariationIDNames-Tuple{}","page":"Configuration","title":"pcvct.locationVariationIDNames","text":"locationVariationIDNames()\n\nReturn the names of the variation ID columns for all varied locations.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.makeXMLPath-Tuple{LightXML.XMLDocument, AbstractVector{<:AbstractString}}","page":"Configuration","title":"pcvct.makeXMLPath","text":"makeXMLPath(xml_doc::XMLDocument, xml_path::AbstractVector{<:AbstractString})\n\nCreate (if it does not exist) and return the XML element relative to the root of the given XML document.\n\nArguments\n\nxml_doc::XMLDocument: The XML document to start from.\nxml_path::AbstractVector{<:AbstractString}: The path to the XML element to create or retrieve. Can be a string representing a child of the root element.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.makeXMLPath-Tuple{LightXML.XMLElement, AbstractVector{<:AbstractString}}","page":"Configuration","title":"pcvct.makeXMLPath","text":"makeXMLPath(current_element::XMLElement, xml_path::AbstractVector{<:AbstractString})\n\nCreate (if it does not exist) and return the XML element relative to the given XML element.\n\nSimilar functionality to the shell command mkdir -p, but for XML elements.\n\nArguments\n\ncurrent_element::XMLElement: The current XML element to start from.\nxml_path::AbstractVector{<:AbstractString}: The path to the XML element to create or retrieve. Can be a string representing a child of the current element.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.motilityPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.motilityPath","text":"motilityPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the motility for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.necrosisPath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.necrosisPath","text":"necrosisPath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the necrosis for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.parseProjectInputsConfigurationFile-Tuple{}","page":"Configuration","title":"pcvct.parseProjectInputsConfigurationFile","text":"parseProjectInputsConfigurationFile()\n\nParse the inputs.toml file in the data_dir directory and create a global ProjectLocations object.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.pathToICCell-Tuple{Simulation}","page":"Configuration","title":"pcvct.pathToICCell","text":"pathToICCell(simulation::Simulation)\n\nReturn the path to the IC cell file for the given simulation, creating it if it needs to be generated from an XML file.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.pathToICECM-Tuple{Simulation}","page":"Configuration","title":"pcvct.pathToICECM","text":"pathToICECM(simulation::Simulation)\n\nReturn the path to the IC ECM file for the given simulation, creating it if it needs to be generated from an XML file.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.phenotypePath-Tuple{String, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.phenotypePath","text":"phenotypePath(cell_definition::String, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the phenotype for the given cell definition (or deeper if more path elements are given).\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.prepareBaseFile-Tuple{pcvct.InputFolder}","page":"Configuration","title":"pcvct.prepareBaseFile","text":"prepareBaseFile(input_folder::InputFolder)\n\nReturn the path to the base XML file for the given input folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.prepareBaseRulesetsCollectionFile-Tuple{pcvct.InputFolder}","page":"Configuration","title":"pcvct.prepareBaseRulesetsCollectionFile","text":"prepareBaseRulesetsCollectionFile(input_folder::InputFolder)\n\nReturn the path to the base XML file for the given input folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.prepareVariedInputFolder-Tuple{Symbol, Sampling}","page":"Configuration","title":"pcvct.prepareVariedInputFolder","text":"prepareVariedInputFolder(location::Symbol, sampling::Sampling)\n\nCreate the XML file for each monad in the sampling for the given location.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.prepareVariedInputFolder-Tuple{Symbol, pcvct.AbstractMonad}","page":"Configuration","title":"pcvct.prepareVariedInputFolder","text":"prepareVariedInputFolder(location::Symbol, M::AbstractMonad)\n\nCreate the XML file for the location in the monad.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.retrieveElement-Tuple{LightXML.XMLDocument, Vector{<:AbstractString}}","page":"Configuration","title":"pcvct.retrieveElement","text":"retrieveElement(xml_doc::XMLDocument, xml_path::Vector{<:AbstractString}; required::Bool=true)\n\nRetrieve the element in the XML document that matches the given path.\n\nIf required is true, an error is thrown if the element is not found. Otherwise, nothing is returned if the element is not found.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.retrieveElementError-Tuple{Vector{<:AbstractString}, String}","page":"Configuration","title":"pcvct.retrieveElementError","text":"retrieveElementError(xml_path::Vector{<:AbstractString}, path_element::String)\n\nThrow an error if the element defined by xml_path is not found in the XML document, including the path element that caused the error.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.rulePath-Tuple{AbstractString, AbstractString, Vararg{AbstractString}}","page":"Configuration","title":"pcvct.rulePath","text":"rulePath(cell_definition::AbstractString, behavior::AbstractString, path_elements::Vararg{AbstractString})\n\nReturn the XML path to the rule for the given cell definition and behavior.\n\nOptionally, add more path_elements to the path as extra arguments.\n\nExample\n\njulia> rulePath(\"T cell\", \"attack rate\")\n2-element Vector{String}:\n \"behavior_ruleset:name:T cell\"\n \"behavior:name:attack rate\"\n\njulia> rulePath(\"cancer\", \"cycle entry\", \"increasing_signals\", \"signal:name:oxygen\", \"half_max\")\n5-element Vector{String}:\n \"behavior_ruleset:name:cancer\"\n \"behavior:name:cycle entry\"\n \"increasing_signals\"\n \"signal:name:oxygen\"\n \"half_max\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.sanitizePathElement-Tuple{String}","page":"Configuration","title":"pcvct.sanitizePathElement","text":"sanitizePathElement(path_elements::String)\n\nDisallow certain path elements to prevent security issues.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortConfigVariationName-Tuple{String}","page":"Configuration","title":"pcvct.shortConfigVariationName","text":"shortConfigVariationName(name::String)\n\nReturn the short name of the varied parameter in the configuration file for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortICCellVariationName-Tuple{String}","page":"Configuration","title":"pcvct.shortICCellVariationName","text":"shortICCellVariationName(name::String)\n\nReturn the short name of the varied parameter in the IC cell file for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortICECMVariationName-Tuple{String}","page":"Configuration","title":"pcvct.shortICECMVariationName","text":"shortICECMVariationName(name::String)\n\nReturn the short name of the varied parameter in the ECM file for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortIntracellularVariationName-Tuple{String}","page":"Configuration","title":"pcvct.shortIntracellularVariationName","text":"shortIntracellularVariationName(name::String)\n\nReturn the short name of the varied parameter in the intracellular file for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortLocationVariationID-Tuple{Symbol}","page":"Configuration","title":"pcvct.shortLocationVariationID","text":"shortLocationVariationID(fieldname)\n\nReturn the short location variation ID name used in creating a DataFrame summary table.\n\nArguments\n\nfieldname: The field name to get the short location variation ID for. This can be a symbol or a string.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortLocationVariationID-Tuple{Type, Union{String, Symbol}}","page":"Configuration","title":"pcvct.shortLocationVariationID","text":"shortLocationVariationID(type::Type, fieldname::Union{String, Symbol})\n\nReturn (as a type) the short location variation ID name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortRulesetsVariationName-Tuple{String}","page":"Configuration","title":"pcvct.shortRulesetsVariationName","text":"shortRulesetsVariationName(name::String)\n\nReturn the short name of the varied parameter in the rulesets collection file for the given name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.shortVariationName-Tuple{Symbol, String}","page":"Configuration","title":"pcvct.shortVariationName","text":"shortVariationName(location::Symbol, name::String)\n\nReturn the short name of the varied parameter for the given location and name used in creating a DataFrame summary table.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.tableName-Tuple{Union{String, Symbol}}","page":"Configuration","title":"pcvct.tableName","text":"tableName(location)\n\nReturn the name of the table for the location (as either a String or Symbol).\n\nExamples\n\njulia> pcvct.tableName(:config)\n\"configs\"\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.updateField-Tuple{LightXML.XMLDocument, Vector{<:AbstractString}, Union{Real, String}}","page":"Configuration","title":"pcvct.updateField","text":"updateField(xml_doc::XMLDocument, xml_path::Vector{<:AbstractString}, new_value::Union{Int,Real,String})\n\nUpdate the content of the element in the XML document that matches the given path with the new value. See retrieveElement.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.userParameterPath-Tuple{String}","page":"Configuration","title":"pcvct.userParameterPath","text":"userParameterPath(field_name::String)\n\nReturn the XML path to the user parameter for the given field name.\n\n\n\n\n\n","category":"method"},{"location":"lib/configuration/#pcvct.variationsTableName-Tuple{Union{String, Symbol}}","page":"Configuration","title":"pcvct.variationsTableName","text":"variationsTableName(location)\n\nReturn the name of the variations table for the location (as either a String or Symbol).\n\n\n\n\n\n","category":"method"},{"location":"lib/movie/#Movie","page":"Movie","title":"Movie","text":"","category":"section"},{"location":"lib/movie/","page":"Movie","title":"Movie","text":"Make movies for simulations in the database.","category":"page"},{"location":"lib/movie/#pcvct.makeMovie-Tuple{Int64}","page":"Movie","title":"pcvct.makeMovie","text":"makeMovie(simulation_id::Int; magick_path::Union{Missing,String}=path_to_magick, ffmpeg_path::Union{Missing,String}=path_to_ffmpeg)\n\nMake a movie for the simulation with ID simulation_id.\n\nUse the PhysiCell Makefile to generate the movie. This process requires first generating JPEG files, which are then used to create the movie. Deletes the JPEG files after the movie is generated.\n\nThis relies on ImageMagick and FFmpeg being installed on the system. There are three ways to allow this function to find these dependencies:\n\nPass the path to the dependencies using the magick_path and ffmpeg_path keyword arguments.\nSet the PATH environment variable to include the directories containing the dependencies.\nSet environment variables PCVCT_IMAGEMAGICK_PATH and PCVCT_FFMPEG_PATH before using pcvct.\n\n\n\n\n\n","category":"method"},{"location":"lib/movie/#pcvct.makeMovie-Tuple{Union{pcvct.AbstractTrial, pcvct.PCVCTOutput}}","page":"Movie","title":"pcvct.makeMovie","text":"makeMovie(T::Union{AbstractTrial,PCVCTOutput}; magick_path::Union{Missing,String}=path_to_magick, ffmpeg_path::Union{Missing,String}=path_to_ffmpeg)\n\nMake movies for all simulations in T, a simulation, monad, sampling, or trial.\n\nUses the PhysiCell Makefile to generate the movies.\n\nExamples\n\nmakeMovie(123) # make a movie for simulation 123\nmakeMovie(sampling) # make movies for all simulations in sampling\n\n\n\n\n\n","category":"method"},{"location":"lib/movie/#pcvct.resolveMovieGlobals-Tuple{Union{Missing, String}, Union{Missing, String}}","page":"Movie","title":"pcvct.resolveMovieGlobals","text":"resolveMovieGlobals(magick_path::Union{Missing,String}, ffmpeg_path::Union{Missing,String})\n\nSet the global variables path_to_magick and path_to_ffmpeg to the provided paths.\n\n\n\n\n\n","category":"method"},{"location":"misc/renaming/#Renaming","page":"Renaming","title":"Renaming","text":"","category":"section"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"Julia packages are supposed to follow certain conventions to be admitted to the General registry. In particular, it must end with .jl, be CamelCase, avoid jargon/acronyms (looking at you pcvct), and be descriptive. We want to clearly tie it to PhysiCell but not make it sound like a replacement for PhysiCell, i.e. not PhysiCell.jl. Here are the options brainstormed thus far:","category":"page"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"PhysiCellVT.jl\nPhysiVT.jl (possible confusion with the OpenVT project where VT = virtual tissue)\nPhysiCellCohorts.jl\nPhysiCellTrials.jl\nPhysiVirtualTrials.jl\nPhysiCellBatch.jl\nPhysiBatch.jl\nPhysiCellDB.jl\nPhysiDB.jl (the clear name for make the database portion a separate package)\nPhysiCell.jl (kinda self-important to assume this will be all the PhysiCell stuff in Julia)","category":"page"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"I think I'm now leaning towards ModelManager.jl being the underlying framework that works across ABM (or other modeling paradigms) frameworks and then PhysiCellModelManager.jl is the PhysiCell-specific version.","category":"page"},{"location":"man/covariations/#CoVariations","page":"CoVariations","title":"CoVariations","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"Sometimes several parameters need to be varied together. A common use case is the varying the base value of a rule and the max response of the rule[1] To handle this scenario, pcvct provides the CoVariation type. A CoVariation is a wrapper for a vector of ElementaryVariation's, and each ElementaryVariation must be of the same type, i.e., all DiscreteVariation's or all DistributedVariation's. The type of a CoVariation is parameterized by the type of ElementaryVariation's it contains. Thus, there are, for now, two types of CoVariation's: CoVariation{DiscreteVariation} and CoVariation{DistributedVariation}.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"[1]: PhysiCell does not allow the base value to exceed the max response. That is, the base response of a decreasing signal cannot be < the max response. Similarly, the base resposne of an increasing signal cannot be > the max response.","category":"page"},{"location":"man/covariations/#CoVariation{DiscreteVariation}","page":"CoVariations","title":"CoVariation{DiscreteVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DiscreteVariation}, each of the DiscreteVariation's must have the same number of values. This may be relaxed in future versions, but the primary use case anticipated is a GridVariation which requires the variations to inform the size of the grid. No restrictions are imposed on how the values of the various variations are linked. pcvct will use values that share an index their respective vectors together.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"base_xml_path = pcvct.customDataPath(\"default\", \"sample\")\nev1 = DiscreteVariation(base_xml_path, [1, 2, 3]) # vary the `sample` custom data for cell type default\nmax_xml_path = [\"behavior_ruleset:name:default\", \"behavior:name:custom sample\", \"increasing_signals\", \"max_response\"] # the max response of the rule increasing sample (must be bigger than the base response above)\nev2 = DiscreteVariation(rule_xml_path, [2, 3, 4])\ncovariation = CoVariation(ev1, ev2) # CoVariation([ev1, ev2]) also works","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"It is also not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"# have the phase durations vary by and compensate for each other\nphase_0_xml_path = pcvct.cyclePath(\"default\", \"phase_durations\", \"duration:index:0\")\nphase_1_xml_path = pcvct.cyclePath(\"default\", \"phase_durations\", \"duration:index:1\")\nphase_0_durations = [300.0, 400.0] \nphase_1_durations = [200.0, 100.0] # the (mean) duration through these two phases is 500 min\n# input any number of tuples (xml_path, values)\ncovariation = Covariation((phase_0_xml_path, phase_0_durations), (phase_1_xml_path, phase_1_durations))","category":"page"},{"location":"man/covariations/#CoVariation{DistributedVariation}","page":"CoVariations","title":"CoVariation{DistributedVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DistributedVariation}, the conversion of a CDF value, x in 0 1, is done independently for each distribution. That is, in the joint probability space, a CoVariation{DistributedVariation} restricts us to the one-dimensional line connecting mathbf0 to mathbf1. To allow for the parameters to vary inversely with one another, the DistributedVariation type accepts an optional flip::Bool argument (not a keyword argument!). For a distribution dv with dv.flip=true, when a value is requested with a CDF x, pcvct will \"flip\" the CDF to give the value with CDF 1 - x.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"using pcvct\ntiming_1_path = pcvct.userParameterPath(\"event_1_time\")\ntiming_2_path = pcvct.userParameterPath(\"event_2_time\")\ndv1 = UniformDistributedVariation(timing_1_path, 100.0, 200.0)\nflip = true\ndv2 = UniformDistributedVariation(timing_2_path, 100.0, 200.0, flip)\ncovariation = CoVariation(dv1, dv2)\ncdf = 0.1\npcvct.variationValues.(covariation.variations, cdf) # pcvct internal for getting values for an ElementaryVariation\n# output\n2-element Vector{Vector{Float64}}:\n [110.0]\n [190.0]","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"As with CoVariation{DiscreteVariation}, it is not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor. It is not possible to flip a DistributedVariation with this syntax, however.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"apop_xml_path = pcvct.apoptosisPath(\"default\", \"death_rate\")\napop_dist = Uniform(0, 0.001)\ncycle_entry_path = pcvct.cyclePath(\"default\", \"phase_transition_rates\", \"rate:start_index:0\")\ncycle_dist = Uniform(0.00001, 0.0001)\ncovariation = CoVariation((apop_xml_path, apop_dist), (cycle_entry_path, cycle_dist))","category":"page"},{"location":"man/intracellular_inputs/#Intracellular-inputs","page":"Intracellular inputs","title":"Intracellular inputs","text":"","category":"section"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"pcvct currently only supports ODE intracellular models using libRoadRunner. It uses a specialized format to achieve this, creating the SBML files needed by libRoadRunner at PhysiCell runtime. Briefly, the intracellular.xml file defines a mapping between cell definitions and intracellular models. See the template provided here.","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"To facilitate creation of such files, and to make it easy to mix-and-match intracellular models, users can place the SBML files that define the ODEs into data/components/roadrunner and then simply reference those to construct the specialized XMLs needed. For example, place the Toy_Metabolic_Model.xml from sampleprojectsintracellular/ode/ode_energy/config/ into data/components/roadrunner and assemble the XML as follows","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"cell_type = \"default\" # name of the cell type using this intracellular model\ncomponent = PhysiCellComponent(\"roadrunner\", \"Toy_Metabolic_Model.xml\") # pass in the type of the component and the name of the file to use\ncell_type_to_component = Dict{String, PhysiCellComponent}(cell_type => component) # add other entries to this Dict for other cell types using an intracellular model\nintracellular_folder = assembleIntracellular!(cell_type_to_component; name=\"toy_metabolic\") # will return \"toy_metabolic\" or \"toy_metabolic_n\"","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"This creates a folder at data/inputs/intracellulars/ with the name stored in intracellular_folder. Also, the ! in assembleIntracellular! references how the components in the cell_type_to_component Dict are updated to match those in data/inputs/intracellulars/$(intracellular_folder)/intracellular.xml. Use these IDs to make variations on the components by using","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"xml_path = [\"intracellulars\", \"intracellular:ID:$(component.id)\", ...]","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"where the ... is the path starting with the root of the XML file (sbml for SBML files).","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"Finally, pass this folder into InputFolders to use this input in simulation runs:","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"inputs = InputFolders(...; ..., intracellular=intracellular_folder, ...)","category":"page"},{"location":"lib/compilation/#Compilation","page":"Compilation","title":"Compilation","text":"","category":"section"},{"location":"lib/compilation/","page":"Compilation","title":"Compilation","text":"Compile a PhysiCell project in pcvct. Includes the necessary compiler macros and checks PhysiCell version by the commit hash of the PhysiCell repository.","category":"page"},{"location":"lib/compilation/#pcvct.addMacro-Tuple{pcvct.AbstractSampling, String}","page":"Compilation","title":"pcvct.addMacro","text":"addMacro(S::AbstractSampling, macro_name::String)\n\nAdd a macro to the macros file for the sampling object S.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.addMacrosIfNeeded-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.addMacrosIfNeeded","text":"addMacrosIfNeeded(S::AbstractSampling)\n\nCheck if the macros needed for the sampling object S are already present in the macros file.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.addPhysiECMIfNeeded-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.addPhysiECMIfNeeded","text":"addPhysiECMIfNeeded(S::AbstractSampling)\n\nCheck if the PhysiECM macro needs to be added for the sampling object S.\n\nThe macro will need to be added if it is not present AND either 1) the inputs includes ic_ecm or 2) the configuration file has ecm_setup enabled.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.addRoadRunnerIfNeeded-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.addRoadRunnerIfNeeded","text":"addRoadRunnerIfNeeded(S::AbstractSampling)\n\nCheck if the RoadRunner macro needs to be added for the sampling object S.\n\nThe macro will need to be added if it is not present AND either 1) the inputs defines an intracellular file with roadrunner intracellulars or 2) the configuration file has roadrunner intracellulars defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.compilerFlags-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.compilerFlags","text":"compilerFlags(S::AbstractSampling)\n\nGenerate the compiler flags for the given sampling object S.\n\nGenerate the necessary compiler flags based on the system and the macros defined in the sampling object S. If the required macros differ from a previous compilation (as stored in macros.txt), then recompile.\n\nReturns\n\ncflags::String: The compiler flags as a string.\nrecompile::Bool: A boolean indicating whether recompilation is needed.\nclean::Bool: A boolean indicating whether cleaning is needed.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.executableExists-Tuple{String}","page":"Compilation","title":"pcvct.executableExists","text":"executableExists(custom_code_folder::String)\n\nCheck if the executable for the custom code folder exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.isPhysiECMInConfig-Tuple{pcvct.AbstractMonad}","page":"Compilation","title":"pcvct.isPhysiECMInConfig","text":"isPhysiECMInConfig(S::AbstractSampling)\n\nCheck if any of the simulations in S have a configuration file with ecm_setup enabled.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.isRoadRunnerInConfig-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.isRoadRunnerInConfig","text":"isRoadRunnerInConfig(S::AbstractSampling)\n\nCheck if any of the simulations in S have a configuration file with roadrunner intracellulars defined.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.isRoadRunnerInInputs-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.isRoadRunnerInInputs","text":"isRoadRunnerInInputs(S::AbstractSampling)\n\nCheck if the inputs for the sampling object S defines an intracellular file with roadrunner intracellulars.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.loadCustomCode-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.loadCustomCode","text":"loadCustomCode(S::AbstractSampling[; force_recompile::Bool=false])\n\nLoad and compile custom code for a simulation, monad, or sampling.\n\nDetermines if recompilation is necessary based on the previously used macros. If compilation is required, copy the PhysiCell directory to a temporary directory to avoid conflicts. Then, compile the project, recording the output and error in the custom_codes folder used. Move the compiled executable into the custom_codes folder and the temporary PhysiCell folder deleted.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.prepareLibRoadRunner-Tuple{String}","page":"Compilation","title":"pcvct.prepareLibRoadRunner","text":"prepareLibRoadRunner(physicell_dir::String)\n\nPrepare the libRoadRunner library for use with PhysiCell.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.readMacrosFile-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.readMacrosFile","text":"readMacrosFile(S::AbstractSampling)\n\nRead the macros file for the sampling object S into a vector of strings, one macro per entry.\n\n\n\n\n\n","category":"method"},{"location":"lib/compilation/#pcvct.writePhysiCellCommitHash-Tuple{pcvct.AbstractSampling}","page":"Compilation","title":"pcvct.writePhysiCellCommitHash","text":"writePhysiCellCommitHash(S::AbstractSampling)\n\nWrite the commit hash of the PhysiCell repository to a file associated with the custom code folder of the sampling object S.\n\nIf the commit hash has changed since the last write, if the repository is in a dirty state, or if PhysiCell is downloaded (not cloned), recompile the custom code.\n\n\n\n\n\n","category":"method"},{"location":"lib/ic_ecm/#ECM-Initial-Conditions","page":"ECM Initial Conditions","title":"ECM Initial Conditions","text":"","category":"section"},{"location":"lib/ic_ecm/","page":"ECM Initial Conditions","title":"ECM Initial Conditions","text":"Functionality for the using PhysiCellECMCreator.jl to create and use PhysiCell ECM XML files.","category":"page"},{"location":"lib/ic_ecm/#pcvct.createICECMXMLTemplate-Tuple{String}","page":"ECM Initial Conditions","title":"pcvct.createICECMXMLTemplate","text":"createICECMXMLTemplate(folder::String)\n\nCreate folder with a template XML file for IC ECM.\n\nSee the PhysiCellECMCreator.jl documentation for more information on IC ECM and how this function works outside of pcvct. This pcvct function runs the createICECMXMLTemplate function from PhysiCellECMCreator.jl and then updates the database. Furthermore, the folder can be passed in just as the name of the folder located in data/inputs/ics/ecms/ rather than the full path.\n\nThis functionality is run outside of a PhysiCell runtime. It will not work in PhysiCell! This function creates a template XML file for IC ECM, showing all the current functionality of this initialization scheme. The ID attribute in patch elements is there to allow variations to target specific patches within a layer. Manually maintain these or you will not be able to vary specific patches effectively.\n\nEach time a simulation is run that is using a ecm.xml file, a new CSV file will be created. These will all be stored with data/inputs/ics/ecms/folder/ic_ecm_variations as ic_ecm_variation_#_s#.csv where the first # is the variation ID associated with variation on the XML file and the second # is the simulation ID. Importantly, no two simulations will use the same CSV file.\n\n\n\n\n\n","category":"method"},{"location":"man/sensitivity_analysis/#Sensitivity-analysis","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"pcvct supports some sensitivity analysis workflows. By using pcvct, you will have the opportunity to readily reuse previous simulations to perform and extend sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/#Supported-sensitivity-analysis-methods","page":"Sensitivity analysis","title":"Supported sensitivity analysis methods","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"pcvct currently supports three sensitivity analysis methods:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Morris One-At-A-Time (MOAT)\nSobol\nRandom Balance Design (RBD)","category":"page"},{"location":"man/sensitivity_analysis/#Morris-One-At-A-Time-(MOAT)","page":"Sensitivity analysis","title":"Morris One-At-A-Time (MOAT)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The Morris One-At-A-Time (MOAT) method gives an intuitive understanding of the sensitivity of a model to its parameters. What it lacks in theoretical grounding, it makes up for in speed and ease of use. In short, MOAT will sample parameter space at n points. From each point, it will vary each parameter one at a time and record the change in model output. Aggregating these changes, MOAT will quantify the sensitivity of the model to each parameter.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT uses a Latin Hypercube Sampling (LHS) to sample the parameter space. By default, it will use the centerpoint of each bin as the point to vary each parameter from. To pick a random point within the bin, set add_noise=true.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT furthermore uses an orthogonal LHS, if possible. If n=k^d for some integer k, then the LHS will be orthogonal. Here, n is the requested number of base points and d is the number of parameters varied. For example, if n=16 and d=4, then k=2 and the LHS will be orthogonal. To force pcvct to NOT use an orthogonal LHS, set orthogonalize=false.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the MOAT method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT() # will default to n=15\nMOAT(8) # set n=8\nMOAT(8; add_noise=true) # use a random point in the bin, not necessarily the center\nMOAT(8; orthogonalize=false) # do not use an orthogonal LHS (even if d=3, so k=2 would make an orthogonal LHS)","category":"page"},{"location":"man/sensitivity_analysis/#Sobol","page":"Sensitivity analysis","title":"Sobol","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The Sobol method is a more rigorous sensitivity analysis method, relying on the variance of the model output to quantify sensitivity. It relies on a Sobol sequence, a deterministic sequence of points that are evenly distributed in the unit hypercube. The important main feature of the Sobol sequence is that it is a low-discrepancy sequence, meaning that it fills the space very evenly. Thus, using such sequences can give a very good approximation of certain quantities (like integrals) with fewer points than a random sequence would require. The Sobol sequence is built around powers of 2, and so picking n=2^k (as well as ±1) will give the best results. See SobolVariation for more information on how pcvct will use the Sobol sequence to sample the parameter space and how you can control it.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"If the extremes of your distributions (where the CDF is 0 or 1) are non-physical, e.g., an unbounded normal distribution, then consider using n=2^k-1 to pick a subsequence that does not include the extremes. For example, if you choose n=7, then the Sobol sequence will be [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875]. If you do want to include the extremes, consider using n=2^k+1. For example, if you choose n=9, then the Sobol sequence will be [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1].","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"You can also choose which method is used to compute the first and total order Sobol indices. For first order: the choices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. For total order: the choices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the Sobol method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Sobolʼ(9)\nSobolʼ(9; skip_start=true) # skip to the odd multiples of 1/32 (smallest one with at least 9)","category":"page"},{"location":"man/sensitivity_analysis/#Random-Balance-Design-(RBD)","page":"Sensitivity analysis","title":"Random Balance Design (RBD)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The RBD method uses a random design matrix (similar to the Sobol method) and uses a Fourier transform (as in in the FAST method) to compute the sensitivity indices. It is much cheaper than Sobol, but only gives first order indices. Choosing n design points, RBD will run n monads. It will then rearrange the n output values so that each parameter in turn is varied along a sinusoid and computes the Fourier transforms to estimate the first order indices. By default, it looks up to the 6th harmonic, but you can control this with the num_harmonics keyword argument.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"By default, pcvct will make use of the Sobol sequence to pick the design points. It is best to pick n such that is differs from a power of 2 by at most 1, e.g. 7, 8, or 9. In this case, pcvct will actually use a half-period of a sinusoid when converting the design points into CDF space. Otherwise, pcvct will use random permuations of n uniformly spaced points in each parameter dimension and will use a full period of a sinusoid when converting the design points into CDF space.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the RBD method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"RBD(9) # will use a Sobol sequence with elements chosen from 0:0.125:1\nRBD(32; use_sobol=false) # opt out of using the Sobol sequence\nRBD(22) # will use the first 22 elements of the Sobol sequence, including 0\nRBD(32; num_harmonics=4) # will look up to the 4th harmonic, instead of the default 6th","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"If you choose n=2^k - 1 or n=2^k + 1, then you will be well-positioned to increment k by one and rerun the RBD method to get more accurate results. The reason: pcvct will start from the start of the Sobol sequence to cover these n points, meaning runs will not need to be repeated. If n=2^k, then pcvct will choose the n odd multiples of 1/2^(k+1) from the Sobol sequence, which will not be used if k is incremented.","category":"page"},{"location":"man/sensitivity_analysis/#Setting-up-a-sensitivity-analysis","page":"Sensitivity analysis","title":"Setting up a sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/#Simulation-inputs","page":"Sensitivity analysis","title":"Simulation inputs","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Having chosen a sensitivity analysis method, you must now choose the same set of inputs as required for a sampling. You will need:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"inputs::InputFolders containing the data/inputs/ folder info defining your model\nn_replicates::Integer for the number of replicates to run at each parameter vector to get average behavior\nevs::Vector{<:ElementaryVariation} to define the parameters to conduct the sensitivity analysis on and their ranges/distributions","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Unlike for (most) trials, the ElementaryVariation's you will want here are likely to be DistributedVariation's to allow for a continuum of parameter values to be tested. pcvct offers UniformDistributedVariation and NormalDistributedVariation as convenience functions to create these DistributedVariation's. You can also use any d::Distribution to create a DistributedVariation directly:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"dv = DistributedVariation(xml_path, d)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Currently, pcvct does not support defining relationships between parameters in any context. CoVariation's are a work-in-progress and will be a sibling of ElementaryVariation in the type tree.","category":"page"},{"location":"man/sensitivity_analysis/#Sensitivity-functions","page":"Sensitivity analysis","title":"Sensitivity functions","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"At the time of starting the sensitivity analysis, you can include any number of sensitivity functions to compute. They must take a single argument, the simulation ID (an Int64) and return a Number (or any type that Statistics.mean will accept a Vector of). For example, finalPopulationCount returns a dictionary of the final population counts of each cell type from a simulation ID. So, if you want to know the sensitivity of the final population count of cell type \"cancer\", you could define a function like:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"f(sim_id) = finalPopulationCount(sim_id)[\"cancer\"]","category":"page"},{"location":"man/sensitivity_analysis/#Running-the-analysis","page":"Sensitivity analysis","title":"Running the analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Putting it all together, you can run this analysis:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"config_folder = \"default\"\ncustom_codes = \"default\"\ninputs = InputFolders(config_folder, custom_codes)\nn_replicates = 3\nevs = [NormalDistributedVariation(pcvct.apoptosisPath(\"cancer\", \"rate\"), 1e-3, 1e-4; lb=0),\n       UniformDistributedVariation(pcvct.cyclePath(\"cancer\", \"phase_durations\", \"duration:index:0\"), 720, 2880)]\nmethod = MOAT(15)\nsensitivity_sampling = run(method, inputs, n_replicates, evs)","category":"page"},{"location":"man/sensitivity_analysis/#Post-processing","page":"Sensitivity analysis","title":"Post-processing","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The object sensitivity_sampling is of type pcvct.GSASampling, meaning you can use pcvct.calculateGSA! to compute sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"f = simulation_id -> finalPopulationCount(simulation_id)[\"default\"] # count the final population of cell type \"default\"\ncalculateGSA!(sensitivity_sampling, f)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"These results are stored in a Dict in the sensitivity_sampling object:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"println(sensitivity_sampling.results[f])","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The exact concrete type of sensitivity_sampling will depend on the method used. This, in turn, is used by calculateGSA! to determine how to compute the sensitivity indices.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Likewise, the method will determine how the sensitivity scheme is saved After running the simulations, pcvct will print a CSV in the data/outputs/sampling/$(sampling) folder named based on the method. This can later be used to reload the GSASampling and continue doing analysis. Currently, this requires some ingenuity by the user. A future version of pcvct could provide convenience functions for simplifying this.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"using CSV, DataFrames\nsampling_id = 1 # for example\nmonad_ids_df = CSV.read(\"data/outputs/samplings/$(sampling_id)/moat_scheme.csv\", DataFrame) # if this was a MOAT scheme\nmoat_sampling = MOATSampling(Sampling(sampling_id), monad_ids_df, Dict{Function, GlobalSensitivity.MorrisResult}())","category":"page"},{"location":"man/physicell_studio/#Using-PhysiCell-Studio","page":"PhysiCell Studio","title":"Using PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"See PhysiCell-Studio. Using PhysiCell Studio within pcvct is designed for visualizing output in the Plot tab and observing model parameters in the remaining tabs.","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"Do not use the Run tab in PhysiCell Studio as this may delete simulation data.","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"See below for how to edit the configuration and rules files in studio.","category":"page"},{"location":"man/physicell_studio/#Setting-paths","page":"PhysiCell Studio","title":"Setting paths","text":"","category":"section"},{"location":"man/physicell_studio/#Environment-variables","page":"PhysiCell Studio","title":"Environment variables","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"You must first inform pcvct where your desired python executable is and the PhysiCell Studio folder. The recommended way to do this is to add the following two lines to your shell environment file (e.g. ~/.bashrc or ~/.zshenv):","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"export PCVCT_PYTHON_PATH=\"/usr/bin/python3\"\nexport PCVCT_STUDIO_PATH=\"/home/user/PhysiCell-Studio\"","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If your python executable is on your PATH, you can set PCVCT_PYTHON_PATH=\"python3\", for example.","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"After making these changes, make sure to source the file to apply the changes:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"$ source ~/.bashrc","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"Or open a new terminal window.","category":"page"},{"location":"man/physicell_studio/#Using-keyword-arguments","page":"PhysiCell Studio","title":"Using keyword arguments","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you prefer not to set these environment variables, you can pass the paths as keyword arguments to the runStudio function. It will remember these settings during the session, so you only need to pass them once. See below for the function signature.","category":"page"},{"location":"man/physicell_studio/#Launching-PhysiCell-Studio","page":"PhysiCell Studio","title":"Launching PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"First, launch julia in a new shell session and make sure the project is initialized by running:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"# if you used createProject(), these are the first two lines of GenerateData.jl\nusing pcvct\ninitializeModelManager()","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"As soon as the simulation has begun (so that its PhysiCell-generated output folder is created and populated), you can launch PhysiCell Studio. If you set the environment variables, you can run the following command for a simulation with id sim_id::Integer:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id)","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you did not set the environment variables, you can run the following command:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id; python_path=path_to_python, studio_path=path_to_studio)","category":"page"},{"location":"man/physicell_studio/#Editing-in-PhysiCell-Studio","page":"PhysiCell Studio","title":"Editing in PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"When you run the runStudio function, PhysiCell Studio will open with the simulation you specified using temporary files for the configuration and rules. Any edits to these in studio will be lost when the studio is closed. Remember: this is the output of a simulation that already ran. Use the File > Save as dropdown to save the configuration file. Use the Rules tab to save the rules file. Note: the recent changes in PhysiCell 1.14.1 copying over the initial conditions files are not yet supported by this. See Known limitations for more information.","category":"page"},{"location":"lib/classes/#Classes","page":"Classes","title":"Classes","text":"","category":"section"},{"location":"lib/classes/","page":"Classes","title":"Classes","text":"Class definitions for the hierarchical structure connecting simulations to trials.","category":"page"},{"location":"lib/classes/#pcvct.AbstractMonad","page":"Classes","title":"pcvct.AbstractMonad","text":"AbstractMonad <: AbstractSampling\n\nAbstract type for the Simulation and Monad types.\n\nAll the inputs and variations must be the same for all associated simulations.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.AbstractSampling","page":"Classes","title":"pcvct.AbstractSampling","text":"AbstractSampling <: AbstractTrial\n\nAbstract type for the Simulation, Monad, and Sampling types.\n\nAll the inputs must be the same for all associated simulations. Variations can differ.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.AbstractTrial","page":"Classes","title":"pcvct.AbstractTrial","text":"AbstractTrial\n\nAbstract type for the Simulation, Monad, Sampling, and Trial types.\n\nThere are no restrictions on inputs or variations for this type.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.InputFolder","page":"Classes","title":"pcvct.InputFolder","text":"InputFolder\n\nHold the information for a single input folder.\n\nUsers should use the InputFolders to create and access individual InputFolder objects.\n\nFields\n\nlocation::Symbol: The location of the input folder, e.g. :config, :custom_code, etc. Options are defined in data/inputs.toml.\nid::Int: The ID of the input folder in the database.\nfolder::String: The name of the input folder. It will be in data/inputs/<path_from_inputs>.\nbasename::Union{String,Missing}: The basename of the input file. This can be used to determine if the input file is varied.\nrequired::Bool: Whether the input folder is required. This is defined in data/inputs.toml.\nvaried::Bool: Whether the input folder is varied. This is determined by the presence of a varied basename in the input folder.\npath_from_inputs::String: The path from the data/inputs directory to the input folder. This is defined in data/inputs.toml.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.InputFolders","page":"Classes","title":"pcvct.InputFolders","text":"InputFolders\n\nConsolidate the folder information for a simulation/monad/sampling.\n\nPass the folder names within the inputs/<path_from_inputs> directory to create an InputFolders object. The path_from_inputs is defined in the data/inputs.toml file for each. It is possible to acces the InputFolder values using index notation, e.g. input_folders[:config].\n\nSeveral constructors exist:\n\nAll folders passed as keyword arguments. Omitted folders are assumed to be \"\", i.e. those inputs are unused.\n\nInputFolders(; config=\"default\", custom_codes=\"default\", rulesets_collection=\"default\")\n\nPass in the required inputs as arguments and the optional inputs as keyword arguments. The required folders must be passed in alphabetical order.\n\nRefer to the names defined in data/inputs.toml to see this order. Omitted optional folders are assumed to be \"\", i.e. those inputs are unused.\n\nconfig_folder = \"default\"\ncustom_code_folder = \"default\"\nic_cell_folder = \"cells_in_disc\"\nInputFolders(config_folder, custom_code_folder; ic_cell=ic_cell_folder)\n\nFields\n\ninput_folders::NamedTuple: The input locations defined in data/inputs.toml define the keys. The values are InputFolders.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.Monad","page":"Classes","title":"pcvct.Monad","text":"Monad\n\nA group of simulations that are identical up to randomness.\n\nTo create a new monad, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations. Set n_replicates=0 to avoid adding new simulations to the database. This is useful for creating references for later use. Otherwise, set n_replicates > 1 to create the simulations to go with this monad. If n_replicates = 1, it will return a Simulation object.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nmonad = createTrial(inputs; n_replicates=0) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nmonad = createTrial(inputs, ev; n_replicates=10) # uses the config file with the specified variation\n\nmonad = createTrial(inputs, ev; n_replicates=10, use_previous=false) # changes the default behavior and creates 10 new simulations for this monad\n\nIf there is a previously created monad that you wish to access, you can use its ID to create a Monad object:\n\nmonad = Monad(monad_id)\nmonad = Monad(monad_id; n_replicates=5) # ensures at least 5 simulations in the monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this monad. Matches with the folder in data/outputs/monads/\ninputs::InputFolders: contains the folder info for this monad.\nvariation_id::VariationID: contains the variation IDs for this monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.Sampling","page":"Classes","title":"pcvct.Sampling","text":"Sampling\n\nA group of monads that have the same input folders, but differ in parameter values.\n\nTo create a new sampling, best practice is to use createTrial and supply it with the InputFolders and any number of DiscreteVariations. At least one should have multiple values to create a sampling.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling = createTrial(inputs, ev; n_replicates=3, use_previous=true)\n\nIf there is a previously created sampling that you wish to access, you can use its ID to create a Sampling object:\n\nsampling = Sampling(sampling_id)\nsampling = Sampling(sampling_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\nsampling = Sampling(sampling_id; n_replicates=5, use_previous=false) # creates 5 new simulations in each monad\n\nFields\n\nid::Int: integer uniquely identifying this sampling. Matches with the folder in data/outputs/samplings/\ninputs::InputFolders: contains the folder info for this sampling.\nmonads::Vector{Monad}: array of monads belonging to this sampling.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.Sampling-Tuple{AbstractArray{<:pcvct.AbstractMonad}}","page":"Classes","title":"pcvct.Sampling","text":"Sampling(Ms::AbstractArray{<:AbstractMonad}; n_replicates::Integer=0, use_previous::Bool=true)\n\nCreates a new Sampling object from a vector of Monad objects.\n\nThe monads must all have the same InputFolders object so that they can actually be grouped into a sampling.\n\nArguments\n\nMs::AbstractArray{<:AbstractMonad}: A vector of Monad objects. A single Monad object can also be passed in.\nn_replicates::Integer=0: The number of replicates to create for each monad. New simulations will be created as needed for each monad.\nuse_previous::Bool=true: Whether to use previous simulations for each monad. If false, new simulations will be created for each monad.\n\n\n\n\n\n","category":"method"},{"location":"lib/classes/#pcvct.Simulation","page":"Classes","title":"pcvct.Simulation","text":"Simulation\n\nA simulation that represents a single run of the model.\n\nTo create a new simulation, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations:\n\ninputs = InputFolders(config_folder, custom_code_folder)\nsimulation = createTrial(inputs) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nsimulation = createTrial(inputs, ev) # uses the config file with the specified variation\n\nIf there is a previously created simulation that you wish to access, you can use its ID to create a Simulation object:\n\nsimulation = Simulation(simulation_id)\n\nFields\n\nid::Int: integer uniquely identifying this simulation. Matches with the folder in data/outputs/simulations/\ninputs::InputFolders: contains the folder info for this simulation.\nvariation_id::VariationID: contains the variation IDs for this simulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.Simulation-Tuple{Monad}","page":"Classes","title":"pcvct.Simulation","text":"Simulation(monad::Monad)\n\nCreates a new Simulation object belonging to the monad, i.e., will not use a simulation already in the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/classes/#pcvct.Trial","page":"Classes","title":"pcvct.Trial","text":"Trial\n\nA group of samplings that can have different input folders.\n\nTo create a new trial, best practice currently is to create a vector of Sampling objects and passing them to Trial.\n\ninputs_1 = InputFolders(config_folder_1, custom_code_folder_1)\ninputs_2 = InputFolders(config_folder_2, custom_code_folder_2)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling_1 = createTrial(inputs_1, ev; n_replicates=3, use_previous=true)\nsampling_2 = createTrial(inputs_2, ev; n_replicates=3, use_previous=true)\ntrial = Trial([sampling_1, sampling_2])\n\nIf there is a previous trial that you wish to access, you can use its ID to create a Trial object:\n\ntrial = Trial(trial_id)\ntrial = Trial(trial_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\ntrial = Trial(trial_id; n_replicates=5, use_previous=false) # creates 5 new simulations in each monad\n\nFields\n\nid::Int: integer uniquely identifying this trial. Matches with the folder in data/outputs/trials/\ninputs::Vector{InputFolders}: contains the folder info for each sampling in this trial.\nvariation_ids::Vector{Vector{VariationID}}: contains the variation IDs for each monad in each sampling in this trial.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.VariationID","page":"Classes","title":"pcvct.VariationID","text":"VariationID\n\nThe variation IDs for any of the possibly varying inputs.\n\nFor each input type that can be varied, a record of the current variation ID for that input type. By convention, a values of -1 indicates that the input is not being used (hence this is disallowed for a required input type). A value of 0 indicates that the base file is being used, unvaried. Hence, if the input type is sometimes varied (such as ic_cell with a cells.csv file), this value must be 0 in such conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/classes/#pcvct.addSimulationID-Tuple{Monad, Int64}","page":"Classes","title":"pcvct.addSimulationID","text":"addSimulationID(monad::Monad, simulation_id::Int)\n\nAdds a simulation ID to the monad's list of simulation IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/classes/#pcvct.createSimpleInputFolders-Tuple{}","page":"Classes","title":"pcvct.createSimpleInputFolders","text":"createSimpleInputFolders()\n\nCreates a simple method for creating InputFolders objects at module initialization based on data/inputs.toml.\n\nThe required inputs are sorted alphabetically and used as the positional arguments. The optional inputs are used as keyword arguments with a default value of \"\", indicating they are unused.\n\n\n\n\n\n","category":"method"},{"location":"lib/classes/#pcvct.getTrialID-Tuple{Vector{Sampling}}","page":"Classes","title":"pcvct.getTrialID","text":"getTrialID(samplings::Vector{Sampling})\n\nGet the trial ID for a vector of samplings or create a new trial if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"lib/classes/#pcvct.printInputFolders","page":"Classes","title":"pcvct.printInputFolders","text":"printInputFolders(io::IO, input_folders::InputFolders, n_indent::Int=1)\n\nPrints the folder information for each input folder in the InputFolders object.\n\n\n\n\n\n","category":"function"},{"location":"lib/classes/#pcvct.printVariationID","page":"Classes","title":"pcvct.printVariationID","text":"printVariationID(io::IO, variation_id::VariationID, n_indent::Int=1)\n\nPrints the variation ID information for each varied input in the VariationID object.\n\n\n\n\n\n","category":"function"},{"location":"man/analyzing_output/#Analyzing-output","page":"Analyzing output","title":"Analyzing output","text":"","category":"section"},{"location":"man/analyzing_output/#Install-dependencies","page":"Analyzing output","title":"Install dependencies","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Julia has several packages for plotting. Here, we will use Plots.jl which you can install with","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"pkg> add Plots","category":"page"},{"location":"man/analyzing_output/#Loading-output","page":"Analyzing output","title":"Loading output","text":"","category":"section"},{"location":"man/analyzing_output/#PhysiCellSnapshot","page":"Analyzing output","title":"PhysiCellSnapshot","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The base unit of PhysiCell output is the PhysiCellSnapshot. These are currently considered pcvct internals and so the API may change. Each snapshot records the path to the PhysiCell output folder, its index in the sequence of outputs, the time of the snapshot in the simulation, and optionally the cell, substrate, and mesh data at that snapshot.","category":"page"},{"location":"man/analyzing_output/#PhysiCellSequence","page":"Analyzing output","title":"PhysiCellSequence","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"A PhysiCellSequence is the full sequence of snapshots corresponding to a single PhysiCell simulation. As with PhysiCellSnapshot's, these are currently considered internals and their API may change. In addition to the path to the PhysiCell output folder and the vector of PhysiCellSnapshot's, it holds metadata for the simulation.","category":"page"},{"location":"man/analyzing_output/#getCellDataSequence","page":"Analyzing output","title":"getCellDataSequence","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The main function to get sequences of cell data is getCellDataSequence. It accepts any of a simulation ID (<:Integer), a simulation (::Simulation), or a sequence (::PhysiCellSequence) and either a single label (::String) or a vector of labels (::Vector{String}). For each cell in the simulation (as determined by the cell ID), the output creates a dictionary entry (the key is the integer cell ID) whose value is a named tuple with the input labels as keys as well as :time. This means that if one sets","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"data = getCellDataSequence(1, \"position\")","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Then one can access the positions of the cell with ID 78 by","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"cell_78_positions = data[78].position # an Nx3 matrix for the N integer-indexed outputs (ignores the `initial_*` and `final_*` files)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"and plot the x-coordinates of this cell over time using","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"cell_78_times = data[78].time\n\nusing Plots\nplot(cell_78_times, cell_78_positions[:,1])","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Note: Each call to getCellDataSequence will load all the data unless a PhysiCellSequence is passed in. Plan your analyses accordingly as loading simulation data is not fast.","category":"page"},{"location":"man/analyzing_output/#Population-plots","page":"Analyzing output","title":"Population plots","text":"","category":"section"},{"location":"man/analyzing_output/#Group-by-Monad","page":"Analyzing output","title":"Group by Monad","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Plotting population plots is one the most basic analysis tasks and pcvct makes it super easy! If you call plot on a Simulation, Monad, Sampling, or the return value of a call to run (though not for a sensitivity analysis), then a sequence of panels will be generated in a single figure. Each panel will correspond to a Monad (replicates using the same parameter values) and will plot mean +/- SD for each cell type.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finer-grained control of the output is possible, too!","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"to include dead cells in your counts: plot(...; ..., include_dead=true, ...)\nselect a subset of cell types to include: plot(...; ..., include_cell_types=\"cancer\", ...)\nselect a subset of cell types to exclude: plot(...; ..., exclude_cell_types=\"cancer\", ...)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The include_cell_types and exclude_cell_types can also accept a Vector{String} to include or exclude certain cell types, respectively. Furthermore, if the value of include_cell_types is a Vector and one of its entries is a Vector{String}, pcvct will interpret this to sum up those cell types. In other words, to get the total tumor cell count in addition to the epithelial (\"epi\") and mesenchymal (\"mes\") components, you could use","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\nplot(Monad(1); include_cell_types=[\"epi\", \"mes\", [\"epi\", \"mes\"]])","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finally, this makes use of Julia's Plot Recipes (see RecipesBase.jl) so any standard plotting keywords can be passed in:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\ncolors = [:blue :red] # Note the absence of a `,` or `;`. This is how Julia requires different series parameters to be passed in \nplot(Simulation(1); color=colors, include_cell_types=[\"cd8\", \"cancer\"]) # will plot cd8s in blue and cancer in red.","category":"page"},{"location":"man/analyzing_output/#Group-by-cell-type","page":"Analyzing output","title":"Group by cell type","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Invert the above by including all data for a single cell type across all monads in a single panel with a call to plotbycelltype. This function works on any T<:AbstractTrial (Simulation, Monad, Sampling, or Trial) as well as any PCVCTOutput object (the return value to run). Everything above for plot applies here.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\nplotbycelltype(Sampling(1); include_cell_types=[\"epi\", \"mes\", [\"epi\", \"mes\"]], color=[:blue :red :purple], labels=[\"epi\" \"mes\" \"both\"], legend=true)","category":"page"},{"location":"man/analyzing_output/#Substrate-analysis","page":"Analyzing output","title":"Substrate analysis","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"pcvct supports two ways to summarize substrate information over time.","category":"page"},{"location":"man/analyzing_output/#AverageSubstrateTimeSeries","page":"Analyzing output","title":"AverageSubstrateTimeSeries","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An AverageSubstrateTimeSeries gives the time series for the average substrate across the entire domain.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nasts = pcvct.AverageSubstrateTimeSeries(simulation_id)\nusing Plots\nplot(asts.time, asts[\"oxygen\"])","category":"page"},{"location":"man/analyzing_output/#ExtracellularSubstrateTimeSeries","page":"Analyzing output","title":"ExtracellularSubstrateTimeSeries","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An ExtracellularSubstrateTimeSeries gives the time series for the average substrate concentration in the extracellular space neighboring all cells of a given cell type. In a simulation with cd8 cells and IFNg diffusible substrate, plot the average concentration of IFNg experienced by CD8+ T cells using the following:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nests = pcvct.ExtracellularSubstrateTimeSeries(simulation_id)\nusing Plots\nplot(ests.time, ests[\"cd8\"][\"IFNg\"])","category":"page"},{"location":"man/analyzing_output/#Motility-analysis","page":"Analyzing output","title":"Motility analysis","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The motilityStatistics function returns the time alive, distance traveled, and mean speed for each cell in the simulation. For each cell, these values are split amongst the cell types the given cell assumed throughout (or at least at the save times). To calculate these values, the cell type at the start of the save interval is used and the net displacement is used to calculate the speed. Optionally, users can pass in a coordinate direction to only consider speed in a given axis.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nmss = motilityStatistics(simulation_id)\nall_mean_speeds_as_mes = [ms[\"mes\"].speed for ms in mss if haskey(ms, \"mes\")] # concatenate all speeds as a \"mes\" cell type (if the given cell ever was a \"mes\")\nall_times_as_mes = [ms[\"mes\"].time for ms in mss if haskey(ms, \"mes\")] # similarly, get the time spent in the \"mes\" state\nmean_mes_speed = all_mean_speeds_as_mes .* all_times_as_mes |> sum # start computing the weighted average of their speeds\nmean_mes_speed /= sum(all_times_as_mes) # finish computing weighted average","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"mss = motilityStatistics(simulation_id; direction=:x) # only consider the movement in the x direction","category":"page"},{"location":"man/analyzing_output/#Pair-correlation-function-(PCF)","page":"Analyzing output","title":"Pair correlation function (PCF)","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Sometimes referred to as radial distribution functions, the pair correlation function (PCF) computes the density of target cells around center cells. If the two sets of cells are the same (centers = targets), this is called PCF. If the two are not equal, this is sometimes called cross-PCF. Both can be computed with a call to pcvct.pcf (or just pcf if using PairCorrelationFunction has been called).","category":"page"},{"location":"man/analyzing_output/#Arguments","page":"Analyzing output","title":"Arguments","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"PCF computations can readily be called on PhysiCellSnapshot's, PhysiCellSequence's, or Simulation's. If the first argument in a call to pcf is an Integer, this is treated as a simulation ID. If this is followed by an index (of type Integer or value :initial or :final), this is treated as a snapshot; otherwise, it computes the PCF for the entire simulation.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The next argument is the cell type to use as the center cells as either a String or Vector{String}, representing the name of the cell type(s). If the target cells are different from the center cells, the next argument is the target cell type as either a String or Vector{String}. If omitted, the target cell type is the same as the center cell type and a (non-cross) PCF is computed. The resulting sets of center and target cell types must either be identical or have no overlap.","category":"page"},{"location":"man/analyzing_output/#Keyword-arguments","page":"Analyzing output","title":"Keyword arguments","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The following keyword arguments are available:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"include_dead::Union{Bool, Tuple{Bool,Bool}} = false: whether to include dead cells in the PCF computation.\nIf true, all cells are included.\nIf false, only live cells are included.\nIf a tuple, the first value is for the center cells and the second is for the target cells.\ndr::Float64 = 20.0: the step size for the radial bins in micrometers.","category":"page"},{"location":"man/analyzing_output/#Output","page":"Analyzing output","title":"Output","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The output of pcf is a PCVCTPCFResult object which has two fields: time and pcf_result. The time field is always a vector of the time points at which the PCF was computed, even if computing PCF for a single snapshot. The pcf_result is of type PairCorrelationFunction.PCFResult and has two fields: radii and g. The radii is the set of cutoffs used to compute the PCF and g is either a vector or a matrix of the PCF values of size length(radii)-1 by length(time).","category":"page"},{"location":"man/analyzing_output/#Plotting","page":"Analyzing output","title":"Plotting","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An API to make use of the PairCorrelationFunction package plotting interface is available through the plot function. Simply pass in the PCVCTPCFResult! You can pass in as many such objects as you like or pass in a Vector{PCVCTPCFResult}. In this case, these are interpreted as stochastic realizations of the same PCF and summary statistics are used to plot. See the PairCorrelationFunction documentation for more details.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The pcvct implementation supports two keyword arguments:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"time_unit::Symbol = :min: the time unit to use for the time axis (only relevant if the PCVCTPCFResult has more than one time point).\nThe default is :min and the other options are :s, :h, :d, :w, :mo, :y.\ndistance_unit::Symbol = :um: the distance unit to use for the distance axis.\nThe default is :um and the other options are :mm and :cm.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finally, a keyword argument supported by PairCorrelationFunction is colorscheme which can be used to change the colorscheme of the color map. pcvct overrides the default from PairCorrelationFunction (:tofino) with :cork to use white to represent values near one.","category":"page"},{"location":"man/analyzing_output/#Examples","page":"Analyzing output","title":"Examples","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nresult = pcvct.pcf(simulation_id, \"cancer\", \"cd8\") # using PairCorrelationFunction will obviate the need to prefix with `pcvct`\nplot(result) # heatmap of proximity of (living) cd8s to (living) cancer cells throughout simulation 1","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"monad = Monad(1) # let's assume that there are >1 simulations in this monad\nresults = [pcvct.pcf(simulation_id, :final, \"cancer\", \"cd8\") for simulation_id in getSimulationIDs(monad)] # one vector of PCF values for each simulation at the final snapshot\nplot(results) # line plot of average PCF values against radius across the monad +/- 1 SD","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"monad = Monad(1) # let's assume that there are >1 simulations in this monad\nresults = [pcvct.pcf(simulation_id, \"cancer\", \"cd8\") for simulation_id in getSimulationIDs(monad)] # one matrix of PCF values for each simulation across all time points\nplot(results) # heatmap of average PCF values with time on the x-axis and radius on the y-axis; averages omit NaN values that can occur at higher radii","category":"page"},{"location":"man/analyzing_output/#Graph-analysis","page":"Analyzing output","title":"Graph analysis","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Every PhysiCell simulation produces three different directed graphs at each save time point. For each graph, the vertices are the cell agents and the edges are as follows:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":":neighbors: the cells overlap based on their positions and radii\n:attachments: manually-defined attachments between cells\n:spring_attachments: spring attachments formed automatically using attachment rates","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Each of these graphs is expected to be symmetric, i.e., if cell A is attached to cell B, then cell B is attached to cell A. Nonetheless, pcvct holds the data in a directed graph.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Currently, pcvct supports computing connected components for any of these graphs using the connectedComponents function. For an pcvct.AbstractPhysiCellSequence object, the graphs can be loaded using the loadGraph! function for any other analysis.","category":"page"},{"location":"man/analyzing_output/#Examples-2","page":"Analyzing output","title":"Examples","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"For all examples that follow, we will assume a PhysiCellSnapshot object called snapshot has been created, e.g., as follows:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nindex = :final\nsnapshot = PhysiCellSnapshot(simulation_id, index)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"To get a list of the connected components for the :neighbors graph for all living cells in a simulation at the final timepoint, use","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"connected_components = connectedComponents(snapshot) # defaults to the :neighbors graph, all cells, and exclude dead cells","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The connected_components object is a Dict with the cell type names in a single vector as the only key with value a vector of vectors. Each element is a vector of the cell IDs belonging to that connected component in the wrapper type pcvct.AgentID.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"If you want to compute connected components for subsets of cells, pass in a vector of vectors of cell type names (Strings) such that each vector corresponds to a subset of cell types.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"subset_1 = [\"cd8_active\", \"cd8_inactive\"]\nsubset_2 = [\"cancer_epi\", \"cancer_mes\"]\nconnected_components = connectedComponents(snapshot; include_cell_types=[subset_1, subset_2])","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"In this case, the connected_components object is a Dict with subset_1 and subset_2 as the keys (the values stored in them, not the strings \"subset_1\" and \"subset_2\"). The value connected_components[subset_1] is a vector of vectors of the cell IDs belonging to each connected component just considering the cells in subset_1. Similarly for subset_2.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Including dead cells is possible though not recommended. This is because dead cells automatically clear their neighbors and attachments. The optional keyword argument include_dead can be set to true to include dead cells in the graph.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"connected_components = connectedComponents(snapshot; include_dead=true)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finally, to combine a single connected component with the dataframe of cell data, the following can be used:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"connected_components = connectedComponents(snapshot)\nconnected_components_1 = connected_components |> # julia's pipe operator\n                         values |>  # get the value for each key\n                         first |> # get the connected components for the first subset of cells (in this case there's only one subset consisting of all cells)\n                         first # get the first connected component for this subset\n\nloadCells!(snapshot) # make sure the cell data is loaded\ncells_df = snapshot.cells # this is the cell data\n\nagent_ids = DataFrame(ID=[a.id for a in connected_components_1]) # get the IDs for the agents in the connected component\ncomponent_df = rightjoin(cells_df, agent_ids, on=:ID) # join on the agent IDs, keeping only the rows in the connected component","category":"page"},{"location":"lib/pcvct/#Core","page":"Core","title":"Core","text":"","category":"section"},{"location":"lib/pcvct/","page":"Core","title":"Core","text":"Core functionality for pcvct.","category":"page"},{"location":"lib/pcvct/#pcvct.PHYSICELL_CPP","page":"Core","title":"pcvct.PHYSICELL_CPP","text":"PHYSICELL_CPP::String\n\nThe compiler used to compile the PhysiCell code. This is set when the model manager is initialized.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.current_physicell_version_id","page":"Core","title":"pcvct.current_physicell_version_id","text":"current_physicell_version_id::Int\n\nThe ID of the current version of PhysiCell being used as defined in the database. This is set when the model manager is initialized.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.data_dir","page":"Core","title":"pcvct.data_dir","text":"data_dir::String\n\nThe path to the data directory. This is set when the model manager is initialized.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.initialized","page":"Core","title":"pcvct.initialized","text":"initialized::Bool\n\nA boolean that indicates whether a project database has been initialized to be used with pcvct.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.inputs_dict","page":"Core","title":"pcvct.inputs_dict","text":"inputs_dict::Dict{Symbol, Any}\n\nA dictionary that maps the types of inputs to the data that defines how they are set up and what they can do. Read in from the inputs.toml file in the data directory.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.march_flag","page":"Core","title":"pcvct.march_flag","text":"march_flag::String\n\nThe march flag to be used when compiling the code.\n\nIf running on an HPC, this is set to \"x86-64\" which will work across different CPU manufacturers that may be present on an HPC. Otherwise, set to \"native\".\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.max_number_of_parallel_simulations","page":"Core","title":"pcvct.max_number_of_parallel_simulations","text":"max_number_of_parallel_simulations::Int\n\nThe maximum number of parallel simulations that can be run at once. If running on an HPC, this is ignored and instead pcvct will queue one job per simulation.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.physicell_dir","page":"Core","title":"pcvct.physicell_dir","text":"physicell_dir::String\n\nThe path to the PhysiCell directory. This is set when the model manager is initialized.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.run_on_hpc","page":"Core","title":"pcvct.run_on_hpc","text":"run_on_hpc::Bool\n\nA boolean that indicates whether the code is running on an HPC environment.\n\nThis is set to true if the sbatch command is available when compiling pcvct.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.sbatch_options","page":"Core","title":"pcvct.sbatch_options","text":"sbatch_options::Dict{String,Any}\n\nA dictionary that will be used to pass options to the sbatch command.\n\nThe keys are the flag names and the values are the values used for the flag. This is initialized using defaultJobOptions and can be modified using setJobOptions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/pcvct/#pcvct.baseToExecutable","page":"Core","title":"pcvct.baseToExecutable","text":"baseToExecutable(s::String)\n\nConvert a string to an executable name based on the operating system. If the operating system is Windows, append \".exe\" to the string.\n\n\n\n\n\n","category":"function"},{"location":"lib/pcvct/#pcvct.constituentsType-Tuple{Type{Simulation}}","page":"Core","title":"pcvct.constituentsType","text":"constituentsType(T::Type{<:AbstractTrial})\nconstituentsType(T::AbstractTrial)\n\nReturn the type of the constituents of T. Used in the readConstituentIDs function.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.constituentsTypeFilename-Tuple{Any}","page":"Core","title":"pcvct.constituentsTypeFilename","text":"constituentsTypeFilename(T::Type{<:AbstractTrial})\nconstituentsTypeFilename(T::AbstractTrial)\n\nReturn the filename of the constituents of T. Used in the readConstituentIDs function.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.getMonadIDs-Tuple{}","page":"Core","title":"pcvct.getMonadIDs","text":"getMonadIDs()\n\nReturn a vector of all monad IDs in the database.\n\nAlternate forms take a monad, sampling, or trial object (or an array of any combination of them) and return the corresponding monad IDs.\n\nExamples\n\ngetMonadIDs() # all monad IDs in the database\ngetMonadIDs(monad) # just a vector with the monad ID, i.e. [monad.id]\ngetMonadIDs(sampling) # all monad IDs in a sampling\ngetMonadIDs(trial) # all monad IDs in a trial\ngetMonadIDs([trial1, trial2]) # all monad IDs between trial1 and trial2\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.getSamplingSimulationIDs-Tuple{Int64}","page":"Core","title":"pcvct.getSamplingSimulationIDs","text":"getSamplingSimulationIDs(sampling_id::Int)\n\nInternal function to get the simulation IDs for a given sampling ID. Users should use getSimulationIDs instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.getSimulationIDs-Tuple{}","page":"Core","title":"pcvct.getSimulationIDs","text":"getSimulationIDs()\n\nReturn a vector of all simulation IDs in the database.\n\nAlternate forms take a simulation, monad, sampling, or trial object (or an array of any combination of them) and return the corresponding simulation IDs.\n\nExamples\n\ngetSimulationIDs() # all simulation IDs in the database\ngetSimulationIDs(simulation) # just a vector with the simulation ID, i.e. [simulation.id]\ngetSimulationIDs(monad) # all simulation IDs in a monad\ngetSimulationIDs(sampling) # all simulation IDs in a sampling\ngetSimulationIDs(trial) # all simulation IDs in a trial\ngetSimulationIDs([trial1, trial2]) # all simulation IDs between trial1 and trial2\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.getTrialMonads-Tuple{Int64}","page":"Core","title":"pcvct.getTrialMonads","text":"getTrialMonads(trial_id::Int)\n\nInternal function to get the monad IDs for a given trial ID. Users should use getMonadIDs instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.getTrialSimulationIDs-Tuple{Int64}","page":"Core","title":"pcvct.getTrialSimulationIDs","text":"getTrialSimulationIDs(trial_id::Int)\n\nInternal function to get the simulation IDs for a given trial ID. Users should use getSimulationIDs instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.initializeModelManager-Tuple{String, String}","page":"Core","title":"pcvct.initializeModelManager","text":"initializeModelManager(path_to_physicell::String, path_to_data::String)\n\nInitialize the VCT environment by setting the paths to PhysiCell and data directories, and initializing the database.\n\nArguments\n\npath_to_physicell::String: Path to the PhysiCell directory as either an absolute or relative path.\npath_to_data::String: Path to the data directory as either an absolute or relative path.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.initializeModelManager-Tuple{}","page":"Core","title":"pcvct.initializeModelManager","text":"initializeModelManager()\n\nInitialize the VCT environment assuming that the PhysiCell and data directories are in the current working directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.lowerClassString-Tuple{Type{<:pcvct.AbstractTrial}}","page":"Core","title":"pcvct.lowerClassString","text":"lowerClassString(T::AbstractTrial)\nlowerClassString(T::Type{<:AbstractTrial})\n\nReturn the lowercase string representation of the type of T, excluding the module name. Without this, it may return, e.g., Main.pcvct.Sampling.\n\nExamples\n\nlowerClassString(Simulation) # \"simulation\"\nlowerClassString(Simulation(1)) # \"simulation\"\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.pcvctLogo-Tuple{}","page":"Core","title":"pcvct.pcvctLogo","text":"pcvctLogo()\n\nReturn a string representation of the awesome pcvct logo.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.readConstituentIDs-Tuple{String}","page":"Core","title":"pcvct.readConstituentIDs","text":"readConstituentIDs(T::AbstractTrial)\n\nRead a CSV file containing constituent IDs from T and return them as a vector of integers.\n\nFor a trial, this is the sampling IDs. For a sampling, this is the monad IDs. For a monad, this is the simulation IDs.\n\nExamples\n\nids = readConstituentIDs(Sampling(1)) # read the IDs of the monads in sampling 1\nids = readConstituentIDs(Sampling, 1) # identical to above but does not need to create the Sampling object\n\nids = readConstituentIDs(Monad, 1) # read the IDs of the simulations in monad 1\nids = readConstituentIDs(Trial, 1) # read the IDs of the samplings in trial 1\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.setMarchFlag-Tuple{String}","page":"Core","title":"pcvct.setMarchFlag","text":"setMarchFlag(flag::String)\n\nSet the march flag to flag. Used for compiling the PhysiCell code.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.setNumberOfParallelSims-Tuple{Int64}","page":"Core","title":"pcvct.setNumberOfParallelSims","text":"setNumberOfParallelSims(n::Int)\n\nSet the maximum number of parallel simulations to n.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.trialFolder-Tuple{Type{<:pcvct.AbstractTrial}, Int64}","page":"Core","title":"pcvct.trialFolder","text":"trialFolder(T::Type{<:AbstractTrial}, id::Int)\n\nReturn the path to the folder for a given subtype of AbstractTrial and ID.\n\nExamples\n\ntrialFolder(Simulation, 1)\n# output\n\"abs/path/to/data/outputs/simulations/1\"\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct/#pcvct.trialFolder-Tuple{pcvct.AbstractTrial}","page":"Core","title":"pcvct.trialFolder","text":"trialFolder(T::Type{<:AbstractTrial})\n\nReturn the path to the folder for the AbstractTrial object, T.\n\nExamples\n\nsimulation = Simulation(1)\ntrialFolder(Simulation)\n# output\n\"abs/path/to/data/outputs/simulations/1\"\n\n\n\n\n\n","category":"method"},{"location":"lib/hpc/#HPC","page":"HPC","title":"HPC","text":"","category":"section"},{"location":"lib/hpc/","page":"HPC","title":"HPC","text":"Run pcvct on an HPC.","category":"page"},{"location":"lib/hpc/#pcvct.defaultJobOptions-Tuple{}","page":"HPC","title":"pcvct.defaultJobOptions","text":"defaultJobOptions()\n\nReturn a dictionary with default options for a job script for use with SLURM. See setJobOptions for setting these options and others.\n\nCurrent defaults are:\n\njob-name: simulation_id -> \"S$(simulation_id)\" (use the simulation ID for the job name)\nmem: \"1G\" (1 GB of memory)\n\n\n\n\n\n","category":"method"},{"location":"lib/hpc/#pcvct.isRunningOnHPC-Tuple{}","page":"HPC","title":"pcvct.isRunningOnHPC","text":"isRunningOnHPC()\n\nReturn true if the current environment is an HPC environment, false otherwise.\n\nCurrently, this function checks if the sbatch command is available, indicating a SLURM environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/hpc/#pcvct.setJobOptions-Tuple{Dict}","page":"HPC","title":"pcvct.setJobOptions","text":"setJobOptions(options::Dict)\n\nSet the default job options for use with SLURM.\n\nFor any key-value pair in options, the corresponding key in the global sbatch_options dictionary is set to the value. A flag is then added to the sbatch command for each key-value pair in options: --key=value. When running simulations, any values in this dictionary that are Function's will be assumed to be functions of the simulation id.\n\n\n\n\n\n","category":"method"},{"location":"lib/hpc/#pcvct.shellCommandExists-Tuple{Union{Cmd, String}}","page":"HPC","title":"pcvct.shellCommandExists","text":"shellCommandExists(cmd::Union{String,Cmd})\n\nCheck if a shell command exists in the current environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/hpc/#pcvct.useHPC","page":"HPC","title":"pcvct.useHPC","text":"useHPC([use::Bool=true])\n\nSet the global variable run_on_hpc to use.\n\nExamples\n\nuseHPC() # Set to true so `sbatch` is used for running simulations\nuseHPC(true) # set to true so `sbatch` is used for running simulations\nuseHPC(false) # Set to false so simulations are run locally\n\n\n\n\n\n","category":"function"},{"location":"lib/pcvct_version/#PCVCT-Version","page":"PCVCT Version","title":"PCVCT Version","text":"","category":"section"},{"location":"lib/pcvct_version/","page":"PCVCT Version","title":"PCVCT Version","text":"Manage the version of PCVCT in the database.","category":"page"},{"location":"lib/pcvct_version/#pcvct.createPCVCTVersionTable-Tuple{Bool}","page":"PCVCT Version","title":"pcvct.createPCVCTVersionTable","text":"createPCVCTVersionTable(is_new_db::Bool)\n\nCreates the pcvctversion table in the database if it does not exist. If isnew_db is true, it inserts the current pcvct version into the table.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct_version/#pcvct.pcvctDBVersion-Tuple{Bool}","page":"PCVCT Version","title":"pcvct.pcvctDBVersion","text":"pcvctDBVersion(is_new_db::Bool)\n\nReturns the version of the pcvct database. If the database does not exist, it creates a new one with the current pcvct version.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct_version/#pcvct.pcvctVersion-Tuple{}","page":"PCVCT Version","title":"pcvct.pcvctVersion","text":"pcvctVersion()\n\nReturns the version of the pcvct package.\n\n\n\n\n\n","category":"method"},{"location":"lib/pcvct_version/#pcvct.resolvePCVCTVersion-Tuple{Bool, Bool}","page":"PCVCT Version","title":"pcvct.resolvePCVCTVersion","text":"resolvePCVCTVersion(is_new_db::Bool, auto_upgrade::Bool)\n\nResolve differences between the pcvct version and the database version. If the pcvct version is lower than the database version, it returns false (upgrade your version of pcvct to match what was already used for the database). If the pcvct version is equal to the database version, it returns true. If the pcvct version is higher than the database version, it upgrades the database to the current pcvct version and returns true.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_studio/#PhysiCell-Studio","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"","category":"section"},{"location":"lib/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"Launch PhysiCell Studio for a simulation run in pcvct.","category":"page"},{"location":"lib/physicell_studio/#pcvct.cleanUpStudioInputs-Tuple{String, Union{Nothing, String}}","page":"PhysiCell Studio","title":"pcvct.cleanUpStudioInputs","text":"cleanUpStudioInputs(path_to_temp_xml::String, path_to_input_rules::Union{Nothing,String})\n\nClean up the temporary files created for PhysiCell Studio.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_studio/#pcvct.executeStudio-Tuple{String}","page":"PhysiCell Studio","title":"pcvct.executeStudio","text":"executeStudio(path_to_temp_xml::String)\n\nRun PhysiCell Studio with the given temporary XML file.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_studio/#pcvct.resolveStudioGlobals-Tuple{Union{Missing, String}, Union{Missing, String}}","page":"PhysiCell Studio","title":"pcvct.resolveStudioGlobals","text":"resolveStudioGlobals(python_path::Union{Missing,String}, studio_path::Union{Missing,String})\n\nSet the global variables path_to_python and path_to_studio to the given paths.\n\nThey are required to not be missing so that the function runStudio works.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_studio/#pcvct.runStudio-Tuple{Int64}","page":"PhysiCell Studio","title":"pcvct.runStudio","text":"runStudio(simulation_id::Int; python_path::Union{Missing,String}=path_to_python, studio_path::Union{Missing,String}=path_to_studio)\n\nLaunch PhysiCell Studio for a given simulation.\n\nCreates temporary config and rules files to avoid overwriting the original files in the output folder. The intent of this function is to allow users to visualize the results of a simulation with Studio, rather than to modify the simulation itself.\n\nThe path to the python executable and the Studio folder must be set. When calling using pcvct, shell environment variables PCVCT_PYTHON_PATH and PCVCT_STUDIO_PATH will be used to set the path to the python executable and the Studio folder, respectively. Note: these should match how you would run PhysiCell Studio from the command line, e.g.: export PCVCT_PYTHON_PATH=python.\n\nIf the paths are not set in the environment, they can be passed as the keyword arguments python_path and studio_path to this function. In this case, the paths will be set as global variables for the duration of the Julia session and do not need to be passed again.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_studio/#pcvct.setUpStudioInputs-Tuple{Int64}","page":"PhysiCell Studio","title":"pcvct.setUpStudioInputs","text":"setUpStudioInputs(simulation_id::Int)\n\nSet up the inputs for PhysiCell Studio. Creates a temporary XML file and a temporary rules file (if applicable) in the output folder of the simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#Sensitivity","page":"Sensitivity","title":"Sensitivity","text":"","category":"section"},{"location":"lib/sensitivity/","page":"Sensitivity","title":"Sensitivity","text":"Run sensitivity analyses on a model.","category":"page"},{"location":"lib/sensitivity/#pcvct.GSAMethod","page":"Sensitivity","title":"pcvct.GSAMethod","text":"GSAMethod\n\nAbstract type for global sensitivity analysis methods.\n\nSubtypes\n\nMOAT\nSobolʼ\nRBD\n\nMethods\n\nrun\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.GSASampling","page":"Sensitivity","title":"pcvct.GSASampling","text":"GSASampling\n\nStore the information that comes out of a global sensitivity analysis method.\n\nSubtypes\n\nMOATSampling\nSobolSampling\nRBDSampling\n\nMethods\n\ncalculateGSA!, evaluateFunctionOnSampling, getMonadIDDataFrame, getSimulationIDs, methodString, sensitivityResults!, recordSensitivityScheme\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.MOAT","page":"Sensitivity","title":"pcvct.MOAT","text":"MOAT\n\nStore the information necessary to run a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nlhs_variation::LHSVariation: the Latin Hypercube Sampling (LHS) variation to use for the MOAT. See LHSVariation.\n\nExamples\n\nNote: any keyword arguments in the MOAT constructor are passed to LHSVariation.\n\nMOAT() # default to 15 base points\nMOAT(10) # 10 base points\nMOAT(10; add_noise=true) # do not restrict the base points to the center of their cells\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.MOATSampling","page":"Sensitivity","title":"pcvct.MOATSampling","text":"MOATSampling\n\nStore the information that comes out of a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.MorrisResult}: the results of the sensitivity analysis for each function.\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.RBD","page":"Sensitivity","title":"pcvct.RBD","text":"RBD\n\nStore the information necessary to run a Random Balance Design (RBD) global sensitivity analysis.\n\nBy default, RBD will use the Sobol' sequence to sample the parameter space. See below for how to turn this off. Currently, users cannot control the Sobolʼ sequence used in RBD to the same degree it can be controlled in Sobolʼ. Open an Issue if you would like this feature.\n\nFields\n\nrbd_variation::RBDVariation: the RBD variation to use for the RBD analysis. See RBDVariation.\nnum_harmonics::Int: the number of harmonics to use from the Fourier transform for the RBD analysis.\n\nExamples\n\nNote: any keyword arguments in the RBD constructor are passed to RBDVariation, except for the num_harmonics keyword argument. If num_harmonics is not specified, it defaults to 6.\n\nRBD(15) # 15 points from the Sobol' sequence\nRBD(15; num_harmonics=10) # use 10 harmonics\nRBD(15; use_sobol=false) # opt out of using the Sobol' sequence, instead using a random sequence in each dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.RBDSampling","page":"Sensitivity","title":"pcvct.RBDSampling","text":"RBDSampling\n\nStore the information that comes out of a Random Balance Design (RBD) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nnum_harmonics::Int: the number of harmonics used in the Fourier transform.\nnum_cycles::Union{Int, Rational}: the number of cycles used for each parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.SobolSampling","page":"Sensitivity","title":"pcvct.SobolSampling","text":"SobolSampling\n\nStore the information that comes out of a Sobol' global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods used for calculating the first and total order indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#pcvct.Sobolʼ","page":"Sensitivity","title":"pcvct.Sobolʼ","text":"Sobolʼ\n\nStore the information necessary to run a Sobol' global sensitivity analysis as well as how to extract the first and total order indices.\n\nThe rasp symbol is used to avoid conflict with the Sobol module. To type it in VS Code, use \\rasp and then press tab. The methods available for the first order indices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. The methods available for the total order indices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.\n\nFields\n\nsobol_variation::SobolVariation: the Sobol' variation to use for the Sobol' analysis. See SobolVariation.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods to use for calculating the first and total order indices.\n\nExamples\n\nNote: any keyword arguments in the Sobolʼ constructor are passed to SobolVariation, except for the sobol_index_methods keyword argument. Do not use the n_matrices keyword argument in the SobolVariation constructor as it is set to 2 as required for Sobol' analysis.\n\nSobolʼ(15) # 15 points from the Sobol' sequence\nSobolʼ(15; sobol_index_methods=(first_order=:Jansen1999, total_order=:Jansen1999)) # use Jansen, 1999 for both first and total order indices\nSobolʼ(15; randomization=NoRand())` # use the default Sobol' sequence with no randomization. See GlobalSensitivity.jl for more options.\nSobolʼ(15; skip_start=true) # force the Sobol' sequence to skip to the lowest denominator in the sequence that can hold 15 points, i.e., choose from [1/32, 3/32, 5/32, ..., 31/32]\nSobolʼ(15; skip_start=false) # force the Sobol' sequence to start at the beginning, i.e. [0, 0.5, 0.25, 0.75, ...]\nSobolʼ(15; include_one=true) # force the Sobol' sequence to include 1 in the sequence\n\n\n\n\n\n","category":"type"},{"location":"lib/sensitivity/#Base.run-Tuple{pcvct.GSAMethod, Integer, InputFolders, Union{pcvct.AbstractVariation, AbstractVector{<:pcvct.AbstractVariation}}}","page":"Sensitivity","title":"Base.run","text":"run(method::GSAMethod, args...; functions::AbstractVector{<:Function}=Function[], kwargs...)\n\nRun a global sensitivity analysis method on the given arguments.\n\nArguments\n\nmethod::GSAMethod: the method to run. Options are MOAT, Sobolʼ, and RBD.\nn_replicates::Integer: the number of replicates to run for each monad, i.e., at each sampled parameter vector.\ninputs::InputFolders: the input folders shared across all simuations to run.\navs::AbstractVector{<:AbstractVariation}: the elementary variations to sample. These can be either DiscreteVariation's or DistributedVariation's.\n\nAlternatively, the third argument, inputs, can be replaced with a reference::AbstractMonad, i.e., a simulation or monad to be the reference. This should be preferred to setting reference variation IDs manually, i.e., if not using the base files in the input folders.\n\nKeyword Arguments\n\nThe reference_variation_id keyword argument is only compatible when the third argument is of type InputFolders. Otherwise, the reference simulation/monad will set the reference variation values.\n\nreference_variation_id::VariationID: the reference variation IDs as a VariationID\nignore_indices::AbstractVector{<:Integer}=[]: indices into avs to ignore when perturbing the parameters. Only used for Sobolʼ. See Sobolʼ for a use case.\nforce_recompile::Bool=false: whether to force recompilation of the simulation code\nprune_options::PruneOptions=PruneOptions(): the options for pruning the simulation results\nuse_previous::Bool=true: whether to use previous simulation results if they exist\nfunctions::AbstractVector{<:Function}=Function[]: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.calculateGSA!-Tuple{pcvct.GSASampling, AbstractVector{<:Function}}","page":"Sensitivity","title":"pcvct.calculateGSA!","text":"calculateGSA!(gsa_sampling::GSASampling, functions::AbstractVector{<:Function})\n\nCalculate the sensitivity indices for the given functions.\n\nThis function is also used to compute the sensitivity indices for a single function:\n\ncalculateGSA!(gsa_sampling, f)\n\nArguments\n\ngsa_sampling::GSASampling: the sensitivity analysis to calculate the indices for.\nfunctions::AbstractVector{<:Function}: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.evaluateFunctionOnSampling-Tuple{pcvct.GSASampling, Function}","page":"Sensitivity","title":"pcvct.evaluateFunctionOnSampling","text":"evaluateFunctionOnSampling(gsa_sampling::GSASampling, f::Function)\n\nEvaluate the given function on the sampling scheme of the global sensitivity analysis, avoiding duplicate evaluations.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.getMonadIDDataFrame-Tuple{pcvct.GSASampling}","page":"Sensitivity","title":"pcvct.getMonadIDDataFrame","text":"getMonadIDDataFrame(gsa_sampling::GSASampling)\n\nGet the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.getSimulationIDs-Tuple{pcvct.GSASampling}","page":"Sensitivity","title":"pcvct.getSimulationIDs","text":"getSimulationIDs(gsa_sampling::GSASampling)\n\nGet the simulation IDs that were run in the sensitivity analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.methodString-Tuple{pcvct.GSASampling}","page":"Sensitivity","title":"pcvct.methodString","text":"methodString(gsa_sampling::GSASampling)\n\nGet the string representation of the method used in the sensitivity analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.perturbVariation-Tuple{Symbol, pcvct.ParsedVariations, String, Int64, Int64}","page":"Sensitivity","title":"pcvct.perturbVariation","text":"perturbVariation(location::Symbol, pv::ParsedVariations, folder::String, reference_variation_id::Int, d::Int)\n\nPerturb the variation at the given location and dimension for MOAT global sensitivity analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.recordSensitivityScheme-Tuple{pcvct.GSASampling}","page":"Sensitivity","title":"pcvct.recordSensitivityScheme","text":"recordSensitivityScheme(gsa_sampling::GSASampling)\n\nRecord the sampling scheme of the global sensitivity analysis to a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.runSensitivitySampling","page":"Sensitivity","title":"pcvct.runSensitivitySampling","text":"runSensitivitySampling(method::GSAMethod, args...; kwargs...)\n\nRun a global sensitivity analysis method on the given arguments.\n\nArguments\n\nmethod::GSAMethod: the method to run. Options are MOAT, Sobolʼ, and RBD.\nn_replicates::Integer: the number of replicates to run for each monad, i.e., at each sampled parameter vector.\ninputs::InputFolders: the input folders shared across all simuations to run.\npv::ParsedVariations: the ParsedVariations object that contains the variations to sample.\n\nKeyword Arguments\n\nreference_variation_id::VariationID: the reference variation IDs as a VariationID\nignore_indices::AbstractVector{<:Integer}=[]: indices into pv.variations to ignore when perturbing the parameters. Only used for Sobolʼ.\nforce_recompile::Bool=false: whether to force recompilation of the simulation code\nprune_options::PruneOptions=PruneOptions(): the options for pruning the simulation results\nuse_previous::Bool=true: whether to use previous simulation results if they exist\n\n\n\n\n\n","category":"function"},{"location":"lib/sensitivity/#pcvct.sensitivityResults!-Tuple{pcvct.GSASampling, AbstractVector{<:Function}}","page":"Sensitivity","title":"pcvct.sensitivityResults!","text":"sensitivityResults!(gsa_sampling::GSASampling, functions::AbstractVector{<:Function})\n\nCalculate the global sensitivity analysis for the given functions and record the sampling scheme.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.variationValue-Tuple{ElementaryVariation, Int64, String}","page":"Sensitivity","title":"pcvct.variationValue","text":"variationValue(ev::ElementaryVariation, variation_id::Int, folder::String)\n\nGet the value of the variation at the given variation ID for MOAT global sensitivity analysis.\n\n\n\n\n\n","category":"method"},{"location":"lib/sensitivity/#pcvct.variationsToMonads-Tuple{InputFolders, Dict{Symbol, Matrix{Int64}}}","page":"Sensitivity","title":"pcvct.variationsToMonads","text":"variationsToMonads(inputs::InputFolders, variation_ids::Dict{Symbol,Matrix{Int}}, use_previous::Bool)\n\nReturn a dictionary of monads and a matrix of monad IDs based on the given variation IDs.\n\nThe five matrix inputs together define a single matrix of variation IDs. This information, together with the inputs, identifies the monads to be used. The use_previous flag determines whether to use previous simulations, if they exist.\n\nReturns\n\nmonad_dict::Dict{VariationID, Monad}: a dictionary of the monads to be used without duplicates.\nmonad_ids::Matrix{Int}: a matrix of the monad IDs to be used. Matches the shape of the input IDs matrices.\n\n\n\n\n\n","category":"method"},{"location":"man/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"man/","page":"Index","title":"Index","text":"","category":"page"},{"location":"lib/user_api/#User-API","page":"User API","title":"User API","text":"","category":"section"},{"location":"lib/user_api/","page":"User API","title":"User API","text":"Main functions users will use to create and run simulations, monads, samplings, and trials.","category":"page"},{"location":"lib/user_api/#Base.run-Tuple{pcvct.AddVariationMethod, Vararg{Any}}","page":"User API","title":"Base.run","text":"run(args...; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions(), kwargs...)\n\nRun a simulation, monad, sampling, or trial with the same signatures available to createTrial.\n\n\n\n\n\n","category":"method"},{"location":"lib/user_api/#pcvct._createTrial-Tuple{pcvct.AddVariationMethod, InputFolders, pcvct.VariationID, Vector{<:pcvct.AbstractVariation}, Integer, Bool}","page":"User API","title":"pcvct._createTrial","text":"_createTrial(args...; kwargs...)\n\nInternal function to create a trial with the given input folders and elementary variations. Users should use createTrial instead.\n\nArguments\n\nmethod::AddVariationMethod: The method to use for creating the trial. Default is GridVariation().\ninputs::InputFolders: The input folders for the simulation.\nreference_variation_id::VariationID: The variation ID of the reference simulation or monad.\navs::Vector{<:AbstractVariation}: A vector of variations to add to the reference simulation or monad.\nn_replicates::Integer: The number of replicates to create. Default is 1.\nuse_previous::Bool: Whether to use previous simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/user_api/#pcvct.createTrial","page":"User API","title":"pcvct.createTrial","text":"createTrial([method=GridVariation()], inputs::InputFolders, avs::Vector{<:AbstractVariation}=AbstractVariation[];\n            n_replicates::Integer=1, use_previous::Bool=true)\n\nReturn an object of type <:AbstractTrial (simulation, monad, sampling, trial) with the given input folders and elementary variations.\n\nUses the avs and n_replicates to determine whether to create a simulation, monad, or sampling. Despite its name, trials cannot yet be created by this function. If n_replicates is 0, and each variation has a single value, a simulation will be created.\n\nBy default, the method is GridVariation(), which creates a grid of variations from the vector avs. Other methods are: LHSVariation, SobolVariation, and RBDVariation.\n\nAlternate forms (all work with the optional method argument in the first position): Only supplying a single AbstractVariation:\n\ncreateTrial(inputs::InputFolders, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nUsing a reference simulation or monad:\n\ncreateTrial(reference::AbstractMonad, avs::Vector{<:AbstractVariation}=AbstractVariation[]; n_replicates::Integer=1,\n            use_previous::Bool=true)\n\ncreateTrial(reference::AbstractMonad, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nExamples\n\ninputs = InputFolders(config_folder, custom_code_folder)\ndv_max_time = DiscreteVariation([\"overall\", \"max_time\"], 1440)\ndv_apoptosis = DiscreteVariation(pcvct.apoptosisPath(cell_type, \"rate\"), [1e-6, 1e-5])\nsimulation = createTrial(inputs, dv_max_time)\nmonad = createTrial(inputs, dv_max_time; n_replicates=2)\nsampling = createTrial(monad, dv_apoptosis; n_replicates=2) # uses the max time defined for monad\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Analyze output from a pcvct project. It is anticipated that this will eventually be split off into its own module or even package. Possibly with loader.jl.","category":"page"},{"location":"lib/analysis/#pcvct._connectedComponents-Tuple{MetaGraphsNext.MetaGraph}","page":"Analysis","title":"pcvct._connectedComponents","text":"_connectedComponents(G::MetaGraph)\n\nFind the connected components of a graph.\n\nFirst compute the transitive closure of the underlying Graphs.Graph object. Then, update the edge data of the MetaGraph object to reflect the new edges. Finally, loop over vertex labels and find the vertices they are connected to until all vertices are accounted for. Returns a list of connected components, where each component is represented as a vector of vertex labels.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.connectedComponents","page":"Analysis","title":"pcvct.connectedComponents","text":"connectedComponents(snapshot::PhysiCellSnapshot, graph=:neighbors; include_cell_types=:all_in_one, exclude_cell_types::String[], include_dead::Bool=false)\n\nFind the connected components of a graph in a PhysiCell snapshot.\n\nThe computation can be done on subsets of cells based on their cell types.\n\nArguments\n\nsnapshot::PhysiCellSnapshot: the snapshot to analyze\ngraph: the graph data to use (default is :neighbors); must be one of :neighbors, :attachments, or :spring_attachments; can also be a string\ninclude_cell_types: the cell types to include in the analysis (default is :all_in_one). Full list of options:\n:all - compute connected components for all cell types individually\n:all_in_one - compute connected components for all cell types together\n\"cell_type_1\" - compute connected components only for the cells of type cell_type_1\n[\"cell_type_1\", \"cell_type_2\"] - compute connected components for the cells of type cell_type_1 and cell_type_2 separately\n[[\"cell_type_1\", \"cell_type_2\"]] - compute connected components for the cells of type cell_type_1 and cell_type_2 together\n[[\"cell_type_1\", \"cell_type_2\"], \"cell_type_3\"] - compute connected components for the cells of type cell_type_1 and cell_type_2 together, and for the cells of type cell_type_3 separately\nexclude_cell_types: the cell types to exclude from the analysis (default is String[]); can be a single string or a vector of strings\ninclude_dead: whether to include dead cells in the analysis (default is false)\n\nReturns\n\nA dictionary in which each key is one of the following:\n\ncell type name (String)\nlist of cell type names (Vector{String})\nlist of cell type names followed by the symbol :include_dead (Vector{Any})\n\nFor each key, the value is a list of connected components in the graph. Each component is represented as a vector of vertex labels. As of this writing, the vertex labels are the simple AgentID class that wraps the cell ID.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct._motilityStatistics-Tuple{Any}","page":"Analysis","title":"pcvct._motilityStatistics","text":"_motilityStatistics(p[; direction=:any])\n\nCompute the motility statistics for a single cell in the PhysiCell simulation.\n\nAccounts for cell type transitions and computes the distance traveled, time spent, and mean speed for each cell type the given cell has taken on during the simulation. The speed can be restricted to a specific direction (x, y, z) or calculated in any direction. In either case, the distance is unsigned.\n\nThis function is used internally by motilityStatistics.\n\nReturns\n\nA Dict{String, NamedTuple} where each key is a cell type name visited by the cell and the value is a NamedTuple with fields :time, :distance, and :speed. The values in this named tuple are the time, distance traveled, and mean speed for the cell in that cell type, i.e., all scalars.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.motilityStatistics-Tuple{Integer}","page":"Analysis","title":"pcvct.motilityStatistics","text":"motilityStatistics(simulation_id::Integer[; direction=:any])\n\nReturn the mean speed, distance traveled, and time alive for each cell in the simulation, broken down by cell type in the case of cell type transitions.\n\nThe time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first. If the cell transitions to a new cell type during the simulation, the time is counted for each cell type separately. Each cell type taken on by a given cell will be a key in the dictionary returned at that entry.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation. A Simulation object can also be passed in.\ndirection::Symbol: The direction to compute the mean speed. Can be :x, :y, :z, or :any (default). If :x, for example, the mean speed is calculated using only the x component of the cell's movement.\n\nReturns\n\nVector{Dict{String, NamedTuple}}: A vector of dictionaries, one per cell in the simulation. Each dictionary has keys for each cell type taken on by the cell. The values are NamedTuples with fields :time, :distance, and :speed.\n\nExample\n\nms = motilityStatistics(1) # a vector of dictionaries, one per cell in the simulation\nms[1][\"epithelial\"] # NamedTuple with fields :time, :distance, :speed for the first cell in the simulation corresponding to its time as an `epithelial` cell\nms[1][\"mesenchymal\"].time # time spent as a `mesenchymal` cell for the first cell in the simulation\nms[1][\"mesenchymal\"].distance # distance traveled as a `mesenchymal` cell for the first cell in the simulation\nms[1][\"mesenchymal\"].speed # mean speed as a `mesenchymal` cell for the first cell in the simulation\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.PCVCTPCFResult","page":"Analysis","title":"pcvct.PCVCTPCFResult","text":"PCVCTPCFResult\n\nA struct to hold the results of the pair correlation function (PCF) calculation.\n\nThe start and end radii for each annulus are stored in the radii field. Thus, there is one more radius than there are annuli, i.e. length(radii) == size(g, 1) + 1. Each column of g corresponds to a time point in the time field, hence size(g, 2) == length(time).\n\nFields\n\ntime::Vector{Float64}: The time points at which the PCF was calculated.\npcf_result::PairCorrelationFunction.PCFResult: The result of the PCF calculation.\n\nExample\n\nusing PairCorrelationFunction\ntime = 12.0\nradii = [0.0, 1.0, 2.0]\ng = [0.5, 1.2]\npcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))\n# output\nPCVCTPCFResult:\n  Time: 12.0\n  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0\n  g: 0.5 - 1.2 (min - max)\n\nusing PairCorrelationFunction\ntime = [12.0; 24.0; 36.0]\nradii = [0.0, 1.0, 2.0]\ng = [0.5 0.6 0.4; 1.2 1.15 1.4]\npcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))\n# output\nPCVCTPCFResult:\n  Time: 12.0 - 36.0 (n = 3)\n  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0\n  g: 0.4 - 1.4 (min - max)\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#PairCorrelationFunction.pcf","page":"Analysis","title":"PairCorrelationFunction.pcf","text":"pcf(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types=center_cell_types; include_dead::Union{Bool,Tuple{Bool,Bool}}=false, dr::Float64=20.0)\n\nCalculate the pair correlation function (PCF) between two sets of cell types in a PhysiCell simulation snapshot or sequence.\n\nThe center_cell_types and target_cell_types can be strings or vectors of strings. This will compute one PCF rather than one for each pair of (center, target) cell types, i.e., all centers are compared to all targets. If omitted, the targetcelltypes will be the same as the centercelltypes, i.e., not a cross-PCF. The include_dead argument can be a boolean or a tuple of booleans to indicate whether to include the dead centers and/or targets, respectively. The dr argument specifies the bin size (thickness of each annulus) for the PCF calculation.\n\nArguments\n\nS::AbstractPhysiCellSequence: A PhysiCellSnapshot or PhysiCellSequence object.\ncenter_cell_types: The cell type name(s) to use as the center of the PCF.\ntarget_cell_types: The cell type name(s) to use as the target of the PCF.\n\nKeyword Arguments\n\ninclude_dead::Union{Bool,Tuple{Bool,Bool}}: Whether to include dead cells in the PCF calculation. If a tuple, the first element indicates whether to include dead centers and the second element indicates whether to include dead targets.\ndr::Float64: The bin size for the PCF calculation.\n\nAlternate methods\n\npcf(simulation::Simulation, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...): Calculate the PCF for a specific snapshot in a simulation.\npcf(simulation_id::Integer, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...): Calculate the PCF for a specific snapshot in a simulation by ID.\npcf(simulation_id::Integer, center_cell_types, target_cell_types=center_cell_types; kwargs...): Calculate the PCF for all snapshots in a simulation by ID.\npcf(simulation::Simulation, center_cell_types, target_cell_types=center_cell_types; kwargs...): Calculate the PCF for all snapshots in a simulation.\n\nReturns\n\nA PCVCTPCFResult object containing the time, radii, and g values of the PCF. Regardless of the type of S, the time and radii will always be vectors. If S is a snapshot, the g values will be a vector of the PCF. If S is a sequence, the g values will be a (length(radii)-1 x length(time)) matrix of the PCF.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.getCellPositionsForPCF-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, Int64}, Bool, Bool}","page":"Analysis","title":"pcvct.getCellPositionsForPCF","text":"getCellPositionsForPCF(cells::DataFrame, cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Bool, is_3d::Bool)\n\nGet the positions of the cells for the PCF calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.isCrossPCF-Tuple{Vector{String}, Vector{String}}","page":"Analysis","title":"pcvct.isCrossPCF","text":"isCrossPCF(center_cell_types::Vector{String}, target_cell_types::Vector{String})\n\nCheck if the center and target cell types are the same (PCF) or disjoint (cross-PCF); if neither, throw an error.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.pcfConstants-Tuple{PhysiCellSnapshot, Float64}","page":"Analysis","title":"pcvct.pcfConstants","text":"pcfConstants(S::AbstractPhysiCellSequence, dr::Float64)\n\nCreate a Constants object for the PCF calculation based on the mesh of the snapshot or sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.pcfSnapshotCalculation-Tuple{PhysiCellSnapshot, Vector{String}, Vector{String}, Dict{String, Int64}, Union{Bool, Tuple{Bool, Bool}}, Bool, PairCorrelationFunction.Constants}","page":"Analysis","title":"pcvct.pcfSnapshotCalculation","text":"pcfSnapshotCalculation(snapshot::PhysiCellSnapshot, center_cell_types::Vector{String}, target_cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Union{Bool,Tuple{Bool,Bool}}, is_cross_pcf::Bool, constants::Constants)\n\nCalculate the pair correlation function (PCF) for a given snapshot.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.preparePCF!-Tuple{pcvct.AbstractPhysiCellSequence, Any, Any, Union{Bool, Tuple{Bool, Bool}}, Float64}","page":"Analysis","title":"pcvct.preparePCF!","text":"preparePCF!(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types, include_dead::Union{Bool,Tuple{Bool,Bool}}, dr::Float64)\n\nPrepare the arguments for the PCF calculation.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.preparePCFPlot-Tuple{Vector{pcvct.PCVCTPCFResult}}","page":"Analysis","title":"pcvct.preparePCFPlot","text":"preparePCFPlot(results::Vector{PCVCTPCFResult}; time_unit=:min, distance_unit=:um)\n\nPrepare the time and radii for the PCF plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.processDistance-Tuple{Any, Any}","page":"Analysis","title":"pcvct.processDistance","text":"processDistance(distance::Vector{Float64}, distance_unit::Symbol)\n\nProcess the distance vector to convert it to the desired distance unit. Options are :um, :mm, and :cm.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.processPCFCellTypes-Tuple{Any}","page":"Analysis","title":"pcvct.processPCFCellTypes","text":"processPCFCellTypes(cell_types)\n\nProcess the cell types for the PCF calculation so that they are always a vector of strings.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.processTime-Tuple{Any, Any}","page":"Analysis","title":"pcvct.processTime","text":"processTime(time::Vector{Float64}, time_unit::Symbol)\n\nProcess the time vector to convert it to the desired time unit. Options are :min, :s, :h, :d, :w, :mo, and :y.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.AbstractPopulationTimeSeries","page":"Analysis","title":"pcvct.AbstractPopulationTimeSeries","text":"AbstractPopulationTimeSeries\n\nAbstract type representing a population time series for either a simulation or a monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.MonadPopulationTimeSeries","page":"Analysis","title":"pcvct.MonadPopulationTimeSeries","text":"MonadPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a monad's population time series.\n\nNote: unlike SimulationPopulationTimeSeries, this type does not save the data to a file.\n\nExamples\n\nmpts = MonadPopulationTimeSeries(1)\nmpts = MonadPopulationTimeSeries(monad(1))\n\nFields\n\nmonad_id::Int: The ID of the monad.\nmonad_length::Int: The number of simulations in the monad.\ntime::Vector{Real}: The time points of the population time series.\ncell_count::Dict{String, NamedTuple}: A dictionary where keys are cell type names and values are NamedTuples with fields :counts, :mean, and :std.\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.SimulationPopulationTimeSeries","page":"Analysis","title":"pcvct.SimulationPopulationTimeSeries","text":"SimulationPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a simulation's population time series.\n\nIf constructed using a Simulation or an Integer (representing a simulation ID), it will save the time series inside the simulations/simulation_id/summary/ folder. It will also look for previously computed time series there to avoid recomputing them.\n\nExamples\n\nspts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has \"_include_dead\" appended\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\ntime::Vector{Real}: The time points of the population time series.\ncell_count::Dict{String, Vector{Integer}}: A dictionary where keys are cell type names and values are vectors of cell counts over time.\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.finalPopulationCount","page":"Analysis","title":"pcvct.finalPopulationCount","text":"finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])\n\nReturn the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.\n\nAlso works with the simulation ID:\n\nfpc = finalPopulationCount(1)\n\nExample\n\nfpc = finalPopulationCount(simulation)\nfinal_default_count = fpc[\"default\"]\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.formatTimeRange-Tuple{Any}","page":"Analysis","title":"pcvct.formatTimeRange","text":"formatTimeRange(v::Vector{Real})\n\nFormat a vector of time points into a string representation.\n\nUsed only for printing certain classes to the console.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.getMeanCounts-Tuple{pcvct.SimulationPopulationTimeSeries}","page":"Analysis","title":"pcvct.getMeanCounts","text":"getMeanCounts(apts::AbstractPopulationTimeSeries)\n\nReturn the mean counts of a population time series.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.plotbycelltype","page":"Analysis","title":"pcvct.plotbycelltype","text":"plotbycelltype(T::AbstractTrial; include_dead::Bool=false, include_cell_types=:all, exclude_cell_types=String[])\n\nPlot the population time series of a trial by cell type.\n\nEach cell type gets its own subplot. Each monad gets its own series within each subplot.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.populationCount","page":"Analysis","title":"pcvct.populationCount","text":"populationCount(snapshot, cell_type_to_name_dict::Dict{Int,String}=Dict{Int,String}(), labels::Vector{String}=String[]; include_dead::Bool=false)\n\nReturn the population count of a snapshot as a dictionary with cell type names as keys and their counts as values.\n\nIf the snapshot is missing, it will return missing. This helps in cases where the files have been deleted, for example by pruning.\n\nArguments\n\nsnapshot::PhysiCellSnapshot: The snapshot to count the cells in.\ncell_type_to_name_dict::Dict{Int,String}: A dictionary mapping cell type IDs to names (default is an empty dictionary). If not provided, it is read from the snapshot files.\nlabels::Vector{String}: The labels to identify the cell data. If not provided, it is read from the snapshot files.\n\nKeyword Arguments\n\ninclude_dead::Bool: Whether to include dead cells in the count. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}","page":"Analysis","title":"pcvct.populationTimeSeries","text":"populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])\n\nReturn the population time series of a simulation or a monad.\n\nSee SimulationPopulationTimeSeries and MonadPopulationTimeSeries for more details.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.processExcludeCellTypes-Tuple{Any}","page":"Analysis","title":"pcvct.processExcludeCellTypes","text":"processExcludeCellTypes(exclude_cell_types)\n\nProcess the exclude_cell_types argument to ensure it is in the correct format.\n\nIf exclude_cell_types is a string, it is converted to a single-element vector. If it is a vector, it is returned as is.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.processIncludeCellTypes-Tuple{Any, Vector{String}}","page":"Analysis","title":"pcvct.processIncludeCellTypes","text":"processIncludeCellTypes(include_cell_types, all_cell_types::Vector{String})\n\nProcess the include_cell_types argument to ensure it is in the correct format.\n\nUses the all_cell_types vector to determine the valid cell types.\n\nArguments\n\ninclude_cell_types: the cell types to include in the analysis (default is :all_in_one). Full list of options:\n:all - return the vector of all cell types\n:all_in_one - return a vector with a single element, which is a vector of all cell types\n\"cell_type_1\" - return [\"celltype1\"]\n[\"cell_type_1\", \"cell_type_2\"] - return [\"celltype1\", \"celltype2\"]\n[[\"cell_type_1\", \"cell_type_2\"]] - return [[\"celltype1\", \"celltype2\"]]\n[[\"cell_type_1\", \"cell_type_2\"], \"cell_type_3\"] - return [[\"celltype1\", \"celltype2\"], \"celltype3\"]\nall_cell_types: a vector of all cell types in the simulation\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.AverageSubstrateTimeSeries","page":"Analysis","title":"pcvct.AverageSubstrateTimeSeries","text":"AverageSubstrateTimeSeries\n\nA struct to hold the average substrate concentrations over time for a PhysiCell simulation.\n\nConstructed using AverageSubstrateTimeSeries(x) where x is any of the following: Integer (simulation ID), PhysiCellSequence, or Simulation.\n\nFields\n\nsimulation_id::Int: The ID of the PhysiCell simulation.\ntime::Vector{Real}: The time points at which the snapshots were taken.\nsubstrate_concentrations::Dict{String, Vector{Real}}: A dictionary mapping substrate names to vectors of their average concentrations over time.\n\nExample\n\n```julia asts = pcvct.AverageSubstrateTimeSeries(1) # Load average substrate time series for Simulation 1 asts.time # Get the time points asts[\"time\"] # alternative way to get the time points asts[\"oxygen\"] # Get the oxygen concentration over time\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.ExtracellularSubstrateTimeSeries","page":"Analysis","title":"pcvct.ExtracellularSubstrateTimeSeries","text":"ExtracellularSubstrateTimeSeries\n\nA struct to hold the mean extracellular substrate concentrations per cell type over time for a PhysiCell simulation.\n\nFields\n\nsimulation_id::Int: The ID of the PhysiCell simulation.\ntime::Vector{Real}: The time points at which the snapshots were taken.\ndata::Dict{String, Dict{String, Vector{Real}}}: A dictionary mapping cell type names to dictionaries mapping substrate names to vectors of their average concentrations over time.\n\nExample\n\nests = pcvct.ExtracellularSubstrateTimeSeries(1) # Load extracellular substrate time series for Simulation 1\nests.time # Get the time points\nests[\"cancer\"][\"oxygen\"] # Get the oxygen concentration over time for the cancer cell type\n\nests = pcvct.ExtracellularSubstrateTimeSeries(simulation; include_dead=true) # Load extracellular substrate time series for a Simulation object, including dead cells\nests[\"time\"] # Alternate way to get the time points\nests[\"cd8\"][\"IFNg\"] # Get the interferon gamma concentration over time for the CD8 cell type\n\nests = pcvct.ExtracellularSubstrateTimeSeries(sequence) # Load extracellular substrate time series for a PhysiCellSequence object\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.VoxelWeights","page":"Analysis","title":"pcvct.VoxelWeights","text":"VoxelWeights\n\nA struct to hold the voxel weights for a PhysiCell simulation.\n\nFields\n\nuse_weights::Bool: Whether to use weights for the voxel volumes. If all voxel volumes are the same, this is set to false.\nweights::Vector{Real}: The weights for the voxel volumes.\nweight_total::Real: The total weight of the voxel volumes.\n\n\n\n\n\n","category":"type"},{"location":"lib/analysis/#pcvct.averageExtracellularSubstrate","page":"Analysis","title":"pcvct.averageExtracellularSubstrate","text":"averageExtracellularSubstrate(snapshot::PhysiCellSnapshot, cell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(), substrate_names::Vector{String}=String[], labels::Vector{String}=String[]; include_dead::Bool=false)\n\nCompute the average extracellular substrate concentrations for each cell type in a PhysiCell snapshot.\n\nArguments\n\nsnapshot::PhysiCellSnapshot: The snapshot to analyze.\ncell_type_to_name_dict::Dict{Int, String}: A dictionary mapping cell type IDs to their names. If not provided, it is read from the snapshot files.\nsubstrate_names::Vector{String}: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.\nlabels::Vector{String}: The labels to use for the cells. If not provided, it is read from the snapshot files.\n\nKeyword Arguments\n\ninclude_dead::Bool: Whether to include dead cells in the analysis (default is false).\n\nReturns\n\nDict{String, Dict{String, Real}}: A dictionary mapping cell type names to dictionaries mapping substrate names to their average concentrations.\n\nThat is, if aes is the output of this function, then aes[\"cell_type_name\"][\"substrate_name\"] is the average concentration of substrate_name for cells of type cell_type_name in the snapshot.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.averageSubstrate","page":"Analysis","title":"pcvct.averageSubstrate","text":"averageSubstrate(snapshot::PhysiCellSnapshot, substrate_names::Vector{String}=String[], voxel_weights::VoxelWeights=VoxelWeights(snapshot))\n\nCompute the average substrate concentrations for every substrate in a PhysiCell snapshot.\n\nThe voxel volumes are used as weights if they are not all the same.\n\nArguments\n\nsnapshot::PhysiCellSnapshot: The snapshot to analyze.\nsubstrate_names::Vector{String}: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.\nvoxel_weights::VoxelWeights: The voxel weights to use. If not provided, it is computed from the snapshot.\n\nReturns\n\ndata::Dict{String, Real}: A dictionary mapping substrate names to their average concentrations.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#pcvct.computeVoxelIndices-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}","page":"Analysis","title":"pcvct.computeVoxelIndices","text":"computeVoxelIndices(cells::DataFrame, mesh::Dict{String, Vector{Float64}})\n\nCompute the voxel (linear) indices (1-nxnynz) for a set of cells in a PhysiCell simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#pcvct.computeVoxelSubscripts-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}","page":"Analysis","title":"pcvct.computeVoxelSubscripts","text":"computeVoxelSubscripts(cells::DataFrame, mesh::Dict{String, Vector{Float64}})\n\nCompute the voxel subscripts (1-nx, 1-ny, 1-nz) for a set of cells in a PhysiCell simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#Loader","page":"Loader","title":"Loader","text":"","category":"section"},{"location":"lib/loader/","page":"Loader","title":"Loader","text":"Load PhysiCell data into useful forms for downstream analysis. This may be split off into its own module or even package eventually, likely with analysis.jl.","category":"page"},{"location":"lib/loader/#pcvct.AbstractPhysiCellSequence","page":"Loader","title":"pcvct.AbstractPhysiCellSequence","text":"AbstractPhysiCellSequence\n\nAbstract type representing either a single snapshot or a sequence of snapshots from a PhysiCell simulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/loader/#pcvct.AgentID","page":"Loader","title":"pcvct.AgentID","text":"AgentID\n\nA wrapper for the agent ID used in PhysiCell.\n\nThe purpose of this struct is to make it easier to interpret the data in the MetaGraphs loaded from PhysiCell. The MetaGraphs use Ints to index the vertices, which could cause confusion when looking at the mappings to the agent ID metadata if also using Ints.\n\n\n\n\n\n","category":"type"},{"location":"lib/loader/#pcvct.PhysiCellSequence","page":"Loader","title":"pcvct.PhysiCellSequence","text":"PhysiCellSequence\n\nA sequence of PhysiCell snapshots.\n\nBy default, only the simulation ID, index, and time are recorded for each PhysiCellSnapshot in the sequence. To include any of cells, substrates, mesh, attachments, spring_attachments, or neighbors, pass in the corresponding keyword argument as true (see below).\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\nsnapshots::Vector{PhysiCellSnapshot}: A vector of PhysiCell snapshots.\ncell_type_to_name_dict::Dict{Int, String}: A dictionary mapping cell type IDs to cell type names.\nlabels::Vector{String}: A vector of cell data labels.\nsubstrate_names::Vector{String}: A vector of substrate names.\n\nExamples\n\nsequence = PhysiCellSequence(1; include_cells=true, include_substrates=true) # loads cell and substrate data for simulation ID 1\nsequence = PhysiCellSequence(simulation; include_attachments=true, include_spring_attachments=true) # loads attachment data for a Simulation object\nsequence = PhysiCellSequence(1; include_mesh=true, include_neighbors=true) # loads mesh and neighbor data for simulation ID 1\n\n\n\n\n\n","category":"type"},{"location":"lib/loader/#pcvct.PhysiCellSnapshot","page":"Loader","title":"pcvct.PhysiCellSnapshot","text":"PhysiCellSnapshot(simulation_id::Int, index::Union{Integer, Symbol}, labels::Vector{String}=String[], substrate_names::Vector{String}=String[]; kwargs...)\n\nCreates a snapshot of the PhysiCell simulation with optional parameters to include various data types.\n\nArguments\n\nsimulation_id::Int: The ID of the simulation. Can also be a Simulation object.\nindex::Union{Integer, Symbol}: The index of the snapshot. Can be an integer or a symbol (:initial or :final).\nlabels::Vector{String}=String[]: A vector of cell data labels.\nsubstrate_names::Vector{String}=String[]: A vector of substrate names.\n\nKeyword Arguments\n\ninclude_cells::Bool=false: Whether to load cell data.\ncell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(): A dictionary mapping cell type IDs to cell type names.\ninclude_substrates::Bool=false: Whether to load substrate data.\ninclude_mesh::Bool=false: Whether to load mesh data.\ninclude_attachments::Bool=false: Whether to load attachment data.\ninclude_spring_attachments::Bool=false: Whether to load spring attachment data.\ninclude_neighbors::Bool=false: Whether to load neighbor data.\n\n\n\n\n\n","category":"type"},{"location":"lib/loader/#pcvct.PhysiCellSnapshot-2","page":"Loader","title":"pcvct.PhysiCellSnapshot","text":"PhysiCellSnapshot\n\nA single snapshot of a PhysiCell simulation.\n\nThe cells, substrates, and mesh fields may remain empty until they are needed for analysis.\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\nindex::Union{Int,Symbol}: The index of the snapshot. Can be an integer or a symbol (:initial or :final).\ntime::Float64: The time of the snapshot (in minutes).\ncells::DataFrame: A DataFrame containing cell data.\nsubstrates::DataFrame: A DataFrame containing substrate data.\nmesh::Dict{String, Vector{Float64}}: A dictionary containing mesh data.\nattachments::MetaGraph: A graph of cell attachment data with vertices labeled by cell IDs.\nspring_attachments::MetaGraph: A graph of spring attachment data with vertices labeled by cell IDs.\nneighbors::MetaGraph: A graph of cell neighbor data with vertices labeled by cell IDs.\n\nExamples\n\nsimulation_id = 1\nindex = 3 # index of the snapshot in the output folder\nsnapshot = PhysiCellSnapshot(simulation_id, index)\n\nsimulation = Simulation(simulation_id)\nindex = :initial # :initial or :final are the accepted symbols\nsnapshot = PhysiCellSnapshot(simulation, index)\n\n\n\n\n\n","category":"type"},{"location":"lib/loader/#pcvct.getCellDataSequence-Tuple{Integer, Vector{String}}","page":"Loader","title":"pcvct.getCellDataSequence","text":"getCellDataSequence(simulation_id::Integer, labels::Vector{String}; include_dead::Bool=false, include_cell_type::Bool=false)\n\nReturn a dictionary where the keys are cell IDs from the PhysiCell simulation and the values are NamedTuples containing the time and the values of the specified labels for that cell.\n\nFor scalar values, such as volume, the values are in a length N vector, where N is the number of snapshots in the simulation. In the case of a label that has multiple columns, such as position, the values are concatenated into a length(snapshots) x number of columns array. Note: If doing multiple calls to this function, it is recommended to use the PhysiCellSequence object so that all the data is loaded one time instead of once per call.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation. Alternatively, can be a Simulation object or a PhysiCellSequence object.\nlabels::Vector{String}: The labels to extract from the cell data. If a label has multiple columns, such as position, the columns are concatenated into a single array. Alternatively, a single label string can be passed.\ninclude_dead::Bool=false: Whether to include dead cells in the data.\ninclude_cell_type::Bool=false: Whether to include the cell type name in the data. Equivalent to including \"cell_type_name\" in labels.\n\nExamples\n\ndata = getCellDataSequence(sequence, [\"position\", \"elapsed_time_in_phase\"]; include_dead=true, include_cell_type=true)\ndata[1] # the first cell's data\ndata[1].position # an Nx3 array of the cell's position over time\ndata[1].elapsed_time_in_phase # an Nx1 array of the cell's elapsed time in phase over time\ndata[1].cell_type_name # an Nx1 array of the cell type name of the first cell over time\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.getCellTypeToNameDict-Tuple{String}","page":"Loader","title":"pcvct.getCellTypeToNameDict","text":"getCellTypeToNameDict(simulation::Simulation)\n\nReturn a dictionary mapping cell type IDs to cell type names from the simulation.\n\nArguments\n\nsimulation: The simulation object. Can also use the simulation ID, an AbstractPhysiCellSequence, XMLDocument, or the path to the XML file (String).\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.getLabels-Tuple{String}","page":"Loader","title":"pcvct.getLabels","text":"getLabels(simulation::Simulation)\n\nReturn the labels from the XML file for a PhysiCell simulation, i.e., the names of the cell data fields.\n\nArguments\n\nsimulation: The simulation object. Can also use the simulation ID, an AbstractPhysiCellSequence, XMLDocument, or the path to the XML file (String).\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.getSubstrateNames-Tuple{String}","page":"Loader","title":"pcvct.getSubstrateNames","text":"getSubstrateNames(simulation::Simulation)\n\nReturn the names of the substrates from the simulation.\n\nArguments\n\nsimulation: The simulation object. Can also use the simulation ID, an AbstractPhysiCellSequence, XMLDocument, or the path to the XML file (String).\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.graphInfo-Tuple{MetaGraphsNext.MetaGraph}","page":"Loader","title":"pcvct.graphInfo","text":"graphInfo(g::MetaGraph)\n\nReturn a string describing the graph.\n\nUsed for printing the graph information in the show function.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.indexToFilename-Tuple{Symbol}","page":"Loader","title":"pcvct.indexToFilename","text":"indexToFilename(index)\n\nConvert an index to a filename in the output folder.\n\nThe index can be an integer or a symbol (:initial or :final).\n\njulia> pcvct.indexToFilename(0)\n\"output00000000\"\n\njulia> pcvct.indexToFilename(:initial)\n\"initial\"\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.loadCells!","page":"Loader","title":"pcvct.loadCells!","text":"loadCells!(cells::DataFrame, filepath_base::String, cell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(), labels::Vector{String}=String[])\n\nInternal function to load cell data into a DataFrame associated with an AbstractPhysiCellSequence object.\n\n\n\n\n\n","category":"function"},{"location":"lib/loader/#pcvct.loadCells!-2","page":"Loader","title":"pcvct.loadCells!","text":"loadCells!(S::AbstractPhysiCellSequence[, cell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(), labels::Vector{String}=String[]])\n\nLoad the cell data for a PhysiCell simulation into an AbstractPhysiCellSequence object.\n\nIf the cell_type_to_name_dict and labels are not provided, they will be loaded from the XML file. Users do not need to compute and pass these in.\n\nArguments\n\nS::AbstractPhysiCellSequence: The sequence or snapshot to load the cell data into.\ncell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(): A dictionary mapping cell type IDs to cell type names. If not provided, it will be loaded from the XML file.\nlabels::Vector{String}=String[]: A vector of cell data labels. If not provided, they will be loaded from the XML file.\n\nExamples\n\nsimulation = Simulation(1)\nsequence = PhysiCellSequence(simulation) # does not load cell data without setting `PhysiCellSequence(simulation; include_cells=true)`\nloadCells!(sequence)\n\n\n\n\n\n","category":"function"},{"location":"lib/loader/#pcvct.loadGraph!-Tuple{MetaGraphsNext.MetaGraph, String}","page":"Loader","title":"pcvct.loadGraph!","text":"loadGraph!(G::MetaGraph, path_to_txt_file::String)\n\nLoad a graph from a text file into a MetaGraph.\n\nUsers should use loadGraph! with an AbstractPhysiCellSequence object instead of this function directly.`\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.loadGraph!-Tuple{PhysiCellSnapshot, Symbol}","page":"Loader","title":"pcvct.loadGraph!","text":"loadGraph!(S::AbstractPhysiCellSequence, graph::Symbol)\n\nLoad a graph for a snapshot or sequence into a MetaGraph(s).\n\nArguments\n\nS::AbstractPhysiCellSequence: The AbstractPhysiCellSequence object to load the graph into.\ngraph: The type of graph to load (must be one of :attachments, :spring_attachments, or :neighbors). Can also be a string.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.loadMesh!-Tuple{Dict{String, Vector{Float64}}, LightXML.XMLDocument}","page":"Loader","title":"pcvct.loadMesh!","text":"loadMesh!(mesh::Dict{String, Vector{Float64}}, xml_doc::XMLDocument)\n\nInternal function to load mesh data into a dictionary associated with an AbstractPhysiCellSequence object.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.loadMesh!-Tuple{PhysiCellSnapshot}","page":"Loader","title":"pcvct.loadMesh!","text":"loadMesh!(S::AbstractPhysiCellSequence)\n\nLoad the mesh data for a PhysiCell simulation into an AbstractPhysiCellSequence object.\n\nArguments\n\nS::AbstractPhysiCellSequence: The sequence or snapshot to load the mesh data into.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.loadSubstrates!","page":"Loader","title":"pcvct.loadSubstrates!","text":"loadSubstrates!(S::AbstractPhysiCellSequence[, substrate_names::Vector{String}=String[]])\n\nLoad the substrate data for a PhysiCell simulation into an AbstractPhysiCellSequence object.\n\nIf the substrate_names are not provided, they will be loaded from the XML file. Users do not need to compute and pass these in.\n\nArguments\n\nS::AbstractPhysiCellSequence: The sequence or snapshot to load the substrate data into.\nsubstrate_names::Vector{String}=String[]: The names of the substrates to load. If not provided, they will be loaded from the XML file.\n\n\n\n\n\n","category":"function"},{"location":"lib/loader/#pcvct.loadSubstrates!-Tuple{DataFrames.DataFrame, String, Vector{String}}","page":"Loader","title":"pcvct.loadSubstrates!","text":"loadSubstrates!(substrates::DataFrame, filepath_base::String, substrate_names::Vector{String}=String[])\n\nInternal function to load substrate data into a DataFrame associated with an AbstractPhysiCellSequence object.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.meshInfo-Tuple{PhysiCellSnapshot}","page":"Loader","title":"pcvct.meshInfo","text":"meshInfo(S::AbstractPhysiCellSequence)\n\nReturn a string describing the mesh for an AbstractPhysiCellSequence object.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.pathToOutputFileBase-Tuple{Integer, Union{Integer, Symbol}}","page":"Loader","title":"pcvct.pathToOutputFileBase","text":"pathToOutputFileBase(simulation_id::Integer, index::Union{Integer,Symbol})\n\nReturn the path to the output files for a snapshot of a PhysiCell simulation, i.e., everything but the file extension.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.pathToOutputFileBase-Tuple{PhysiCellSnapshot}","page":"Loader","title":"pcvct.pathToOutputFileBase","text":"pathToOutputFileBase(snapshot::PhysiCellSnapshot)\n\nReturn the path to the output files for a snapshot of a PhysiCell simulation, i.e., everything but the file extension.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.pathToOutputFolder-Tuple{Integer}","page":"Loader","title":"pcvct.pathToOutputFolder","text":"pathToOutputFolder(simulation_id::Integer)\n\nReturn the path to the output folder for a PhysiCell simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.pathToOutputXML","page":"Loader","title":"pcvct.pathToOutputXML","text":"pathToOutputXML(simulation_id::Integer, index::Union{Integer,Symbol}=:initial)\n\nReturn the path to the XML output file for a snapshot of a PhysiCell simulation. Can also pass in a Simulation object for the first argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/loader/#pcvct.pathToOutputXML-Tuple{PhysiCellSnapshot}","page":"Loader","title":"pcvct.pathToOutputXML","text":"pathToOutputXML(snapshot::PhysiCellSnapshot)\n\nReturn the path to the XML output file for a snapshot of a PhysiCell simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.physicellEmptyGraph-Tuple{}","page":"Loader","title":"pcvct.physicellEmptyGraph","text":"physicellEmptyGraph()\n\nCreate an empty graph for use with PhysiCell.\n\nFor all PhysiCell graphs, the vertices are labeled with AgentIDs and the vertices carry no other information. The edges also carry no extra information other than that the edge exists.\n\n\n\n\n\n","category":"method"},{"location":"lib/loader/#pcvct.readPhysiCellGraph!-Tuple{MetaGraphsNext.MetaGraph, String}","page":"Loader","title":"pcvct.readPhysiCellGraph!","text":"readPhysiCellGraph!(g::MetaGraph, path_to_txt_file::String)\n\nRead a PhysiCell graph from a text file into a MetaGraph.\n\nUsers should use loadGraph! instead of this function directly.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#Deletion","page":"Deletion","title":"Deletion","text":"","category":"section"},{"location":"lib/deletion/","page":"Deletion","title":"Deletion","text":"Safely delete output from a pcvct project.","category":"page"},{"location":"lib/deletion/#pcvct.deleteAllSimulations-Tuple{}","page":"Deletion","title":"pcvct.deleteAllSimulations","text":"deleteAllSimulations(; delete_supers::Bool=true, and_constraints::String=\"\")\n\nDelete all simulations. See deleteSimulations for the meaning of the keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.deleteMonad-Tuple{AbstractVector{<:Integer}}","page":"Deletion","title":"pcvct.deleteMonad","text":"deleteMonad(monad_ids::AbstractVector{<:Integer}; delete_subs::Bool=true, delete_supers::Bool=true)\n\nDelete monads from the database by monad ID.\n\nArguments\n\nmonad_ids: list of monad IDs to delete. Can also pass an Integer.\ndelete_subs: If delete_subs is true, will further delete the simulations corresponding to the monad.\ndelete_supers: If delete_supers is true, will further delete any samplings that no longer have associated monads after the deletion.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.deleteSampling-Tuple{AbstractVector{<:Integer}}","page":"Deletion","title":"pcvct.deleteSampling","text":"deleteSampling(sampling_ids::AbstractVector{<:Integer}; delete_subs::Bool=true, delete_supers::Bool=true)\n\nDelete samplings from the database by sampling ID.\n\nArguments\n\nsampling_ids: list of sampling IDs to delete. Can also pass an Integer.\ndelete_subs: If delete_subs is true, will further delete the monads corresponding to the sampling.\ndelete_supers: If delete_supers is true, will further delete any trials that no longer have associated samplings after the deletion.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.deleteSimulation","page":"Deletion","title":"pcvct.deleteSimulation","text":"deleteSimulation(args...; kwargs...)\n\nAlias for deleteSimulations.\n\n\n\n\n\n","category":"function"},{"location":"lib/deletion/#pcvct.deleteSimulations-Tuple{AbstractVector{<:Union{Missing, Integer}}}","page":"Deletion","title":"pcvct.deleteSimulations","text":"deleteSimulations(simulation_ids::AbstractVector{<:Union{Integer,Missing}}; delete_supers::Bool=true, and_constraints::String=\"\")\n\nDeletes the simulations with the input IDs from the database and from the data/outputs/simulations folder.\n\nWorks with a vector of simulation IDs, a single simulation ID, a vector of Simulations or a single Simulation. If delete_supers is true, it will also delete any monads, samplings, and trials that no longer have any simulations associated with them. It is recommended to leave this to true to keep the database clean. The and_constraints argument allows for additional SQLite conditions to be added to the WHERE clause of the SQLite query. Use this only after inspecting the simulations table in the data/vct.db database.     Note: deleteSimulation is an alias for deleteSimulations.\n\nExamples\n\ndeleteSimulations(1:3)\ndeleteSimulations(4)\ndeleteSimulations(1:100; and_constraints=\"AND config_id = 1\") # delete simulations with IDs 1 to 100 that have config_id = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.deleteSimulationsByStatus","page":"Deletion","title":"pcvct.deleteSimulationsByStatus","text":"deleteSimulationsByStatus(status_codes_to_delete::Vector{String}=[\"Failed\"]; user_check::Bool=true)\n\nDelete simulations from the database based on their status codes.\n\nThe list of possible status codes is: \"Not Started\", \"Queued\", \"Running\", \"Completed\", \"Failed\".\n\nArguments\n\nstatus_codes_to_delete::Vector{String}: A vector of status codes for which simulations should be deleted. Default is [\"Failed\"].\nuser_check::Bool: If true, prompts the user for confirmation before deleting simulations. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/deletion/#pcvct.deleteTrial-Tuple{AbstractVector{<:Integer}}","page":"Deletion","title":"pcvct.deleteTrial","text":"deleteTrial(trial_ids::AbstractVector{<:Integer}; delete_subs::Bool=true)\n\nDelete trials from the database by trial ID.\n\nArguments\n\ntrial_ids: list of trial IDs to delete. Can also pass an Integer.\ndelete_subs: If delete_subs is true, will further delete the samplings corresponding to the trials.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.eraseSimulationIDFromConstituents-Tuple{Int64}","page":"Deletion","title":"pcvct.eraseSimulationIDFromConstituents","text":"eraseSimulationIDFromConstituents(simulation_id::Int[; monad_id::Union{Missing,Int}=missing])\n\nErase a simulation ID from the simulations.csv file of the monad it belongs to.\n\nIf monad_id is not provided, the function will infer it from the simulation ID. If the monad contains only the given simulation ID, the monad will be deleted. This is used when running simulations if they error so that the monads no longer rely on them, but the simulation output can still be checked.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.resetDatabase-Tuple{}","page":"Deletion","title":"pcvct.resetDatabase","text":"resetDatabase()\n\nReset the database (after user confirmation) by deleting all simulations, monads, samplings, and trials.\n\nAll the base inputs files will be kept, so previously run scripts should still work as expected. If the user aborts the reset, the user will then be asked if they want to continue with the script.\n\nKeyword Arguments\n\nforce_reset::Bool: If true, skips the user confirmation prompt. Default is false.\nforce_continue::Bool: If true, skips the user confirmation prompt for continuing with the script after aborting the reset. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.resetFolder-Tuple{Symbol, String}","page":"Deletion","title":"pcvct.resetFolder","text":"resetFolder(location::Symbol, folder::String)\n\nReset a specific folder in the database for a given location, removing the variations database and variations folder.\n\nArguments\n\nlocation: The location of the folder to reset.\nfolder: The name of the folder to reset.\n\n\n\n\n\n","category":"method"},{"location":"lib/deletion/#pcvct.rm_hpc_safe-Tuple{String}","page":"Deletion","title":"pcvct.rm_hpc_safe","text":"rm_hpc_safe(path::String; force::Bool=false, recursive::Bool=false)\n\nRemove files and take care if on an HPC since the NFS filesystem can leave behind extra files.\n\nIf on an HPC, move deleted files into the hidden directory data/.trash/ in a time-stamped folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/up/#PCVCT-Upgrade","page":"PCVCT Upgrade","title":"PCVCT Upgrade","text":"","category":"section"},{"location":"lib/up/","page":"PCVCT Upgrade","title":"PCVCT Upgrade","text":"Functionality for upgrading the database to match the current version of pcvct.","category":"page"},{"location":"lib/up/#pcvct.populateTableOnFeatureSubset-Tuple{SQLite.DB, String, String}","page":"PCVCT Upgrade","title":"pcvct.populateTableOnFeatureSubset","text":"populateTableOnFeatureSubset(db::SQLite.DB, source_table::String, target_table::String; column_mapping::Dict{String, String}=Dict{String,String}())\n\nPopulate a target table with data from a source table, using a column mapping if provided.\n\n\n\n\n\n","category":"method"},{"location":"lib/up/#pcvct.upgradePCVCT-Tuple{VersionNumber, VersionNumber, Bool}","page":"PCVCT Upgrade","title":"pcvct.upgradePCVCT","text":"upgradePCVCT(from_version::VersionNumber, to_version::VersionNumber, auto_upgrade::Bool)\n\nUpgrade the PCVCT database from one version to another.\n\nThe upgrade process is done in steps, where each step corresponds to a milestone version. The function will apply all necessary upgrades until the target version is reached. If auto_upgrade is true, the function will automatically apply all upgrades without prompting. Otherwise, it will prompt the user for confirmation before large upgrades.\n\n\n\n\n\n","category":"method"},{"location":"lib/up/#pcvct.upgradeToVX_Y_Z","page":"PCVCT Upgrade","title":"pcvct.upgradeToVX_Y_Z","text":"upgradeToX_Y_Z(auto_upgrade::Bool)\n\nUpgrade the database to pcvct version X.Y.Z. Each milestone version has its own upgrade function.\n\n\n\n\n\n","category":"function"},{"location":"man/known_limitations/#Known-limitations","page":"Known limitations","title":"Known limitations","text":"","category":"section"},{"location":"man/known_limitations/#Always-select-all-simulations-associated-with-a-Monad","page":"Known limitations","title":"Always select all simulations associated with a Monad","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"Anytime a group of simulation replicates (a Monad in pcvct internals) is requested, all simulations in that group are used, regardless of the value of n_replicates. If the number of simulations in the group is less than n_replicates, then additional simulations are run to reach n_replicates. Note: if use_previous=false, then n_replicates will be run regardless and the returned Monad will only have the newly-run simulations. If you do need an upper bound on the number of simulations in such a grouping, submit an issue. It is assumed that most, if not all use cases, will benefit from more simulations.","category":"page"},{"location":"man/known_limitations/#Initial-conditions-not-loaded-when-launching-PhysiCell-Studio-for-a-simulation.","page":"Known limitations","title":"Initial conditions not loaded when launching PhysiCell Studio for a simulation.","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"When launching PhysiCell Studio from pcvct, the initial conditions (cells and substrates) are not loaded.","category":"page"},{"location":"man/known_limitations/#Limited-intracellular-models","page":"Known limitations","title":"Limited intracellular models","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"Currently only supports ODE intracellular models (using libRoadRunner). Does not support MaBoSS or dFBA.","category":"page"},{"location":"misc/database_upgrades/#Database-upgrades","page":"Database upgrades","title":"Database upgrades","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Over time, the database structure of pcvct will evolve to reflect new capabilities, features, and improvements. Not every release will change the database structure, but when one does in a way that could affect your workflow, pcvct will throw a warning. The warning will link to this page and the function will wait for user input to proceed. Changes are listed in reverse chronological order.","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.15","page":"Database upgrades","title":"to v0.0.15","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Introduce XML-based ECM initial conditions. This introduces ic_ecm_variations. Also, introduce Dirichlet initial conditions from file, which introduces the ic_dc_id in the database. For any simulations in the database before upgrading, both of these will be set to -1 (i.e., no initial conditions) except if  ic_ecm_id is not -1, in which case ic_ecm_variation_id will be set to 0 (i.e., the default ECM initial conditions which is all the original CSV version can handle).","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.10","page":"Database upgrades","title":"to v0.0.10","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Start tracking the PhysiCell version used in the simulation. This introduces the physicell_versions table which tracks the PhysiCell versions used in simulations. Currently, only supports reading the PhysiCell version, not setting it (e.g., through git commands). Key changes include:","category":"page"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Adding the physicell_version_id column to the simulations, monads, and samplings tables.\nAdding the physicell_versions table.\nIf PhysiCell is a git-tracked repo, this will store the commit hash as well as any tag and repo owner it can find based on the remotes. It will also store the date of the commit.\nIf PhysiCell is not a git-tracked repo, it will read the VERSION.txt file and store that as the commit_hash with -download appended to the version.","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.3","page":"Database upgrades","title":"to v0.0.3","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Introduce XML-based cell initial conditions. This introduces ic_cell_variations. Also, standardized the use of config_variation in place of variation. Key changes include:","category":"page"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Renaming the variation_id column in the simulations and monads tables to config_variation_id.\nAdding the ic_cell_variation_id column to the simulations and monads tables.\nIn data/inputs/configs, renaming all instances of \"variation\" to \"config_variation\" in filenames and databases.","category":"page"},{"location":"lib/import/#Import","page":"Import","title":"Import","text":"","category":"section"},{"location":"lib/import/","page":"Import","title":"Import","text":"Import a project from the standard PhysiCell format into the pcvct format.","category":"page"},{"location":"lib/import/#pcvct.ImportDestFolder","page":"Import","title":"pcvct.ImportDestFolder","text":"ImportDestFolder\n\nA struct to hold the information about a destination folder to be created in the pcvct structure.\n\nUsed internally in the importProject function to manage the creation of folders in the pcvct structure.\n\nFields\n\npath_from_inputs::AbstractString: The path to the destination folder relative to the inputs folder.\ncreated::Bool: Indicates if the folder was created during the import process.\ndescription::AbstractString: A description of the folder.\n\n\n\n\n\n","category":"type"},{"location":"lib/import/#pcvct.ImportDestFolders","page":"Import","title":"pcvct.ImportDestFolders","text":"ImportDestFolders\n\nA struct to hold the information about the destination folders to be created in the pcvct structure.\n\nUsed internally in the importProject function to manage the creation of folders in the pcvct structure.\n\nFields\n\nconfig::ImportDestFolder: The config folder to be created.\ncustom_code::ImportDestFolder: The custom code folder to be created.\nrules::ImportDestFolder: The rules folder to be created.\nintracellular::ImportDestFolder: The intracellular folder to be created.\nic_cell::ImportDestFolder: The intracellular cell folder to be created.\nic_substrate::ImportDestFolder: The intracellular substrate folder to be created.\nic_ecm::ImportDestFolder: The intracellular ECM folder to be created.\nic_dc::ImportDestFolder: The intracellular DC folder to be created.\n\n\n\n\n\n","category":"type"},{"location":"lib/import/#pcvct.ImportSource","page":"Import","title":"pcvct.ImportSource","text":"ImportSource\n\nA struct to hold the information about a source file or folder to be imported into the pcvct structure.\n\nUsed internally in the importProject function to manage the import of files and folders from a user project into the pcvct structure.\n\nFields\n\nsrc_key::Symbol: The key in the source dictionary.\ninput_folder_key::Symbol: The key in the destination dictionary.\npath_from_project::AbstractString: The path to the source file or folder relative to the project.\npcvct_name::AbstractString: The name of the file or folder in the pcvct structure.\ntype::AbstractString: The type of the source (e.g., file or folder).\nrequired::Bool: Indicates if the source is required for the project.\nfound::Bool: Indicates if the source was found during import.\n\n\n\n\n\n","category":"type"},{"location":"lib/import/#pcvct.ImportSources","page":"Import","title":"pcvct.ImportSources","text":"ImportSources\n\nA struct to hold the information about the sources to be imported into the pcvct structure.\n\nUsed internally in the importProject function to manage the import of files and folders from a user project into the pcvct structure.\n\nFields\n\nconfig::ImportSource: The config file to be imported.\nmain::ImportSource: The main.cpp file to be imported.\nmakefile::ImportSource: The Makefile to be imported.\ncustom_modules::ImportSource: The custom modules folder to be imported.\nrulesets_collection::ImportSource: The rulesets collection to be imported.\nintracellular::ImportSource: The intracellular components to be imported.\nic_cell::ImportSource: The cell definitions to be imported.\nic_substrate::ImportSource: The substrate definitions to be imported.\nic_ecm::ImportSource: The extracellular matrix definitions to be imported.\nic_dc::ImportSource: The DC definitions to be imported.\n\n\n\n\n\n","category":"type"},{"location":"lib/import/#pcvct.adaptConfig-Tuple{pcvct.ImportDestFolder}","page":"Import","title":"pcvct.adaptConfig","text":"adaptConfig(config::ImportDestFolder)\n\nAdapt the config file to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptCustomCPP-Tuple{AbstractString}","page":"Import","title":"pcvct.adaptCustomCPP","text":"adaptCustomCPP(path_from_inputs::AbstractString)\n\nAdapt the custom cpp file to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptCustomCode-Tuple{pcvct.ImportDestFolder}","page":"Import","title":"pcvct.adaptCustomCode","text":"adaptCustomCode(custom_code::ImportDestFolder)\n\nAdapt the custom code to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptCustomHeader-Tuple{AbstractString}","page":"Import","title":"pcvct.adaptCustomHeader","text":"adaptCustomHeader(path_from_inputs::AbstractString)\n\nAdapt the custom header to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptCustomModules-Tuple{AbstractString}","page":"Import","title":"pcvct.adaptCustomModules","text":"adaptCustomModules(path_from_inputs::AbstractString)\n\nAdapt the custom modules to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptMain-Tuple{AbstractString}","page":"Import","title":"pcvct.adaptMain","text":"adaptMain(path_from_inputs::AbstractString)\n\nAdapt the main.cpp file to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptMakefile-Tuple{AbstractString}","page":"Import","title":"pcvct.adaptMakefile","text":"adaptMakefile(path_from_inputs::AbstractString)\n\nAdapt the Makefile to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.adaptProject-Tuple{pcvct.ImportDestFolders}","page":"Import","title":"pcvct.adaptProject","text":"adaptProject(import_dest_folders::ImportDestFolders)\n\nAdapt the project to be used in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.copyFilesToFolders-Tuple{AbstractString, pcvct.ImportSources, pcvct.ImportDestFolders}","page":"Import","title":"pcvct.copyFilesToFolders","text":"copyFilesToFolders(path_to_project::AbstractString, project_sources::ImportSources, import_dest_folders::ImportDestFolders)\n\nCopy files from the project directory to the destination folders in the pcvct structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.createComponentDestFilename-Tuple{String, PhysiCellComponent}","page":"Import","title":"pcvct.createComponentDestFilename","text":"createComponentDestFilename(src_lines::Vector{String}, component::PhysiCellComponent)\n\nCreate a file name for the component file to be copied to.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.createInputFolder!-Tuple{pcvct.ImportDestFolder}","page":"Import","title":"pcvct.createInputFolder!","text":"createInputFolder!(import_dest_folder::ImportDestFolder)\n\nCreate an input folder based on the provided destination folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.createInputFolders!-Tuple{pcvct.ImportDestFolders, pcvct.ImportSources}","page":"Import","title":"pcvct.createInputFolders!","text":"createInputFolders!(import_dest_folders::ImportDestFolders, project_sources::ImportSources)\n\nCreate input folders based on the provided project sources and destination folders.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.importProject","page":"Import","title":"pcvct.importProject","text":"importProject(path_to_project::AbstractString[, src=Dict(), dest=Dict(); extreme_caution::Bool=false])\n\nImport a project from the structured in the format of PhysiCell sample projects and user projects into the pcvct structure.\n\nArguments\n\npath_to_project::AbstractString: Path to the project to import. Relative paths are resolved from the current working directory where Julia was launched.\nsrc::Dict: Dictionary of the project sources to import. If absent, tries to use the default names.\n\nThe following keys are recognized: config, main, makefile, custom_modules, rulesets_collection, intracellular, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\ndest::Dict: Dictionary of the inputs folders to create in the pcvct structure. If absent, taken from the project name.\n\nThe following keys are recognized: config, custom_code, rules, intracellular, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\nextreme_caution::Bool: If true, will ask for confirmation before deleting any folders created during the import process. Care has been taken to ensure this is unnecessary. Provided for users who want to be extra cautious.\n\n\n\n\n\n","category":"function"},{"location":"lib/import/#pcvct.prepareIntracellularImport-Tuple{Dict, pcvct.ImportSource, AbstractString}","page":"Import","title":"pcvct.prepareIntracellularImport","text":"prepareIntracellularImport(src::Dict, config::ImportSource, path_to_project::AbstractString)\n\nPrepare the intracellular import source.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.prepareRulesetsCollectionImport-Tuple{Dict, AbstractString}","page":"Import","title":"pcvct.prepareRulesetsCollectionImport","text":"prepareRulesetsCollectionImport(src::Dict, path_to_project::AbstractString)\n\nPrepare the rulesets collection import source.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.resolveProjectSource!-Tuple{pcvct.ImportSource, AbstractString}","page":"Import","title":"pcvct.resolveProjectSource!","text":"resolveProjectSource!(project_source::ImportSource, path_to_project::AbstractString)\n\nResolve the project source by checking if it exists in the project directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.resolveProjectSources!-Tuple{pcvct.ImportSources, AbstractString}","page":"Import","title":"pcvct.resolveProjectSources!","text":"resolveProjectSources!(project_sources::ImportSources, path_to_project::AbstractString)\n\nResolve the project sources by checking if they exist in the project directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/import/#pcvct.writeDescriptionToMetadata-Tuple{AbstractString, AbstractString}","page":"Import","title":"pcvct.writeDescriptionToMetadata","text":"writeDescriptionToMetadata(path_to_metadata::AbstractString, description::AbstractString)\n\nWrite the description to the metadata file.\n\n\n\n\n\n","category":"method"},{"location":"man/best_practices/#Best-practices","page":"Best practices","title":"Best practices","text":"","category":"section"},{"location":"man/best_practices/#Do-NOT-manually-edit-files-inside-inputs.","page":"Best practices","title":"Do NOT manually edit files inside inputs.","text":"","category":"section"},{"location":"man/best_practices/","page":"Best practices","title":"Best practices","text":"If parameter values need to be changed, use variations as shown in VCT/GenerateData.jl. Let pcvct manage the databases that track simulation parameters.","category":"page"},{"location":"lib/database/#Database","page":"Database","title":"Database","text":"","category":"section"},{"location":"lib/database/","page":"Database","title":"Database","text":"Create and manage the pcvct database.","category":"page"},{"location":"lib/database/#pcvct.abstractSamplingForeignReferenceSubSchema-Tuple{}","page":"Database","title":"pcvct.abstractSamplingForeignReferenceSubSchema","text":"abstractSamplingForeignReferenceSubSchema()\n\nCreate the part of the schema containing foreign key references for the simulations, monads, and samplings tables.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.addFolderNameColumns!-Tuple{DataFrames.DataFrame}","page":"Database","title":"pcvct.addFolderNameColumns!","text":"addFolderNameColumns!(df::DataFrame)\n\nAdd the folder names to the DataFrame for each location in the DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.appendVariations-Tuple{Symbol, DataFrames.DataFrame}","page":"Database","title":"pcvct.appendVariations","text":"appendVariations(location::Symbol, df::DataFrame)\n\nAdd the varied parameters associated with the location to  df.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.constructSelectQuery","page":"Database","title":"pcvct.constructSelectQuery","text":"constructSelectQuery(table_name::String, condition_stmt::String=\"\"; selection::String=\"*\")\n\nConstruct a SELECT query for the given table name, condition statement, and selection.\n\n\n\n\n\n","category":"function"},{"location":"lib/database/#pcvct.createDefaultStatusCodesTable-Tuple{}","page":"Database","title":"pcvct.createDefaultStatusCodesTable","text":"createDefaultStatusCodesTable()\n\nCreate the default status codes table in the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.createPCVCTTable-Tuple{String, String}","page":"Database","title":"pcvct.createPCVCTTable","text":"createPCVCTTable(table_name::String, schema::String; db::SQLite.DB=db)\n\nCreate a table in the database with the given name and schema. The table will be created if it does not already exist.\n\nThe table name must end in \"s\" to help normalize the ID names for these entries. The schema must have a PRIMARY KEY named as the table name without the \"s\" followed by \"_id.\"\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.createSchema-Tuple{Bool}","page":"Database","title":"pcvct.createSchema","text":"createSchema(is_new_db::Bool; auto_upgrade::Bool=false)\n\nCreate the schema for the database. This includes creating the tables and populating them with data.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.getStatusCodeID-Tuple{String}","page":"Database","title":"pcvct.getStatusCodeID","text":"getStatusCodeID(status_code::String)\n\nGet the ID of a status code from the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.initializeDatabase-Tuple{String}","page":"Database","title":"pcvct.initializeDatabase","text":"initializeDatabase(path_to_database::String; auto_upgrade::Bool=false)\n\nInitialize the database at the given path. If the database does not exist, it will be created.\n\nAlso, check the version of pcvct used to create the database and upgrade it if necessary.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.inputFolderID-Tuple{Symbol, String}","page":"Database","title":"pcvct.inputFolderID","text":"inputFolderID(location::Symbol, folder_name::String; db::SQLite.DB=db)\n\nRetrieve the ID of the folder associated with the given location and folder name.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.inputFolderName-Tuple{Symbol, Int64}","page":"Database","title":"pcvct.inputFolderName","text":"inputFolderName(location::Symbol, id::Int)\n\nRetrieve the folder name associated with the given location and ID.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.inputIDsSubSchema-Tuple{}","page":"Database","title":"pcvct.inputIDsSubSchema","text":"inputIDsSubSchema()\n\nCreate the part of the schema corresponding to the input IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.inputVariationIDsSubSchema-Tuple{}","page":"Database","title":"pcvct.inputVariationIDsSubSchema","text":"inputVariationIDsSubSchema()\n\nCreate the part of the schema corresponding to the varied inputs and their IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.insertFolder","page":"Database","title":"pcvct.insertFolder","text":"insertFolder(location::Symbol, folder::String, description::String=\"\")\n\nInsert a folder into the database. If the folder already exists, it will be ignored.\n\nIf the folder already has a description from the metadata.xml file, that description will be used instead of the one provided.\n\n\n\n\n\n","category":"function"},{"location":"lib/database/#pcvct.isStarted-Tuple{Int64}","page":"Database","title":"pcvct.isStarted","text":"isStarted(simulation_id::Int[; new_status_code::Union{Missing,String}=missing])\n\nCheck if a simulation has been started. Can also pass in a Simulation object in place of the simulation ID.\n\nIf new_status_code is provided, update the status of the simulation to this value. The check and status update are done in a transaction to ensure that the status is not changed by another process.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.metadataDescription-Tuple{AbstractString}","page":"Database","title":"pcvct.metadataDescription","text":"metadataDescription(path_to_folder::AbstractString)\n\nGet the description from the metadata.xml file in the given folder using the description element as a child element of the root element.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.monadsSchema-Tuple{}","page":"Database","title":"pcvct.monadsSchema","text":"monadsSchema()\n\nCreate the schema for the monads table. This includes the columns and their types.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.necessaryInputsPresent-Tuple{}","page":"Database","title":"pcvct.necessaryInputsPresent","text":"necessaryInputsPresent()\n\nCheck if all necessary input folders are present in the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.physicellVersionsSchema-Tuple{}","page":"Database","title":"pcvct.physicellVersionsSchema","text":"physicellVersionsSchema()\n\nCreate the schema for the physicell_versions table. This includes the columns and their types.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.printSimulationsTable-Tuple","page":"Database","title":"pcvct.printSimulationsTable","text":"printSimulationsTable()\n\nPrint a table of simulations and their varied values. See keyword arguments below for more control of the output.\n\nThere are many methods for this function. The simplest is printSimulationsTable(), which prints all simulations in the database. You can also pass in any number of simulations, monads, samplings, and trials to print a table of those simulations:\n\nprintSimulationsTable([simulation_1, monad_3, sampling_2, trial_1])\n\nFinally, a vector of simulation IDs can be passed in:\n\nprintSimulationsTable([1, 2, 3])\n\nKeyword arguments can be used with any of these methods to control the output:\n\nKeyword Arguments\n\nsink: A function to print the table. Defaults to println. Note, the table is a DataFrame, so you can also use CSV.write to write the table to a CSV file.\nremove_constants::Bool: If true, removes columns that have the same value for all simulations. Defaults to true.\nsort_by::Vector{String}: A vector of column names to sort the table by. Defaults to all columns. To populate this argument, first print the table to see the column names.\nsort_ignore::Vector{String}: A vector of column names to ignore when sorting. Defaults to the database IDs associated with the simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.queryToDataFrame-Tuple{String}","page":"Database","title":"pcvct.queryToDataFrame","text":"queryToDataFrame(query::String; db::SQLite.DB=db, is_row::Bool=false)\n\nExecute a query against the database and return the result as a DataFrame.\n\nIf is_row is true, the function will assert that the result has exactly one row, i.e., a unique result.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.recognizedStatusCodes-Tuple{}","page":"Database","title":"pcvct.recognizedStatusCodes","text":"recognizedStatusCodes()\n\nReturn the recognized status codes for simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.reinitializeDatabase-Tuple{}","page":"Database","title":"pcvct.reinitializeDatabase","text":"reinitializeDatabase()\n\nReinitialize the database by searching through the data/inputs directory to make sure all are present in the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.samplingsSchema-Tuple{}","page":"Database","title":"pcvct.samplingsSchema","text":"samplingsSchema()\n\nCreate the schema for the samplings table. This includes the columns and their types.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.simulationsTable-Tuple{Union{pcvct.AbstractTrial, AbstractArray{<:pcvct.AbstractTrial}}}","page":"Database","title":"pcvct.simulationsTable","text":"simulationsTable(T; kwargs...)\n\nReturn a DataFrame with the simulation data calling simulationsTableFromQuery with those keyword arguments.\n\nThere are three options for T:\n\nT can be any Simulation, Monad, Sampling, Trial, or any array (or vector) of such.\nT can also be a vector of simulation IDs.\nIf omitted, creates a DataFrame for all the simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.simulationsTableFromQuery-Tuple{String}","page":"Database","title":"pcvct.simulationsTableFromQuery","text":"simulationsTableFromQuery(query::String; remove_constants::Bool=true, sort_by=String[], sort_ignore=[:SimID; shortLocationVariationID.(project_locations.varied)])\n\nReturn a DataFrame containing the simulations table for the given query.\n\nBy default, will ignore the simulation ID and the variation IDs for the varied locations when sorting. The sort order can be controlled by the sort_by and sort_ignore keyword arguments.\n\nBy default, constant columns (columns with the same value for all simulations) will be removed (unless there is only one simulation). Set remove_constants to false to keep these columns.\n\nArguments\n\nquery::String: The SQL query to execute.\n\nKeyword Arguments\n\nremove_constants::Bool: If true, removes columns that have the same value for all simulations. Defaults to true.\nsort_by::Vector{String}: A vector of column names to sort the table by. Defaults to all columns. To populate this argument, it is recommended to first print the table to see the column names.\nsort_ignore::Vector{String}: A vector of column names to ignore when sorting. Defaults to the simulation ID and the variation IDs associated with the simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationIDs-Tuple{Symbol, pcvct.AbstractMonad}","page":"Database","title":"pcvct.variationIDs","text":"variationIDs(location::Symbol, S::AbstractSampling)\n\nReturn a vector of the variation IDs for the given location associated with S.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsDatabase-Tuple{Symbol, String}","page":"Database","title":"pcvct.variationsDatabase","text":"variationsDatabase(location::Symbol, folder::String)\n\nReturn the database for the location and folder.\n\nThe second argument can alternatively be the ID of the folder or an AbstractSampling object (simulation, monad, or sampling) using that folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsTable-Tuple{String, SQLite.DB}","page":"Database","title":"pcvct.variationsTable","text":"variationsTable(query::String, db::SQLite.DB; remove_constants::Bool=false)\n\nReturn a DataFrame containing the variations table for the given query and database.\n\nRemove constant columns if remove_constants is true and the DataFrame has more than one row.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsTable-Tuple{Symbol, Missing, AbstractVector{<:Integer}}","page":"Database","title":"pcvct.variationsTable","text":"variationsTable(location::Symbol, ::Missing, variation_ids::AbstractVector{<:Integer}; kwargs...)\n\nIf the location folder does not contain a variations database, return a DataFrame with all variation IDs set to 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsTable-Tuple{Symbol, Nothing, AbstractVector{<:Integer}}","page":"Database","title":"pcvct.variationsTable","text":"variationsTable(location::Symbol, ::Nothing, variation_ids::AbstractVector{<:Integer}; kwargs...)\n\nIf the location is not being used, return a DataFrame with all variation IDs set to -1.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsTable-Tuple{Symbol, SQLite.DB, AbstractVector{<:Integer}}","page":"Database","title":"pcvct.variationsTable","text":"variationsTableName(location::Symbol, variations_database::SQLite.DB, variation_ids::AbstractVector{<:Integer}; remove_constants::Bool=false)\n\nReturn a DataFrame containing the variations table for the given location, variations database, and variation IDs.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.variationsTable-Tuple{Symbol, pcvct.AbstractSampling}","page":"Database","title":"pcvct.variationsTable","text":"variationsTable(location::Symbol, S::AbstractSampling; remove_constants::Bool=false)\n\nReturn a DataFrame containing the variations table for the given location and sampling.\n\n\n\n\n\n","category":"method"},{"location":"lib/database/#pcvct.vctDBQuery-Tuple{String}","page":"Database","title":"pcvct.vctDBQuery","text":"vctDBQuery(query::String; db::SQLite.DB=db)\n\nExecute a query against the database and return the result.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#Creation","page":"Creation","title":"Creation","text":"","category":"section"},{"location":"lib/creation/","page":"Creation","title":"Creation","text":"Create a new pcvct project.","category":"page"},{"location":"lib/creation/#pcvct.createProject","page":"Creation","title":"pcvct.createProject","text":"createProject(project_dir::String=\".\"; clone_physicell::Bool=true, template_as_default::Bool=true, terse::Bool=false)\n\nCreate a new pcvct project structure.\n\nCreates a new project directory at project_dir with the following structure:\n\nproject_dir\n├── data\n├── PhysiCell # The latest release from https://github.com/drbergman/PhysiCell\n└── scripts\n\ndata is populated with the standard structure. PhysiCell is a copy of PhysiCell. scripts contains a generated GenerateData.jl file.\n\nArguments\n\nproject_dir::String=\".\": The directory in which to create the project. Relative paths are resolved from the current working directory where Julia was launched.\nclone_physicell::Bool=true: Whether to clone the PhysiCell repository. If false, the latest release will be downloaded. Recommended to set to true so pcvct will be able to track changes to the PhysiCell repository.\ntemplate_as_default::Bool=true: Whether to set up the project with the template files as the default. If false, the project will be set up with an empty structure.\nterse::Bool=false: Whether to generate a terse GenerateData.jl file. If true, the file will be generated without comments and explanations.\n\nNote\n\nThe names of the data and PhysiCell directories are fixed and cannot be changed. Their relative locations should not be changed without updating the GenerateData.jl file. The name of the scripts folder and the GenerateData.jl are just by convention and can be changed.\n\n\n\n\n\n","category":"function"},{"location":"lib/creation/#pcvct.getLatestReleaseTag-Tuple{String}","page":"Creation","title":"pcvct.getLatestReleaseTag","text":"getLatestReleaseTag(repo_url::String)\n\nGet the latest release tag from a GitHub repository.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.icFilename-Tuple{String}","page":"Creation","title":"pcvct.icFilename","text":"icFilename(table_name::String)\n\nGet the filename for the given IC type for setting up the IC folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpComponents-Tuple{String, String}","page":"Creation","title":"pcvct.setUpComponents","text":"setUpComponents(data_dir::String, physicell_dir::String)\n\nSet up the components directory in the data directory and populate it with the \"Toy_Metabolic_Model.xml\" file.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpICFolder-NTuple{4, String}","page":"Creation","title":"pcvct.setUpICFolder","text":"setUpICFolder(path_to_template::String, inputs_dir::String, ic_name::String, folder::String)\n\nSet up the IC folder in the inputs directory for the given IC type.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpInputs-Tuple{String, String, Bool}","page":"Creation","title":"pcvct.setUpInputs","text":"setUpInputs(data_dir::String, physicell_dir::String, template_as_default::Bool)\n\nSet up the inputs directory in the data directory, if the data directory does not already exist.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpPhysiCell-Tuple{String, Bool}","page":"Creation","title":"pcvct.setUpPhysiCell","text":"setUpPhysiCell(project_dir::String, clone_physicell::Bool)\n\nSet up the PhysiCell directory in the project directory.\n\nIf the directory already exists, it will not be created again. If clone_physicell is true, the latest release of the PhysiCell repository will be cloned.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpRequiredFolders-Tuple{String, String, String}","page":"Creation","title":"pcvct.setUpRequiredFolders","text":"setUpRequiredFolders(path_to_template::String, inputs_dir::String, folder::String)\n\nSet up the required folders in the inputs directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpScripts-Tuple{String, String, String, Bool, Bool}","page":"Creation","title":"pcvct.setUpScripts","text":"setUpScripts(project_dir::String, physicell_dir::String, data_dir::String, template_as_default::Bool, terse::Bool)\n\nSet up the scripts directory in the project directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/creation/#pcvct.setUpTemplate-Tuple{String, String}","page":"Creation","title":"pcvct.setUpTemplate","text":"setUpTemplate(physicell_dir::String, inputs_dir::String)\n\nSet up the template project in the inputs directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#Variations","page":"Variations","title":"Variations","text":"","category":"section"},{"location":"lib/variations/","page":"Variations","title":"Variations","text":"Vary parameters of the project.","category":"page"},{"location":"lib/variations/#pcvct.AbstractVariation","page":"Variations","title":"pcvct.AbstractVariation","text":"AbstractVariation\n\nAbstract type for variations.\n\nSubtypes\n\nElementaryVariation, DiscreteVariation, DistributedVariation, CoVariation\n\nMethods\n\naddVariations, createTrial, run,  _createTrial\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddGridVariationsResult","page":"Variations","title":"pcvct.AddGridVariationsResult","text":"AddGridVariationsResult <: AddVariationsResult\n\nA struct that holds the result of adding grid variations to a set of inputs.\n\nFields\n\nall_variation_ids::AbstractArray{VariationID}: The variation IDs for all the variations added.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddLHSVariationsResult","page":"Variations","title":"pcvct.AddLHSVariationsResult","text":"AddLHSVariationsResult <: AddVariationsResult\n\nA struct that holds the result of adding LHS variations to a set of inputs.\n\nFields\n\nall_variation_ids::AbstractArray{VariationID}: The variation IDs for all the variations added.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddRBDVariationsResult","page":"Variations","title":"pcvct.AddRBDVariationsResult","text":"AddRBDVariationsResult <: AddVariationsResult\n\nA struct that holds the result of adding Sobol variations to a set of inputs.\n\nFields\n\nall_variation_ids::AbstractArray{VariationID}: The variation IDs for all the variations added.\nlocation_variation_ids_dict::Dict{Symbol, Matrix{Int}}: A dictionary of the variation IDs for each location. The keys are the locations and the values are the variation IDs for that location.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddSobolVariationsResult","page":"Variations","title":"pcvct.AddSobolVariationsResult","text":"AddSobolVariationsResult <: AddVariationsResult\n\nA struct that holds the result of adding Sobol variations to a set of inputs.\n\nFields\n\nall_variation_ids::AbstractArray{VariationID}: The variation IDs for all the variations added.\ncdfs::Array{Float64, 3}: The CDFs for the samples. The first dimension is the varied parameters, the second dimension is the design matrices, and the third dimension is the samples.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddVariationMethod","page":"Variations","title":"pcvct.AddVariationMethod","text":"AddVariationMethod\n\nAbstract type for variation methods.\n\nSubtypes\n\nGridVariation, LHSVariation, SobolVariation, RBDVariation\n\nMethods\n\naddVariations, createTrial, run,  _createTrial\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.AddVariationsResult","page":"Variations","title":"pcvct.AddVariationsResult","text":"AddVariationsResult\n\nAbstract type for the result of adding variations to a set of inputs.\n\nSubtypes\n\nAddGridVariationsResult, AddLHSVariationsResult, AddSobolVariationsResult, AddRBDVariationsResult\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.CoVariation","page":"Variations","title":"pcvct.CoVariation","text":"CoVariation{T<:ElementaryVariation} <: AbstractVariation\n\nA co-variation of one or more variations. Each must be of the same type, either DiscreteVariation or DistributedVariation.\n\nFields\n\nvariations::Vector{T}: The variations that make up the co-variation.\n\nConstructors\n\nCoVariation(inputs::Vararg{Tuple{Vector{<:AbstractString},Distribution},N}) where {N}: Create a co-variation from a vector of XML paths and distributions.\n\nCoVariation((xml_path_1, d_1), (xml_path_2, d_2), ...) # d_i are distributions, e.g. `d_1 = Uniform(1, 2)`\n\nCoVariation(inputs::Vararg{Tuple{Vector{<:AbstractString},Vector},N}) where {N}: Create a co-variation from a vector of XML paths and values.\n\nCoVariation((xml_path_1, val_1), (xml_path_2, val_2), ...) # val_i are vectors of values, e.g. `val_1 = [0.1, 0.2]`, or singletons, e.g. `val_2 = 0.3`\n\nCoVariation(evs::Vector{ElementaryVariation}): Create a co-variation from a vector of variations all the same type.\n\nCoVariation([discrete_1, discrete_2, ...]) # all discrete variations and with the same number of values\nCoVariation([distributed_1, distributed_2, ...]) # all distributed variations\n\nCoVariation(inputs::Vararg{T}) where {T<:ElementaryVariation}: Create a co-variation from a variable number of variations all the same type.\n\nCoVariation(discrete_1, discrete_2, ...) # all discrete variations and with the same number of values\nCoVariation(distributed_1, distributed_2, ...) # all distributed variations\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.DiscreteVariation","page":"Variations","title":"pcvct.DiscreteVariation","text":"DiscreteVariation\n\nThe location, target, and values of a discrete variation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets_collection, :intracellular, :ic_cell, :ic_ecm. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\nvalues::Vector{T}: The values of the variation. The values are the possible values that the target can take on.\n\nA singleton value can be passed in place of values for convenience.\n\nExamples\n\njulia> dv = DiscreteVariation([\"overall\", \"max_time\"], [1440.0, 2880.0])\nDiscreteVariation (Float64):\n  location: config\n  target: overall/max_time\n  values: [1440.0, 2880.0]\n\nxml_path = rulePath(\"default\", \"cycle entry\", \"decreasing_signals\", \"max_response\")\nDiscreteVariation(xml_path, 0)\n# output\nDiscreteVariation (Int64):\n  location: rulesets_collection\n  target: behavior_ruleset:name:default/behavior:name:cycle entry/decreasing_signals/max_response\n  values: [0]\n\nxml_path = icCellsPath(\"default\", \"disc\", 1, \"x0\")\nDiscreteVariation(xml_path, [0.0, 100.0])\n# output\nDiscreteVariation (Float64):\n  location: ic_cell\n  target: cell_patches:name:default/patch_collection:type:disc/patch:ID:1/x0\n  values: [0.0, 100.0]\n\n```jldoctest xmlpath = icECMPath(2, \"ellipse\", 1, \"density\") DiscreteVariation(xmlpath, [0.1, 0.2])\n\noutput\n\nDistributedVariation:   location: icecm   target: layer:ID:2/patchcollection:type:ellipse/patch:ID:1/density   values: [0.1, 0.2]\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.DistributedVariation","page":"Variations","title":"pcvct.DistributedVariation","text":"DistributedVariation\n\nThe location, target, and distribution of a distributed variation.\n\nAnalagousy to DiscreteVariation, instances of DistributedVariation can be initialized with a target (XML path) and a distribution (a distribution from the Distributions package). Alternatively, users can use the UniformDistributedVariation and NormalDistributedVariation functions to create instances of DistributedVariation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets_collection, :intracellular, :ic_cell, or :ic_ecm. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\ndistribution::Distribution: The distribution of the variation.\nflip::Bool=false: Whether to flip the distribution, i.e., when asked for the iCDF of x, return the iCDF of 1-x. Useful for CoVariation's.\n\nExamples\n\nusing Distributions\nd = Uniform(1, 2)\nDistributedVariation(pcvct.apoptosisPath(\"default\", \"death_rate\"), d)\n# output\nDistributedVariation:\n  location: config\n  target: cell_definitions/cell_definition:name:default/phenotype/death/model:code:100/death_rate\n  distribution: Distributions.Uniform{Float64}(a=1.0, b=2.0)\n\n```jldoctest using Distributions d = Uniform(1, 2) flip = true # the cdf on this variation will decrease from 1 to 0 as the value increases from 1 to 2 DistributedVariation(pcvct.necrosisPath(\"default\", \"death_rate\"), d, flip)\n\noutput\n\nDistributedVariation (flipped):   location: config   target: celldefinitions/celldefinition:name:default/phenotype/death/model:code:101/death_rate   distribution: Distributions.Uniform{Float64}(a=1.0, b=2.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.ElementaryVariation","page":"Variations","title":"pcvct.ElementaryVariation","text":"ElementaryVariation <: AbstractVariation\n\nThe base type for variations of a single parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.GridVariation","page":"Variations","title":"pcvct.GridVariation","text":"GridVariation <: AddVariationMethod\n\nA variation method that creates a grid of all possible combinations of the values of the variations.\n\nExamples\n\njulia> GridVariation() # the only method for GridVariation\nGridVariation()\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.LHSVariation","page":"Variations","title":"pcvct.LHSVariation","text":"LHSVariation <: AddVariationMethod\n\nA variation method that creates a Latin Hypercube Sample of the values of the variations.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nExamples\n\njulia> LHSVariation(4) # set `n` and use default values for the rest\nLHSVariation(4, false, Random.TaskLocalRNG(), true)\n\nusing Random\nLHSVariation(; n=16, add_noise=true, rng=MersenneTwister(1234), orthogonalize=false)\n# output\nLHSVariation(16, true, MersenneTwister(1234), false)\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.LocationParsedVariations","page":"Variations","title":"pcvct.LocationParsedVariations","text":"LocationParsedVariations\n\nA struct that holds the variations and their indices into a vector of AbstractVariations for a specific location.\n\nFields\n\nvariations::Vector{<:ElementaryVariation}: The variations for the location.\nindices::Vector{Int}: The indices of the variations in the vector of AbstractVariations.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.ParsedVariations","page":"Variations","title":"pcvct.ParsedVariations","text":"ParsedVariations\n\nA struct that holds the parsed variations and their sizes for all locations.\n\nFields\n\nsz::Vector{Int}: The sizes of the variations for each location.\nvariations::Vector{<:AbstractVariation}: The variations used to create the parsed variations.\nlocation_parsed_variations::NamedTuple: A named tuple of LocationParsedVariationss for each location.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.RBDVariation","page":"Variations","title":"pcvct.RBDVariation","text":"RBDVariation <: AddVariationMethod\n\nA variation method that creates a Random Balance Design of the values of the variations.\n\nThis creates n sample points where the values in each dimension are uniformly distributed. By default, this will use Sobol sequences (see SobolVariation) to create the sample points. If use_sobol is false, it will use random permutations of uniformly spaced points for each dimension.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\nuse_sobol::Bool=true: Whether to use Sobol sequences to create the sample points.\n\nDo not set these next two fields unless you know what you are doing. Let pcvct compute them.\n\npow2_diff::Union{Missing, Int}=missing: The difference between n and the nearest power of 2. Missing means pcvct will compute it if using Sobol sequences.\nnum_cycles::Union{Missing, Int, Rational}=missing: The number of cycles to use in the Sobol sequence. Missing means pcvct will set it.\n\nExamples\n\njulia> pcvct.RBDVariation(4) # set `n` and use default values for the rest\nRBDVariation(4, Random.TaskLocalRNG(), true, 0, 1//2)\n\njulia> pcvct.RBDVariation(4; use_sobol=false) # use random permutations of uniformly spaced points\nRBDVariation(4, Random.TaskLocalRNG(), false, missing, 1//1)\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.SobolVariation","page":"Variations","title":"pcvct.SobolVariation","text":"SobolVariation <: AddVariationMethod\n\nA variation method that creates a Sobol sequence of the values of the variations.\n\nSee generateSobolCDFs for more information on how the Sobol sequence is generated based on n and the other fields.\n\nSee the GlobalSensitivity.jl package for more information on RandomizationMethod's to use.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence.\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nExamples\n\njulia> SobolVariation(9) # set `n` and use default values for the rest; will use [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1]\nSobolVariation(9, 1, QuasiMonteCarlo.NoRand(), missing, missing)\n\njulia> SobolVariation(15; skip_start=true) # use [0.5, 0.25, 0.75, ..., 1/16, 3/16, ..., 15/16]\nSobolVariation(15, 1, QuasiMonteCarlo.NoRand(), true, missing)\n\njulia> SobolVariation(4; include_one=true) # use [0, 0.5, 1] and one of [0.25, 0.75]\nSobolVariation(4, 1, QuasiMonteCarlo.NoRand(), missing, true)\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#pcvct.XMLPath","page":"Variations","title":"pcvct.XMLPath","text":"XMLPath\n\nHold the XML path as a vector of strings.\n\nPhysiCell uses a : in names for signals/behaviors from cell custom data. For example, custom:sample is the default way to represent the sample custom data in a PhysiCell rule. pcvct uses : to indicate an attribute in an XML path and thus splits on : when looking for attribute values. To avoid this conflict, pcvct will internally replace custom:<name> and custom: <name> with custom <name>. Users should never have to think about this. Any pcvct function that uses XML paths will automatically handle this replacement.\n\n\n\n\n\n","category":"type"},{"location":"lib/variations/#Distributions.cdf-Tuple{DiscreteVariation, Real}","page":"Variations","title":"Distributions.cdf","text":"cdf(ev::ElementaryVariation, x::Real)\n\nGet the cumulative distribution function (CDF) of the variation at x.\n\nIf ev is a DiscreteVariation, x must be in the values of the variation. The value returned is from 0:Δ:1 where Δ=1/(n-1) and n is the number of values in the variation.\n\nIf ev is a DistributedVariation, the CDF is computed from the distribution of the variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.NormalDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"Variations","title":"pcvct.NormalDistributedVariation","text":"NormalDistributedVariation(xml_path::Vector{<:AbstractString}, mu::T, sigma::T; lb::Real=-Inf, ub::Real=Inf) where {T<:Real}\n\nCreate a (possibly truncated) distributed variation with a normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.UniformDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"Variations","title":"pcvct.UniformDistributedVariation","text":"UniformDistributedVariation(xml_path::Vector{<:AbstractString}, lb::T, ub::T) where {T<:Real}\n\nCreate a distributed variation with a uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addAttackRateVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"Variations","title":"pcvct.addAttackRateVariationDimension!","text":"addAttackRateVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, target_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for the attack rate of a cell type against a target cell type.\n\nExamples:\n\naddAttackRateVariationDimension!(evs, \"immune\", \"cancer\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addColumns-Tuple{Symbol, Int64, Vector{<:ElementaryVariation}}","page":"Variations","title":"pcvct.addColumns","text":"addColumns(location::Symbol, folder_id::Int, evs::Vector{<:ElementaryVariation})\n\nAdd columns to the variations database for the given location and folder_id.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addCustomDataVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"Variations","title":"pcvct.addCustomDataVariationDimension!","text":"addCustomDataVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, field_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for a custom data field of a cell type.\n\nExamples:\n\naddCustomDataVariationDimension!(evs, \"immune\", \"perforin\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addDomainVariationDimension!-Tuple{Vector{<:ElementaryVariation}, NamedTuple}","page":"Variations","title":"pcvct.addDomainVariationDimension!","text":"addDomainVariationDimension!(evs::Vector{<:ElementaryVariation}, domain::NamedTuple)\n\nPushes variations onto evs for each domain boundary named in domain.\n\nThe names in domain can be flexibly named as long as they contain either min or max and one of x, y, or z (other than the the x in max). It is not required to include all three dimensions and their boundaries. The values for each boundary can be a single value or a vector of values.\n\nExamples:\n\n``` evs = ElementaryVariation[] addDomainVariationDimension!(evs, (xmin=-78, xmax=78, miny=-30, maxy=[30, 60], z_max=10))\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addLocationCDFVariations-Tuple{Symbol, InputFolders, pcvct.ParsedVariations, pcvct.VariationID, AbstractMatrix{Float64}}","page":"Variations","title":"pcvct.addLocationCDFVariations","text":"addLocationCDFVariations(location::Symbol, inputs::InputFolders, pv::ParsedVariations, reference_variation_id::VariationID, cdfs::AbstractMatrix{Float64})\n\nAdd variations for a specific location to the inputs. Used in addVariations with the LHSVariation, SobolVariation, and RBDVariation methods.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addLocationGridVariations-Tuple{Symbol, InputFolders, pcvct.ParsedVariations, pcvct.VariationID}","page":"Variations","title":"pcvct.addLocationGridVariations","text":"addLocationGridVariations(location::Symbol, inputs::InputFolders, pv::ParsedVariations, reference_variation_id::VariationID)\n\nAdd grid variations for a specific location to the inputs. Used in addVariations with a GridVariation method.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addVariationRow-Tuple{Symbol, Int64, String, String, String}","page":"Variations","title":"pcvct.addVariationRow","text":"addVariationRow(location::Symbol, folder_id::Int, table_features::String, static_values::String, varied_values::String)\n\nAdd a new row to the variations database for the given location and folder_id if it doesn't already exist.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.addVariations","page":"Variations","title":"pcvct.addVariations","text":"addVariations(method::AddVariationMethod, inputs::InputFolders, avs::Vector{<:AbstractVariation}, reference_variation_id::VariationID=VariationID(inputs))\n\nAdd variations to the inputs using the specified AddVariationMethod and the variations in avs.\n\n\n\n\n\n","category":"function"},{"location":"lib/variations/#pcvct.cdfsToVariations-Tuple{Symbol, pcvct.ParsedVariations, Int64, Int64, AbstractMatrix{Float64}}","page":"Variations","title":"pcvct.cdfsToVariations","text":"cdfsToVariations(location::Symbol, pv::ParsedVariations, folder_id::Int, reference_variation_id::Int, cdfs::AbstractMatrix{Float64})\n\nConvert the CDFs to variation IDs in the database.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.createSortedRBDMatrix-Tuple{Vector{Int64}, AbstractMatrix{Int64}}","page":"Variations","title":"pcvct.createSortedRBDMatrix","text":"createSortedRBDMatrix(variation_ids::Vector{Int}, rbd_sorting_inds::AbstractMatrix{Int})\n\nCreate a sorted matrix of variation IDs based on the RBD sorting indices. This ensures that the orderings for each parameter stored for the RBD calculations.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.generateLHSCDFs-Tuple{Int64, Int64}","page":"Variations","title":"pcvct.generateLHSCDFs","text":"generateLHSCDFs(n::Int, d::Int[; add_noise::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG, orthogonalize::Bool=true])\n\nGenerate a Latin Hypercube Sample of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples, if possible. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nReturns\n\ncdfs::Matrix{Float64}: The CDFs for the samples. Each row is a sample and each column is a dimension (corresponding to a feature).\n\nExamples\n\ncdfs = pcvct.generateLHSCDFs(4, 2)\nsize(cdfs)\n# output\n(4, 2)\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.generateRBDCDFs-Tuple{RBDVariation, Int64}","page":"Variations","title":"pcvct.generateRBDCDFs","text":"generateRBDCDFs(rbd_variation::RBDVariation, d::Int)\n\nGenerate CDFs for a Random Balance Design (RBD) in d dimensions.\n\nArguments\n\nrbd_variation::RBDVariation: The RBD variation method to use.\nd::Int: The number of dimensions to sample.\n\nReturns\n\ncdfs::Matrix{Float64}: The CDFs for the samples. Each row is a sample and each column is a dimension (corresponding to a parameter / parameter group from a CoVariation).\nrbd_sorting_inds::Matrix{Int}: A n_samples x d matrix that gives the ordering of the dimensions to use for the RBD. The order along each column is necessary for computing the RBD, sorting the simulations along the periodic curve.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.generateSobolCDFs-Tuple{Int64, Int64}","page":"Variations","title":"pcvct.generateSobolCDFs","text":"generateSobolCDFs(n::Int, d::Int[; n_matrices::Int=1, randomization::RandomizationMethod=NoRand(), skip_start::Union{Missing, Bool, Int}=missing, include_one::Union{Missing, Bool}=missing)\n\nGenerate n_matrices Sobol sequences of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nThe subsequence of the Sobol sequence is chosen based on the value of n and the value of include_one. If it is one less than a power of 2, e.g. n=7, skip 0 and start from 0.5. Otherwise, it will always start from 0. If it is one more than a power of 2, e.g. n=9, include 1 (unless include_one is false).\n\nThe skip_start field can be used to control this by skipping the start of the sequence. If skip_start is true, skip to the smallest consecutive subsequence with the same denominator that has at least n elements. If skip_start is false, start from 0. If skip_start is an integer, skip that many elements in the sequence, .e.g., skip_start=1 skips 0 and starts at 0.5.\n\nIf you want to include 1 in the sequence, set include_one to true. If you want to exlude 1 (in the case of n=9, e.g.), set include_one to false.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence (effectively, the dimension of the sample is d x n_matrices).\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence. See GlobalSensitivity.jl.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nReturns\n\ncdfs::Array{Float64, 3}: The CDFs for the samples. The first dimension is the features, the second dimension is the matrix, and the third dimension is the sample points.\n\nExamples\n\ncdfs = pcvct.generateSobolCDFs(11, 3)\nsize(cdfs)\n# output\n(3, 1, 11)\n\ncdfs = pcvct.generateSobolCDFs(7, 5; n_matrices=2)\nsize(cdfs)\n# output\n(5, 2, 7)\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.gridToDB-Tuple{Vector{<:DiscreteVariation}, Int64, Int64}","page":"Variations","title":"pcvct.gridToDB","text":"gridToDB(evs::Vector{<:DiscreteVariation}, folder_id::Int, reference_variation_id::Int)\n\nAdds a grid of variations to the database from the vector of DiscreteVariations.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.orthogonalLHS-Tuple{Int64, Int64}","page":"Variations","title":"pcvct.orthogonalLHS","text":"orthogonalLHS(k::Int, d::Int)\n\nGenerate an orthogonal Latin Hypercube Sample in d dimensions with k subdivisions in each dimension, requiring n=k^d samples.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.setUpColumns-Tuple{Symbol, Vector{<:ElementaryVariation}, Int64, Int64}","page":"Variations","title":"pcvct.setUpColumns","text":"setUpColumns(location::Symbol, evs::Vector{<:ElementaryVariation}, folder_id::Int, reference_variation_id::Int)\n\nSet up the columns for the variations database for the given location and folder_id.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.sqliteDataType-Tuple{ElementaryVariation}","page":"Variations","title":"pcvct.sqliteDataType","text":"sqliteDataType(ev::ElementaryVariation)\n\nGet the SQLite data type to hold the data in the variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.variationDataType-Union{Tuple{DiscreteVariation{T}}, Tuple{T}} where T","page":"Variations","title":"pcvct.variationDataType","text":"variationDataType(ev::ElementaryVariation)\n\nGet the data type of the variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.variationLocation-Tuple{ElementaryVariation}","page":"Variations","title":"pcvct.variationLocation","text":"variationLocation(av::AbstractVariation)\n\nGet the location of a variation as a Symbol, e.g., :config, :rulesets_collection, etc. Can also pass in an XMLPath object.\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.variationTarget-Tuple{ElementaryVariation}","page":"Variations","title":"pcvct.variationTarget","text":"variationTarget(av::AbstractVariation)\n\nGet the type XMLPath target(s) of a variation\n\n\n\n\n\n","category":"method"},{"location":"lib/variations/#pcvct.variationValues-Tuple{DiscreteVariation}","page":"Variations","title":"pcvct.variationValues","text":"variationValues(ev::ElementaryVariation[, cdf])\n\nGet the values of an ElementaryVariation.\n\nIf ev is a DiscreteVariation, all values are returned unless cdf is provided. In that case, the CDF(s) is linearly converted into an index into the values vector and the corresponding value is returned.\n\nIf ev is a DistributedVariation, the cdf is required and the iCDF is returned. The cdf can be a single value or a vector of values.\n\nArguments\n\nev::ElementaryVariation: The variation to get the values of.\ncdf: The cumulative distribution function (CDF) values to use for the variation.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#Runner","page":"Runner","title":"Runner","text":"","category":"section"},{"location":"lib/runner/","page":"Runner","title":"Runner","text":"Run simulations, monads, samplings, and trials in the pcvct framework.","category":"page"},{"location":"lib/runner/#pcvct.PCVCTOutput","page":"Runner","title":"pcvct.PCVCTOutput","text":"PCVCTOutput\n\nA struct to hold the output of the PCVCT run, including the AbstractTrial object, the number of scheduled simulations, and the number of successful simulations.\n\nFields\n\ntrial::AbstractTrial: The trial, sampling, monad, or simulation that was run.\nn_scheduled::Int: The number of simulations that were scheduled to run.\nn_success::Int: The number of simulations that were successfully completed.\n\n\n\n\n\n","category":"type"},{"location":"lib/runner/#pcvct.SimulationProcess","page":"Runner","title":"pcvct.SimulationProcess","text":"SimulationProcess\n\nA struct to hold the simulation process and its associated monad ID. Users should not need to interact with this struct directly.\n\nFields\n\nsimulation::Simulation: The simulation object.\nmonad_id::Int: The ID of the associated monad.\nprocess::Union{Nothing,Base.Process}: The process associated with the simulation. If the simulation process fails, e.g. if the command cannot be constructed, this will be nothing.\n\n\n\n\n\n","category":"type"},{"location":"lib/runner/#Base.run-Tuple{pcvct.AbstractTrial}","page":"Runner","title":"Base.run","text":"run(T::AbstractTrial[; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions()])`\n\nRun the given simulation, monad, sampling, or trial.\n\nCall the appropriate functions to run the simulations and return the number of successful simulations. Also print out messages to the console to inform the user about the progress and results of the simulations.\n\nArguments\n\nT::AbstractTrial: The trial, sampling, monad, or simulation to run.\nforce_recompile::Bool=false: If true, forces a recompilation of all files by removing all .o files in the PhysiCell directory.\nprune_options::PruneOptions=PruneOptions(): Options for pruning simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.collectSimulationTasks-Tuple{Simulation}","page":"Runner","title":"pcvct.collectSimulationTasks","text":"collectSimulationTasks(T::AbstractTrial[; force_recompile::Bool=false])\n\nCollect the simulation tasks for the given trial, sampling, monad, or simulation.\n\nArguments\n\nT::AbstractTrial: The trial, sampling, monad, or simulation to collect tasks for.\n\nKeyword Arguments\n\nforce_recompile::Bool=false: If true, forces a recompilation of all files by removing all .o files in the PhysiCell directory.\ndo_full_setup::Bool=true: If true, performs a full setup of the simulation, including compiling code and preparing input files. Only used for AbstractMonad objects.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.getSimulationIDs-Tuple{pcvct.PCVCTOutput}","page":"Runner","title":"pcvct.getSimulationIDs","text":"getSimulationIDs(output::PCVCTOutput)\n\nGet the simulation IDs from the output of the PCVCT run.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.prepCmdForWrap-Tuple{Cmd}","page":"Runner","title":"pcvct.prepCmdForWrap","text":"prepCmdForWrap(cmd::Cmd)\n\nPrepare the command for wrapping in the sbatch command. This is a helper function to remove the backticks from the command string.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.prepareHPCCommand-Tuple{Cmd, Int64}","page":"Runner","title":"pcvct.prepareHPCCommand","text":"prepareHPCCommand(cmd::Cmd, simulation_id::Int)\n\nPrepare the command to run a simulation on an HPC system using sbatch. This function adds the necessary flags to the command and returns it as a Cmd object.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.prepareSimulationCommand-Tuple{Simulation, Int64, Bool, Bool}","page":"Runner","title":"pcvct.prepareSimulationCommand","text":"prepareSimulationCommand(simulation::Simulation, monad_id::Int, do_full_setup::Bool, force_recompile::Bool)\n\nInternal function to prepare the command to run a simulation, including preparing input files and compiling the custom code if necessary.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.processSimulationTask-Tuple{Any, Any}","page":"Runner","title":"pcvct.processSimulationTask","text":"processSimulationTask(simulation_task, prune_options)\n\nProcess the given simulation task and return whether it was successful.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.resolveSimulation-Tuple{pcvct.SimulationProcess, PruneOptions}","page":"Runner","title":"pcvct.resolveSimulation","text":"resolveSimulation(simulation_process::SimulationProcess, prune_options::PruneOptions)\n\nResolve the simulation process by checking its exit code and updating the database accordingly.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.runAbstractTrial-Tuple{pcvct.AbstractTrial}","page":"Runner","title":"pcvct.runAbstractTrial","text":"runAbstractTrial(T::AbstractTrial; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions())\n\nAlias for run, but only with this particular signature. Does not work on Cmd objects as Base.run is built for. Also, does not work with running sensitivity samplings.\n\n\n\n\n\n","category":"method"},{"location":"lib/runner/#pcvct.simulationFailedToRun-Tuple{Simulation, Int64}","page":"Runner","title":"pcvct.simulationFailedToRun","text":"simulationFailedToRun(simulation::Simulation, monad_id::Int)\n\nSet the status code of the simulation to \"Failed\" and erase the simulation ID from the simulations.csv file for the monad it belongs to.\n\n\n\n\n\n","category":"method"},{"location":"lib/recorder/#Recorder","page":"Recorder","title":"Recorder","text":"","category":"section"},{"location":"lib/recorder/","page":"Recorder","title":"Recorder","text":"Functionality for recording constituent IDs of Monads, Samplings, and Trials.","category":"page"},{"location":"lib/recorder/#pcvct.compressIDs-Tuple{AbstractArray{Int64}}","page":"Recorder","title":"pcvct.compressIDs","text":"compressIDs(ids::AbstractArray{Int})\n\nCompress a list of IDs into a more compact representation by grouping consecutive IDs together.\n\n\n\n\n\n","category":"method"},{"location":"lib/recorder/#pcvct.recordConstituentIDs-Tuple{Type{<:pcvct.AbstractTrial}, Int64, Array{Int64}}","page":"Recorder","title":"pcvct.recordConstituentIDs","text":"recordConstituentIDs(T::Type{<:AbstractTrial}, id::Int, ids::Array{Int})\nrecordConstituentIDs(T::AbstractTrial, ids::Array{Int})\n\nRecord the IDs of the constituents of an AbstractTrial object in a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"lib/pruner/#Pruner","page":"Pruner","title":"Pruner","text":"","category":"section"},{"location":"lib/pruner/","page":"Pruner","title":"Pruner","text":"Prune files from a simulation immediately after finishing the simulation.","category":"page"},{"location":"lib/pruner/","page":"Pruner","title":"Pruner","text":"To motivate this functionality, consider the following scenario. A user has been testing their model, including making movies, and is ready to do a large virtual clinical trial with thousands of simulations. Saving all the SVGs will require gigabytes of storage, which is not ideal for the user. The user could choose to create a new variation on the SVG parameters (e.g., increase the SVG save interval), but then pcvct will not be able to reuse previous simulations as they have different variation IDs. Alternatively, the user can use the PruneOptions to delete the SVGs after each simulation is finished. This way, there are fewer variations in the database and more capability to reuse simulations.","category":"page"},{"location":"lib/pruner/#pcvct.PruneOptions","page":"Pruner","title":"pcvct.PruneOptions","text":"PruneOptions\n\nAutomatically prune some of the generated output files from a simulation.\n\nFields\n\nprune_svg::Bool=false: Prune SVG files\nprune_txt::Bool=false: Prune TXT files\nprune_mat::Bool=false: Prune MAT files\nprune_initial::Bool=false: If any of the above are true, also prune the initial files for that type\nprune_final::Bool=false: If any of the above are true, also prune the final files for that type\n\nExamples\n\njulia> PruneOptions(prune_svg=true, prune_txt=true, prune_mat=true)\nPruneOptions\n  prune_mat: Bool true\n  prune_svg: Bool true\n  prune_txt: Bool true\n  prune_xml: Bool false\n  prune_initial: Bool false\n  prune_final: Bool false\n\n\n\n\n\n","category":"type"},{"location":"lib/pruner/#pcvct.pruneSimulationOutput","page":"Pruner","title":"pcvct.pruneSimulationOutput","text":"pruneSimulationOutput(simulation_id::Integer, prune_options::PruneOptions=PruneOptions())\n\nPrune the output files from a simulation.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation. A Simulation object can also be passed in.\nprune_options::PruneOptions=PruneOptions(): The options for pruning the output files. See PruneOptions for more information.\n\n```\n\n\n\n\n\n","category":"function"},{"location":"man/developer_guide/#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"man/developer_guide/#Style-guide","page":"Developer guide","title":"Style guide","text":"","category":"section"},{"location":"man/developer_guide/","page":"Developer guide","title":"Developer guide","text":"Use #! for comments that are informative\nThis helps find code lines commented out in development.\nUsing the regexp ^(\\s+)?# .+\\n seems to work well for finding commented out code lines.","category":"page"},{"location":"lib/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"lib/export/","page":"Export","title":"Export","text":"This file holds the functions for exporting a simulation to a user_project format.","category":"page"},{"location":"lib/export/#pcvct.createExportFolder-Tuple{Simulation, AbstractString}","page":"Export","title":"pcvct.createExportFolder","text":"createExportFolder(simulation::Simulation, export_folder::AbstractString)\n\nCreate and populate the export folder for a simulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.exportIntracellular-Tuple{Simulation, AbstractString}","page":"Export","title":"pcvct.exportIntracellular","text":"exportIntracellular(simulation::Simulation, export_folder::AbstractString)\n\nExport the intracellular model for a simulation to the export folder.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.exportSimulation","page":"Export","title":"pcvct.exportSimulation","text":"exportSimulation(simulation_id::Integer[, export_folder::AbstractString])\n\nCreate a user_project folder from a simulation that can be loaded into PhysiCell.\n\nWarning: not all features in drbergman/PhysiCell/latest/release are not supported in MathCancer/PhysiCell.\n\nArguments\n\nsimulation_id::Integer: the id of the simulation to export. Can also be a Simulation object.\nexport_folder::AbstractString: the folder to export the simulation to. Default is the simulation output folder.\n\nReturns\n\nexport_folder::AbstractString: the folder where the simulation was exported to\n\n\n\n\n\n","category":"function"},{"location":"lib/export/#pcvct.revertConfig-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertConfig","text":"revertConfig(export_folder::AbstractString, physicell_version::AbstractString)\n\nRevert the config folder in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertCustomCPP-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertCustomCPP","text":"revertCustomCPP(path_to_custom_modules::AbstractString, physicell_version::AbstractString)\n\nRevert the custom cpp file in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertCustomHeader-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertCustomHeader","text":"revertCustomHeader(path_to_custom_modules::AbstractString, physicell_version::AbstractString)\n\nRevert the custom header file in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertCustomModules-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertCustomModules","text":"revertCustomModules(export_folder::AbstractString, physicell_version::AbstractString)\n\nRevert the custom modules in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertMain-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertMain","text":"revertMain(export_folder::AbstractString, physicell_version::AbstractString)\n\nRevert the main.cpp file in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertMakefile-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertMakefile","text":"revertMakefile(export_folder::AbstractString, physicell_version::AbstractString)\n\nRevert the Makefile in the export folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.revertSimulationFolderToCurrentPhysiCell-Tuple{AbstractString, AbstractString}","page":"Export","title":"pcvct.revertSimulationFolderToCurrentPhysiCell","text":"revertSimulationFolderToCurrentPhysiCell(export_folder::AbstractString, physicell_version::AbstractString)\n\nRevert the simulation folder to the given PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/export/#pcvct.setECMSetupElement-Tuple{LightXML.XMLDocument}","page":"Export","title":"pcvct.setECMSetupElement","text":"setECMSetupElement(xml_doc::XMLDocument)\n\nSet up the ECM element in the XML document to support the ECM module.\n\n\n\n\n\n","category":"method"},{"location":"lib/ic_cell/#Cell-Initial-Conditions","page":"Cell Initial Conditions","title":"Cell Initial Conditions","text":"","category":"section"},{"location":"lib/ic_cell/","page":"Cell Initial Conditions","title":"Cell Initial Conditions","text":"Functionality for the using PhysiCellCellCreator.jl to create and use PhysiCell IC cell XML files.","category":"page"},{"location":"lib/ic_cell/#pcvct.createICCellXMLTemplate-Tuple{String}","page":"Cell Initial Conditions","title":"pcvct.createICCellXMLTemplate","text":"createICCellXMLTemplate(folder::String)\n\nCreate folder with a template XML file for IC cells.\n\nSee the PhysiCellCellCreator.jl documentation for more information on IC cells and how this function works outside of pcvct. This pcvct function runs the createICCellXMLTemplate function from PhysiCellCellCreator.jl and then updates the database. Furthermore, the folder can be passed in just as the name of the folder located in data/inputs/ics/cells/ rather than the full path.\n\nThis functionality is run outside of a PhysiCell runtime. It will not work in PhysiCell! This function creates a template XML file for IC cells, showing all the current functionality of this initialization scheme. It uses the cell type \"default\". Create ICs for more cell types by copying the cell_patches element. The ID attribute in patch elements is there exactly to allow variations to target specific patches. Manually maintain these or you will not be able to vary specific patches effectively.\n\nEach time a simulation is run that is using a cells.xml file, a new CSV file will be created, drawing randomly from the patches defined in the XML file. These will all be stored with data/inputs/ics/cells/folder/ic_cell_variations as ic_cell_variation_#_s#.csv where the first # is the variation ID associated with variation on the XML file and the second # is the simulation ID. Importantly, no two simulations will use the same CSV file.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#PhysiCell-Version","page":"PhysiCell Version","title":"PhysiCell Version","text":"","category":"section"},{"location":"lib/physicell_version/","page":"PhysiCell Version","title":"PhysiCell Version","text":"Manage the PhysiCell version used in the project.","category":"page"},{"location":"lib/physicell_version/#pcvct.currentPhysiCellVersionID-Tuple{}","page":"PhysiCell Version","title":"pcvct.currentPhysiCellVersionID","text":"currentPhysiCellVersionID()\n\nGet the current PhysiCell version ID.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.getCommitHashToTagDict-Tuple{String}","page":"PhysiCell Version","title":"pcvct.getCommitHashToTagDict","text":"getCommitHashToTagDict(dir::String)\n\nGet a dictionary mapping commit hashes to tags in the git repository at dir.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.gitDirectoryIsClean-Tuple{String}","page":"PhysiCell Version","title":"pcvct.gitDirectoryIsClean","text":"gitDirectoryIsClean(dir::String)\n\nCheck if the git directory is clean (i.e., no uncommitted changes).\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.gitRemotes-Tuple{String}","page":"PhysiCell Version","title":"pcvct.gitRemotes","text":"gitRemotes(dir::String)\n\nGet the remotes for the git repository at dir.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.physiCellCommitHash-Tuple{}","page":"PhysiCell Version","title":"pcvct.physiCellCommitHash","text":"physicellCommitHash()\n\nGet the commit hash for the current PhysiCell version.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.physicellInfo-Tuple{}","page":"PhysiCell Version","title":"pcvct.physicellInfo","text":"physicellInfo()\n\nReturn a string representing the PhysiCell version information to display on initializing the model manager.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.physicellIsGit-Tuple{}","page":"PhysiCell Version","title":"pcvct.physicellIsGit","text":"physicellIsGit()\n\nCheck if the PhysiCell directory is a git repository.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.physicellVersion-Tuple{Int64}","page":"PhysiCell Version","title":"pcvct.physicellVersion","text":"physicellVersion()\nphysiCellVersion(physicell_version_id::Int)\nphysiCellVersion(simulation::Simulation)\n\nGet the PhysiCell version from the database or, if not in the database, from the VERSION.txt file.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.repoOwner-Tuple{Any, String}","page":"PhysiCell Version","title":"pcvct.repoOwner","text":"repoOwner(commit_hash::String, tag::String)\n\nGet the owner of the repository for a given commit hash and tag.\n\n\n\n\n\n","category":"method"},{"location":"lib/physicell_version/#pcvct.resolvePhysiCellVersionID-Tuple{}","page":"PhysiCell Version","title":"pcvct.resolvePhysiCellVersionID","text":"resolvePhysiCellVersionID()\n\nGet the PhysiCell version ID from the database, adding it to the database if it doesn't exist.\n\n\n\n\n\n","category":"method"},{"location":"#pcvct","page":"Home","title":"pcvct","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The pcvct (PhysiCell Virtual Clinical Trials) package is a Julia package that provides a framework for running virtual clinical trials using PhysiCell simulations. See Getting started for getting pcvct set up and running.","category":"page"},{"location":"#Issues","page":"Home","title":"Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Have an issue? First check the Known limitations and Best practices sections. If you still have an issue, please submit it here.","category":"page"},{"location":"man/data_directory/#Data-directory-structure","page":"Data directory","title":"Data directory structure","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"To set up your pcvct-enabled repository within project-dir (the name of your project directory), create the following directory structure:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"project-dir/\n├── data/\n│   └── inputs/\n│       ├── configs/\n│       ├── custom_codes/\n│       ├── ics/\n│       │   ├── cells/\n│       │   ├── dcs/\n│       │   ├── ecms/\n│       │   └── substrates/\n│       ├── intracellulars/\n│       ├── rulesets_collections/\n...","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Within each of the terminal subdirectories above within data/inputs/, add a subdirectory with a user-defined name with content described below. We will use the name \"default\" for all as an example.","category":"page"},{"location":"man/data_directory/#Configs","page":"Data directory","title":"Configs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/configs/default/ called PhysiCell_settings.xml with the base configuration file for your PhysiCell project.","category":"page"},{"location":"man/data_directory/#Custom-codes","page":"Data directory","title":"Custom codes","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add within data/inputs/custom_codes/default/ the following, each exactly as is used in a PhysiCell project:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"main.cpp\nMakefile\ncustom_modules/","category":"page"},{"location":"man/data_directory/#Rulesets-collections","page":"Data directory","title":"Rulesets collections","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/rulesets_collections/default/ called base_rulesets.csv with the base ruleset collection for your PhysiCell project. If your project does not use rules, you can skip this step.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"You may also place an XML file here. Use PhysiCellXMLRules.jl to create one from a standard CSV version of the rules.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Important: In either case, the variations you define must be on the XML version. After calling initializeModelManager(), any folder with base_rulesets.csv will now be populated with a base_rulesets.xml file that can be reference to set the XML paths.","category":"page"},{"location":"man/data_directory/#Intracellulars","page":"Data directory","title":"Intracellulars","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single XML file within data/inputs/intracellulars/default/ called intracellular.xml in which the root has two child elements: cell_definitions and intracellulars. This currently only supports libRoadRunner, i.e., ODEs. See the sample_projects_intracellular/combined/template-combined for an example. See Intracellular inputs for much more information.","category":"page"},{"location":"man/data_directory/#ICs","page":"Data directory","title":"ICs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"These folders are optional as not every model includes initial conditions as separate files. If your model does, for each initial condition add a subfolder. For example, if you have two initial cell position conditions, random_cells.csv and structured_cells.csv, the data/inputs/ics/cells/ directory would look like this:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"cells/\n├── random_cells/\n│   └── cells.csv\n└── structured_cells/\n    └── cells.csv","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Note: Place the files in their corresponding folders and rename to cells.csv.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Proceed similarly for dcs/, ecms/, and substrates/, renaming those files to dcs.csv, ecm.csv, and substrates.csv, respectively.","category":"page"},{"location":"man/data_directory/#IC-cells","page":"Data directory","title":"IC cells","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"pcvct uses PhysiCellCellCreator.jl to allow for creation of cells.csv files based on geometries defined in a cells.xml file. To use this, first create such an XML document (see PhysiCellCellCreator.jl for details) and place this in place of the cells.csv file. You may make variations on this in the same was as for config and rulesets_collection.","category":"page"},{"location":"man/data_directory/#IC-ecm","page":"Data directory","title":"IC ecm","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"pcvct uses PhysiCellECMCreator.jl to allow for creation of ecm.csv files based on the structure defined in a ecm.xml file. To use this, first create such an XML document (see PhysiCellECMCreator.jl for details) and place this in place of the ecm.csv file. You may make variations on this in the same was as for config and rulesets_collection.","category":"page"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Read Best practices before using pcvct.","category":"page"},{"location":"man/getting_started/#Install-pcvct","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/#Download-julia","page":"Getting started","title":"Download julia","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The easiest way to install julia is to use the command line. On Linux and MacOS, you can run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"On Windows, you can run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"> winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: this command also installs the JuliaUp installation manager, which will automatically install julia and help keep it up to date.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"See here for the Julia installation home page. See here for more download options.","category":"page"},{"location":"man/getting_started/#Add-the-PCVCTRegistry","page":"Getting started","title":"Add the PCVCTRegistry","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Launch julia by running julia in a shell. Then, enter the Pkg REPL by pressing ]. Finally, add the PCVCTRegistry by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> registry add https://github.com/drbergman/PCVCTRegistry","category":"page"},{"location":"man/getting_started/#Install-pcvct-2","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Still in the Pkg REPL, run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> add pcvct","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Troubleshoot: If this fails, it may be because the General registry is not set up correctly. The output of ] registry status should show the PCVCTRegistry and General registry. If it does not, you can add the General registry by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> registry add General","category":"page"},{"location":"man/getting_started/#Set-up-a-pcvct-project","page":"Getting started","title":"Set up a pcvct project","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Leave the Pkg REPL by pressing the delete or backspace key (if still in it from the previous step). Load the pcvct module by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using pcvct","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Then, create a new project by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> createProject(path_to_project_folder) # createProject() will use the current directory as the project folder","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This creates three folders inside the path_to_project_folder folder: data/, PhysiCell/, and VCT/. See Data directory structure for information about the data/ folder.","category":"page"},{"location":"man/getting_started/#(Optional)-Import-from-user_projects","page":"Getting started","title":"(Optional) Import from user_projects","text":"","category":"section"},{"location":"man/getting_started/#Inputs","page":"Getting started","title":"Inputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you have a project in the PhysiCell/user_projects/ folder that you would like to import, you can do so by running importProject:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder)","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The path_to_project_folder string can be either the absolute path (recommended) or the relative path (from the directory julia was launched) to the project folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: This function assumes your project files are in the standard PhysiCell/user_projects/ format. See the table below for the standard locations of the files. Note the Default location column shows the path relative to path_to_project_folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Input Default location Key Optional\nconfig config/PhysiCell_settings.xml config \nmain main.cpp main \nMakefile Makefile makefile \ncustom modules custom_modules/ custom_modules \nrules config/cell_rules.csv rules X\ncell initial conditions config/cells.csv ic_cell X\nsubstrate initial conditions config/substrates.csv ic_substrate X","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If any of these files are not located in the standard location, you can define a dictionary with keys taken from the table above to specify the location of each file. For example, if the config file is instead located at PhysiCell/user_projects/[project_name]/config/config.xml, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> src = Dict(\"config\" => \"config/config.xml\")","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Additional entries can be added in a comma-separated list into Dict or added later with src[key] = rel_path. Pass the dictionary in as the second argument as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder, src)","category":"page"},{"location":"man/getting_started/#Outputs","page":"Getting started","title":"Outputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you use this option, then the GenerateData.jl script must be updated to reflect the new project folders. By default, the folder names are taken from the name of the project with an integer appended if it already exists. If you want to use a different name, you can pass ","category":"page"},{"location":"man/getting_started/#Running-first-trial","page":"Getting started","title":"Running first trial","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The createProject() command creates three folder, including a VCT folder with a single file: VCT/GenerateData.jl. The name of this folder and this file are purely convention, change them as you like. To run your first pcvct trial, you can run the GenerateData.jl script from the shell:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: if you want to parallelize these 9 runs, you can set the shell environment variable PCVCT_NUM_PARALLEL_SIMS to the number of parallel simulations you want to run. For example, to run 9 parallel simulations, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ export PCVCT_NUM_PARALLEL_SIMS=9\n$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Or for a one-off solution:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ PCVCT_NUM_PARALLEL_SIMS=9 julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Alternatively, you can run the script via the REPL.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Run the script a second time and observe that no new simulations are run. This is because pcvct looks for matching simulations first before running new ones. The use_previous optional keyword argument can control this behavior if new simulations are desired.","category":"page"}]
}
