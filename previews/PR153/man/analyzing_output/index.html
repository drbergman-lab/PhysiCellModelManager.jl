<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analyzing output · PhysiCellModelManager.jl</title><meta name="title" content="Analyzing output · PhysiCellModelManager.jl"/><meta property="og:title" content="Analyzing output · PhysiCellModelManager.jl"/><meta property="twitter:title" content="Analyzing output · PhysiCellModelManager.jl"/><meta name="description" content="Documentation for PhysiCellModelManager.jl."/><meta property="og:description" content="Documentation for PhysiCellModelManager.jl."/><meta property="twitter:description" content="Documentation for PhysiCellModelManager.jl."/><meta property="og:url" content="https://drbergman-lab.github.io/PhysiCellModelManager.jl/man/analyzing_output/"/><meta property="twitter:url" content="https://drbergman-lab.github.io/PhysiCellModelManager.jl/man/analyzing_output/"/><link rel="canonical" href="https://drbergman-lab.github.io/PhysiCellModelManager.jl/man/analyzing_output/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhysiCellModelManager.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../best_practices/">Best practices</a></li><li><a class="tocitem" href="../getting_started/">Getting started</a></li><li><a class="tocitem" href="../varying_parameters/">Varying parameters</a></li><li><a class="tocitem" href="../xml_path_helpers/">XML path helpers</a></li><li><a class="tocitem" href="../covariations/">CoVariations</a></li><li><a class="tocitem" href="../data_directory/">Data directory</a></li><li><a class="tocitem" href="../intracellular_inputs/">Intracellular inputs</a></li><li><a class="tocitem" href="../known_limitations/">Known limitations</a></li><li><a class="tocitem" href="../physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../sensitivity_analysis/">Sensitivity analysis</a></li><li class="is-active"><a class="tocitem" href>Analyzing output</a><ul class="internal"><li><a class="tocitem" href="#Install-dependencies"><span>Install dependencies</span></a></li><li><a class="tocitem" href="#Loading-output"><span>Loading output</span></a></li><li><a class="tocitem" href="#Population-plots"><span>Population plots</span></a></li><li><a class="tocitem" href="#Substrate-analysis"><span>Substrate analysis</span></a></li><li><a class="tocitem" href="#Motility-analysis"><span>Motility analysis</span></a></li><li><a class="tocitem" href="#Pair-correlation-function-(PCF)"><span>Pair correlation function (PCF)</span></a></li><li><a class="tocitem" href="#Graph-analysis"><span>Graph analysis</span></a></li></ul></li><li><a class="tocitem" href="../developer_guide/">Developer guide</a></li><li><a class="tocitem" href="../project_configuration/">Project configuration</a></li><li><a class="tocitem" href="../">Index</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../../lib/PhysiCellModelManager/">Core</a></li><li><a class="tocitem" href="../../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../../lib/classes/">Classes</a></li><li><a class="tocitem" href="../../lib/compilation/">Compilation</a></li><li><a class="tocitem" href="../../lib/components/">Components</a></li><li><a class="tocitem" href="../../lib/configuration/">Configuration</a></li><li><a class="tocitem" href="../../lib/creation/">Creation</a></li><li><a class="tocitem" href="../../lib/database/">Database</a></li><li><a class="tocitem" href="../../lib/deletion/">Deletion</a></li><li><a class="tocitem" href="../../lib/deprecate_keywords/">Deprecate Keywords</a></li><li><a class="tocitem" href="../../lib/export/">Export</a></li><li><a class="tocitem" href="../../lib/globals/">Globals</a></li><li><a class="tocitem" href="../../lib/hpc/">HPC</a></li><li><a class="tocitem" href="../../lib/ic_cell/">Cell Initial Conditions</a></li><li><a class="tocitem" href="../../lib/ic_ecm/">ECM Initial Conditions</a></li><li><a class="tocitem" href="../../lib/import/">Import</a></li><li><a class="tocitem" href="../../lib/loader/">Loader</a></li><li><a class="tocitem" href="../../lib/movie/">Movie</a></li><li><a class="tocitem" href="../../lib/pcmm_version/">PhysiCellModelManager.jl Version</a></li><li><a class="tocitem" href="../../lib/physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../../lib/physicell_version/">PhysiCell Version</a></li><li><a class="tocitem" href="../../lib/pruner/">Pruner</a></li><li><a class="tocitem" href="../../lib/recorder/">Recorder</a></li><li><a class="tocitem" href="../../lib/runner/">Runner</a></li><li><a class="tocitem" href="../../lib/sensitivity/">Sensitivity</a></li><li><a class="tocitem" href="../../lib/up/">PhysiCellModelManager.jl Upgrade</a></li><li><a class="tocitem" href="../../lib/user_api/">User API</a></li><li><a class="tocitem" href="../../lib/variations/">Variations</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../../misc/database_upgrades/">Database upgrades</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Analyzing output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analyzing output</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/main/docs/src/man/analyzing_output.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Analyzing-output"><a class="docs-heading-anchor" href="#Analyzing-output">Analyzing output</a><a id="Analyzing-output-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-output" title="Permalink"></a></h1><h2 id="Install-dependencies"><a class="docs-heading-anchor" href="#Install-dependencies">Install dependencies</a><a id="Install-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Install-dependencies" title="Permalink"></a></h2><p>Julia has several packages for plotting. Here, we will use <code>Plots.jl</code> which you can install with</p><pre><code class="language-julia-repl hljs">pkg&gt; add Plots</code></pre><h2 id="Loading-output"><a class="docs-heading-anchor" href="#Loading-output">Loading output</a><a id="Loading-output-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-output" title="Permalink"></a></h2><h3 id="PhysiCellSnapshot"><a class="docs-heading-anchor" href="#PhysiCellSnapshot"><code>PhysiCellSnapshot</code></a><a id="PhysiCellSnapshot-1"></a><a class="docs-heading-anchor-permalink" href="#PhysiCellSnapshot" title="Permalink"></a></h3><p>The base unit of PhysiCell output is the <code>PhysiCellSnapshot</code>. These are currently considered PhysiCellModelManager.jl internals and so the API may change. Each snapshot records the path to the PhysiCell output folder, its index in the sequence of outputs, the time of the snapshot in the simulation, and optionally the cell, substrate, and mesh data at that snapshot.</p><h3 id="PhysiCellSequence"><a class="docs-heading-anchor" href="#PhysiCellSequence"><code>PhysiCellSequence</code></a><a id="PhysiCellSequence-1"></a><a class="docs-heading-anchor-permalink" href="#PhysiCellSequence" title="Permalink"></a></h3><p>A <code>PhysiCellSequence</code> is the full sequence of snapshots corresponding to a single PhysiCell simulation. As with <code>PhysiCellSnapshot</code>&#39;s, these are currently considered internals and their API may change. In addition to the path to the PhysiCell output folder and the vector of <code>PhysiCellSnapshot</code>&#39;s, it holds metadata for the simulation.</p><h3 id="cellDataSequence"><a class="docs-heading-anchor" href="#cellDataSequence"><code>cellDataSequence</code></a><a id="cellDataSequence-1"></a><a class="docs-heading-anchor-permalink" href="#cellDataSequence" title="Permalink"></a></h3><p>The main function to get sequences of cell data is <code>cellDataSequence</code>. It accepts any of a simulation ID (<code>&lt;:Integer</code>), a simulation (<code>::Simulation</code>), or a sequence (<code>::PhysiCellSequence</code>) and either a single label (<code>::String</code>) or a vector of labels (<code>::Vector{String}</code>). For each cell in the simulation (as determined by the cell ID), the output creates a dictionary entry (the key is the integer cell ID) whose value is a named tuple with the input labels as keys as well as <code>:time</code>. This means that if one sets</p><pre><code class="language-julia hljs">data = cellDataSequence(1, &quot;position&quot;)</code></pre><p>Then one can access the positions of the cell with ID 78 by</p><pre><code class="language-julia hljs">cell_78_positions = data[78].position # an Nx3 matrix for the N integer-indexed outputs (ignores the `initial_*` and `final_*` files)</code></pre><p>and plot the x-coordinates of this cell over time using</p><pre><code class="language-julia hljs">cell_78_times = data[78].time

using Plots
plot(cell_78_times, cell_78_positions[:,1])</code></pre><p><strong>Note</strong>: Each call to <code>cellDataSequence</code> will load <em>all</em> the data unless a <code>PhysiCellSequence</code> is passed in. Plan your analyses accordingly as loading simulation data is not fast.</p><h2 id="Population-plots"><a class="docs-heading-anchor" href="#Population-plots">Population plots</a><a id="Population-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Population-plots" title="Permalink"></a></h2><h3 id="Group-by-Monad"><a class="docs-heading-anchor" href="#Group-by-Monad">Group by Monad</a><a id="Group-by-Monad-1"></a><a class="docs-heading-anchor-permalink" href="#Group-by-Monad" title="Permalink"></a></h3><p>Plotting population plots is one the most basic analysis tasks and PhysiCellModelManager.jl makes it super easy! If you call <code>plot</code> on a <code>Simulation</code>, <code>Monad</code>, <code>Sampling</code>, or the return value of a call to <code>run</code> (though not for a sensitivity analysis), then a sequence of panels will be generated in a single figure. Each panel will correspond to a <code>Monad</code> (replicates using the same parameter values) and will plot mean +/- SD for each cell type.</p><p>Finer-grained control of the output is possible, too!</p><ul><li>to include dead cells in your counts: <code>plot(...; ..., include_dead=true, ...)</code></li><li>select a subset of cell types to include: <code>plot(...; ..., include_cell_type_names=&quot;cancer&quot;, ...)</code></li><li>select a subset of cell types to exclude: <code>plot(...; ..., exclude_cell_type_names=&quot;cancer&quot;, ...)</code></li><li>choose time units for the x-axis: <code>plot(...; ..., time_unit=:h, ...)</code></li></ul><p>The <code>include_cell_type_names</code> and <code>exclude_cell_type_names</code> can also accept a <code>Vector{String}</code> to include or exclude certain cell types, respectively. Furthermore, if the value of <code>include_cell_type_names</code> is a <code>Vector</code> and one of its entries is a <code>Vector{String}</code>, PhysiCellModelManager.jl will interpret this to sum up those cell types. In other words, to get the total tumor cell count in addition to the epithelial (<code>&quot;epi&quot;</code>) and mesenchymal (<code>&quot;mes&quot;</code>) components, you could use</p><pre><code class="language-julia hljs">using Plots
plot(Monad(1); include_cell_type_names=[&quot;epi&quot;, &quot;mes&quot;, [&quot;epi&quot;, &quot;mes&quot;]])</code></pre><p>Finally, this makes use of Julia&#39;s Plot Recipes (see <a href="https://docs.juliaplots.org/stable/RecipesBase/">RecipesBase.jl</a>) so any standard plotting keywords can be passed in:</p><pre><code class="language-julia hljs">using Plots
colors = [:blue :red] # Note the absence of a `,` or `;`. This is how Julia requires different series parameters to be passed in 
plot(Simulation(1); color=colors, include_cell_type_names=[&quot;cd8&quot;, &quot;cancer&quot;]) # will plot cd8s in blue and cancer in red.</code></pre><h3 id="Group-by-cell-type"><a class="docs-heading-anchor" href="#Group-by-cell-type">Group by cell type</a><a id="Group-by-cell-type-1"></a><a class="docs-heading-anchor-permalink" href="#Group-by-cell-type" title="Permalink"></a></h3><p>Invert the above by including all data for a single cell type across all monads in a single panel with a call to <code>plotbycelltype</code>. This function works on any <code>T&lt;:AbstractTrial</code> (<code>Simulation</code>, <code>Monad</code>, <code>Sampling</code>, or <code>Trial</code>) as well as any <code>PCMMOutput</code> object (the return value to <code>run</code>). Everything above for <code>plot</code> applies here.</p><pre><code class="language-julia hljs">using Plots
plotbycelltype(Sampling(1); include_cell_type_names=[&quot;epi&quot;, &quot;mes&quot;, [&quot;epi&quot;, &quot;mes&quot;]], color=[:blue :red :purple], labels=[&quot;epi&quot; &quot;mes&quot; &quot;both&quot;], legend=true)</code></pre><h2 id="Substrate-analysis"><a class="docs-heading-anchor" href="#Substrate-analysis">Substrate analysis</a><a id="Substrate-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Substrate-analysis" title="Permalink"></a></h2><p>PhysiCellModelManager.jl supports two ways to summarize substrate information over time.</p><h3 id="AverageSubstrateTimeSeries"><a class="docs-heading-anchor" href="#AverageSubstrateTimeSeries"><code>AverageSubstrateTimeSeries</code></a><a id="AverageSubstrateTimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#AverageSubstrateTimeSeries" title="Permalink"></a></h3><p>An <code>AverageSubstrateTimeSeries</code> gives the time series for the average substrate across the entire domain.</p><pre><code class="language-julia hljs">simulation_id = 1
asts = PhysiCellModelManager.AverageSubstrateTimeSeries(simulation_id)
using Plots
plot(asts.time, asts[&quot;oxygen&quot;])</code></pre><h3 id="ExtracellularSubstrateTimeSeries"><a class="docs-heading-anchor" href="#ExtracellularSubstrateTimeSeries"><code>ExtracellularSubstrateTimeSeries</code></a><a id="ExtracellularSubstrateTimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#ExtracellularSubstrateTimeSeries" title="Permalink"></a></h3><p>An <code>ExtracellularSubstrateTimeSeries</code> gives the time series for the average substrate concentration in the extracellular space neighboring all cells of a given cell type. In a simulation with <code>cd8</code> cells and <code>IFNg</code> diffusible substrate, plot the average concentration of IFNg experienced by CD8+ T cells using the following:</p><pre><code class="language-julia hljs">simulation_id = 1
ests = PhysiCellModelManager.ExtracellularSubstrateTimeSeries(simulation_id)
using Plots
plot(ests.time, ests[&quot;cd8&quot;][&quot;IFNg&quot;])</code></pre><h2 id="Motility-analysis"><a class="docs-heading-anchor" href="#Motility-analysis">Motility analysis</a><a id="Motility-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Motility-analysis" title="Permalink"></a></h2><p>The <code>motilityStatistics</code> function returns the time alive, distance traveled, and mean speed for each cell in the simulation. For each cell, these values are split amongst the cell types the given cell assumed throughout (or at least at the save times). To calculate these values, the cell type at the start of the save interval is used and the net displacement is used to calculate the speed. Optionally, users can pass in a coordinate direction to only consider speed in a given axis.</p><pre><code class="language-julia hljs">simulation_id = 1
mss = motilityStatistics(simulation_id)
all_mean_speeds_as_mes = [ms[&quot;mes&quot;].speed for ms in mss if haskey(ms, &quot;mes&quot;)] # concatenate all speeds as a &quot;mes&quot; cell type (if the given cell ever was a &quot;mes&quot;)
all_times_as_mes = [ms[&quot;mes&quot;].time for ms in mss if haskey(ms, &quot;mes&quot;)] # similarly, get the time spent in the &quot;mes&quot; state
mean_mes_speed = all_mean_speeds_as_mes .* all_times_as_mes |&gt; sum # start computing the weighted average of their speeds
mean_mes_speed /= sum(all_times_as_mes) # finish computing weighted average</code></pre><pre><code class="language-julia hljs">mss = motilityStatistics(simulation_id; direction=:x) # only consider the movement in the x direction</code></pre><h2 id="Pair-correlation-function-(PCF)"><a class="docs-heading-anchor" href="#Pair-correlation-function-(PCF)">Pair correlation function (PCF)</a><a id="Pair-correlation-function-(PCF)-1"></a><a class="docs-heading-anchor-permalink" href="#Pair-correlation-function-(PCF)" title="Permalink"></a></h2><p>Sometimes referred to as radial distribution functions, the pair correlation function (PCF) computes the density of target cells around center cells. If the two sets of cells are the same (centers = targets), this is called PCF. If the two are not equal, this is sometimes called cross-PCF. Both can be computed with a call to <code>PhysiCellModelManager.pcf</code> (or just <code>pcf</code> if <code>using PairCorrelationFunction</code> has been called).</p><h3 id="Arguments"><a class="docs-heading-anchor" href="#Arguments">Arguments</a><a id="Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Arguments" title="Permalink"></a></h3><p>PCF computations can readily be called on <code>PhysiCellSnapshot</code>&#39;s, <code>PhysiCellSequence</code>&#39;s, or <code>Simulation</code>&#39;s. If the first argument in a call to <code>pcf</code> is an <code>Integer</code>, this is treated as a simulation ID. If this is followed by an index (of type <code>Integer</code> or value <code>:initial</code> or <code>:final</code>), this is treated as a snapshot; otherwise, it computes the PCF for the entire simulation.</p><p>The next argument is the cell type to use as the center cells as either a <code>String</code> or <code>Vector{String}</code>, representing the name of the cell type(s). If the target cells are different from the center cells, the next argument is the target cell type as either a <code>String</code> or <code>Vector{String}</code>. If omitted, the target cell type is the same as the center cell type and a (non-cross) PCF is computed. The resulting sets of center and target cell types must either be identical or have no overlap.</p><h3 id="Keyword-arguments"><a class="docs-heading-anchor" href="#Keyword-arguments">Keyword arguments</a><a id="Keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-arguments" title="Permalink"></a></h3><p>The following keyword arguments are available:</p><ul><li><code>include_dead::Union{Bool, Tuple{Bool,Bool}} = false</code>: whether to include dead cells in the PCF computation.<ul><li>If <code>true</code>, all cells are included.</li><li>If <code>false</code>, only live cells are included.</li><li>If a tuple, the first value is for the center cells and the second is for the target cells.</li></ul></li><li><code>dr::Float64 = 20.0</code>: the step size for the radial bins in micrometers.</li></ul><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p>The output of <code>pcf</code> is a <code>PCMMPCFResult</code> object which has two fields: <code>time</code> and <code>pcf_result</code>. The <code>time</code> field is always a vector of the time points at which the PCF was computed, even if computing PCF for a single snapshot. The <code>pcf_result</code> is of type <code>PairCorrelationFunction.PCFResult</code> and has two fields: <code>radii</code> and <code>g</code>. The <code>radii</code> is the set of cutoffs used to compute the PCF and <code>g</code> is either a vector or a matrix of the PCF values of size <code>length(radii)-1</code> by <code>length(time)</code>.</p><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><p>An API to make use of the <code>PairCorrelationFunction</code> package plotting interface is available through the <code>plot</code> function. Simply pass in the <code>PCMMPCFResult</code>! You can pass in as many such objects as you like or pass in a <code>Vector{PCMMPCFResult}</code>. In this case, these are interpreted as stochastic realizations of the same PCF and summary statistics are used to plot. See the <code>PairCorrelationFunction</code> documentation for more details.</p><p>The PhysiCellModelManager.jl implementation supports two keyword arguments:</p><ul><li><code>time_unit::Symbol = :min</code>: the time unit to use for the time axis (only relevant if the <code>PCMMPCFResult</code> has more than one time point).<ul><li>The default is <code>:min</code> and the other options are <code>:s</code>, <code>:h</code>, <code>:d</code>, <code>:w</code>, <code>:mo</code>, <code>:y</code>.</li></ul></li><li><code>distance_unit::Symbol = :um</code>: the distance unit to use for the distance axis.<ul><li>The default is <code>:um</code> and the other options are <code>:mm</code> and <code>:cm</code>.</li></ul></li></ul><p>Finally, a keyword argument supported by <code>PairCorrelationFunction</code> is <code>colorscheme</code> which can be used to change the colorscheme of the color map. PhysiCellModelManager.jl overrides the default from <code>PairCorrelationFunction</code> (<code>:tofino</code>) with <code>:cork</code> to use white to represent values near one.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia hljs">simulation_id = 1
result = PhysiCellModelManager.pcf(simulation_id, &quot;cancer&quot;, &quot;cd8&quot;) # using PairCorrelationFunction will obviate the need to prefix with `PhysiCellModelManager`
plot(result) # heatmap of proximity of (living) cd8s to (living) cancer cells throughout simulation 1</code></pre><pre><code class="language-julia hljs">monad = Monad(1) # let&#39;s assume that there are &gt;1 simulations in this monad
results = [PhysiCellModelManager.pcf(simulation_id, :final, &quot;cancer&quot;, &quot;cd8&quot;) for simulation_id in simulationIDs(monad)] # one vector of PCF values for each simulation at the final snapshot
plot(results) # line plot of average PCF values against radius across the monad +/- 1 SD</code></pre><pre><code class="language-julia hljs">monad = Monad(1) # let&#39;s assume that there are &gt;1 simulations in this monad
results = [PhysiCellModelManager.pcf(simulation_id, &quot;cancer&quot;, &quot;cd8&quot;) for simulation_id in simulationIDs(monad)] # one matrix of PCF values for each simulation across all time points
plot(results) # heatmap of average PCF values with time on the x-axis and radius on the y-axis; averages omit NaN values that can occur at higher radii</code></pre><h2 id="Graph-analysis"><a class="docs-heading-anchor" href="#Graph-analysis">Graph analysis</a><a id="Graph-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-analysis" title="Permalink"></a></h2><p>Every PhysiCell simulation produces three different directed graphs at each save time point. For each graph, the vertices are the cell agents and the edges are as follows:</p><ul><li><code>:neighbors</code>: the cells overlap based on their positions and radii</li><li><code>:attachments</code>: manually-defined attachments between cells</li><li><code>:spring_attachments</code>: spring attachments formed automatically using attachment rates</li></ul><p>Each of these graphs is expected to be symmetric, i.e., if cell A is attached to cell B, then cell B is attached to cell A. Nonetheless, PhysiCellModelManager.jl holds the data in a directed graph.</p><p>Currently, PhysiCellModelManager.jl supports computing connected components for any of these graphs using the <a href="../../lib/analysis/#PhysiCellModelManager.connectedComponents"><code>connectedComponents</code></a> function. For an <a href="../../lib/loader/#PhysiCellModelManager.AbstractPhysiCellSequence"><code>PhysiCellModelManager.AbstractPhysiCellSequence</code></a> object, the graphs can be loaded using the <a href="../../lib/loader/#PhysiCellModelManager.loadGraph!-Tuple{PhysiCellSnapshot, Symbol}"><code>loadGraph!</code></a> function for any other analysis.</p><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><p>For all examples that follow, we will assume a <a href="#PhysiCellSnapshot"><code>PhysiCellSnapshot</code></a> object called <code>snapshot</code> has been created, e.g., as follows:</p><pre><code class="language-julia hljs">simulation_id = 1
index = :final
snapshot = PhysiCellSnapshot(simulation_id, index)</code></pre><p>To get a list of the connected components for the <code>:neighbors</code> graph for all living cells in a simulation at the final timepoint, use</p><pre><code class="language-julia hljs">connected_components = connectedComponents(snapshot) # defaults to the :neighbors graph, all cells, and exclude dead cells</code></pre><p>The <code>connected_components</code> object is a <code>Dict</code> with the cell type names in a single vector as the only key with value a vector of vectors. Each element is a vector of the cell IDs belonging to that connected component in the wrapper type <a href="../../lib/loader/#PhysiCellModelManager.AgentID"><code>PhysiCellModelManager.AgentID</code></a>.</p><p>If you want to compute connected components for subsets of cells, pass in a vector of vectors of cell type names (<code>String</code>s) such that each vector corresponds to a subset of cell types.</p><pre><code class="language-julia hljs">subset_1 = [&quot;cd8_active&quot;, &quot;cd8_inactive&quot;]
subset_2 = [&quot;cancer_epi&quot;, &quot;cancer_mes&quot;]
connected_components = connectedComponents(snapshot; include_cell_type_names=[subset_1, subset_2])</code></pre><p>In this case, the <code>connected_components</code> object is a <code>Dict</code> with <code>subset_1</code> and <code>subset_2</code> as the keys (the values stored in them, not the strings <code>&quot;subset_1&quot;</code> and <code>&quot;subset_2&quot;</code>). The value <code>connected_components[subset_1]</code> is a vector of vectors of the cell IDs belonging to each connected component just considering the cells in <code>subset_1</code>. Similarly for <code>subset_2</code>.</p><p>Including dead cells is possible though not recommended. This is because dead cells automatically clear their neighbors and attachments. The optional keyword argument <code>include_dead</code> can be set to <code>true</code> to include dead cells in the graph.</p><pre><code class="language-julia hljs">connected_components = connectedComponents(snapshot; include_dead=true)</code></pre><p>Finally, to combine a single connected component with the dataframe of cell data, the following can be used:</p><pre><code class="language-julia hljs">connected_components = connectedComponents(snapshot)
connected_components_1 = connected_components |&gt; # julia&#39;s pipe operator
                         values |&gt;  # get the value for each key
                         first |&gt; # get the connected components for the first subset of cells (in this case there&#39;s only one subset consisting of all cells)
                         first # get the first connected component for this subset

loadCells!(snapshot) # make sure the cell data is loaded
cells_df = snapshot.cells # this is the cell data

agent_ids = DataFrame(ID=[a.id for a in connected_components_1]) # get the IDs for the agents in the connected component
component_df = rightjoin(cells_df, agent_ids, on=:ID) # join on the agent IDs, keeping only the rows in the connected component</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sensitivity_analysis/">« Sensitivity analysis</a><a class="docs-footer-nextpage" href="../developer_guide/">Developer guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 4 August 2025 22:16">Monday 4 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
