<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · PhysiCellModelManager.jl</title><meta name="title" content="Analysis · PhysiCellModelManager.jl"/><meta property="og:title" content="Analysis · PhysiCellModelManager.jl"/><meta property="twitter:title" content="Analysis · PhysiCellModelManager.jl"/><meta name="description" content="Documentation for PhysiCellModelManager.jl."/><meta property="og:description" content="Documentation for PhysiCellModelManager.jl."/><meta property="twitter:description" content="Documentation for PhysiCellModelManager.jl."/><meta property="og:url" content="https://drbergman-lab.github.io/PhysiCellModelManager.jl/lib/analysis/"/><meta property="twitter:url" content="https://drbergman-lab.github.io/PhysiCellModelManager.jl/lib/analysis/"/><link rel="canonical" href="https://drbergman-lab.github.io/PhysiCellModelManager.jl/lib/analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PhysiCellModelManager.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/best_practices/">Best practices</a></li><li><a class="tocitem" href="../../man/getting_started/">Getting started</a></li><li><a class="tocitem" href="../../man/varying_parameters/">Varying parameters</a></li><li><a class="tocitem" href="../../man/querying_parameters/">Querying parameters</a></li><li><a class="tocitem" href="../../man/xml_path_helpers/">XML path helpers</a></li><li><a class="tocitem" href="../../man/covariations/">CoVariations</a></li><li><a class="tocitem" href="../../man/data_directory/">Data directory</a></li><li><a class="tocitem" href="../../man/intracellular_inputs/">Intracellular inputs</a></li><li><a class="tocitem" href="../../man/known_limitations/">Known limitations</a></li><li><a class="tocitem" href="../../man/physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../../man/sensitivity_analysis/">Sensitivity analysis</a></li><li><a class="tocitem" href="../../man/analyzing_output/">Analyzing output</a></li><li><a class="tocitem" href="../../man/developer_guide/">Developer guide</a></li><li><a class="tocitem" href="../../man/project_configuration/">Project configuration</a></li><li><a class="tocitem" href="../../man/">Index</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../PhysiCellModelManager/">Core</a></li><li class="is-active"><a class="tocitem" href>Analysis</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li></ul></li><li><a class="tocitem" href="../classes/">Classes</a></li><li><a class="tocitem" href="../compilation/">Compilation</a></li><li><a class="tocitem" href="../components/">Components</a></li><li><a class="tocitem" href="../configuration/">Configuration</a></li><li><a class="tocitem" href="../creation/">Creation</a></li><li><a class="tocitem" href="../database/">Database</a></li><li><a class="tocitem" href="../deletion/">Deletion</a></li><li><a class="tocitem" href="../deprecate_keywords/">Deprecate Keywords</a></li><li><a class="tocitem" href="../export/">Export</a></li><li><a class="tocitem" href="../globals/">Globals</a></li><li><a class="tocitem" href="../hpc/">HPC</a></li><li><a class="tocitem" href="../ic_cell/">Cell Initial Conditions</a></li><li><a class="tocitem" href="../ic_ecm/">ECM Initial Conditions</a></li><li><a class="tocitem" href="../import/">Import</a></li><li><a class="tocitem" href="../loader/">Loader</a></li><li><a class="tocitem" href="../movie/">Movie</a></li><li><a class="tocitem" href="../pcmm_version/">PhysiCellModelManager.jl Version</a></li><li><a class="tocitem" href="../physicell_studio/">PhysiCell Studio</a></li><li><a class="tocitem" href="../physicell_version/">PhysiCell Version</a></li><li><a class="tocitem" href="../pruner/">Pruner</a></li><li><a class="tocitem" href="../recorder/">Recorder</a></li><li><a class="tocitem" href="../runner/">Runner</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity</a></li><li><a class="tocitem" href="../up/">PhysiCellModelManager.jl Upgrade</a></li><li><a class="tocitem" href="../user_api/">User API</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../variations/">Variations</a></li></ul></li><li><span class="tocitem">Miscellaneous</span><ul><li><a class="tocitem" href="../../misc/database_upgrades/">Database upgrades</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/main/docs/src/lib/analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><p>Analyze output from a PCMM project. It is anticipated that this will eventually be split off into its own module or even package. Possibly with loader.jl.</p><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><article><details class="docstring"><summary id="PhysiCellModelManager.connectedComponents"><a class="docstring-binding" href="#PhysiCellModelManager.connectedComponents"><code>PhysiCellModelManager.connectedComponents</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">connectedComponents(snapshot::PhysiCellSnapshot, graph=:neighbors; include_cell_type_names=:all_in_one, exclude_cell_type_names::String[], include_dead::Bool=false)
connectedComponents(simulation::Simulation, index, graph; kwargs...)
connectedComponents(pcmm_output::PCMMOutput{Simulation}, args...; kwargs...)</code></pre><p>Find the connected components of a graph in a PhysiCell snapshot.</p><p>The computation can be done on subsets of cells based on their cell types.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to analyze</li><li><code>graph</code>: The graph data to use (default is <code>:neighbors</code>); must be one of <code>:neighbors</code>, <code>:attachments</code>, or <code>:spring_attachments</code>; can also be a string</li><li><code>simulation::Simulation</code>: The simulation object to analyze</li><li><code>index</code>: The index of the snapshot to analyze (can be an integer or a symbol)</li><li><code>pcmm_output::PCMMOutput{Simulation}</code>: The output of a PCMM simulation run to analyze</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_cell_type_names</code>: The cell types to include in the analysis (default is <code>:all_in_one</code>). Full list of options:<ul><li><code>:all</code> - compute connected components for all cell types individually</li><li><code>:all_in_one</code> - compute connected components for all cell types together</li><li><code>&quot;cell_type_1&quot;</code> - compute connected components only for the cells of type <code>cell_type_1</code></li><li><code>[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> separately</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> together</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;], &quot;cell_type_3&quot;]</code> - compute connected components for the cells of type <code>cell_type_1</code> and <code>cell_type_2</code> together, and for the cells of type <code>cell_type_3</code> separately</li></ul></li><li><code>exclude_cell_type_names</code>: The cell types to exclude from the analysis (default is <code>String[]</code>); can be a single string or a vector of strings</li><li><code>include_dead</code>: Whether to include dead cells in the analysis (default is <code>false</code>)</li></ul><p><strong>Returns</strong></p><p>A dictionary in which each key is one of the following:</p><ul><li>cell type name (String)</li><li>list of cell type names (Vector{String})</li><li>list of cell type names followed by the symbol :include_dead (Vector{Any})</li></ul><p>For each key, the value is a list of connected components in the graph. Each component is represented as a vector of vertex labels. As of this writing, the vertex labels are the simple <code>AgentID</code> class that wraps the cell ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/graphs.jl#L8-L44">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.motilityStatistics-Tuple{Integer}"><a class="docstring-binding" href="#PhysiCellModelManager.motilityStatistics-Tuple{Integer}"><code>PhysiCellModelManager.motilityStatistics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">motilityStatistics(simulation_id::Integer[; direction=:any])
motilityStatistics(simulation::Simulation[; direction=:any])
motilityStatistics(pcmm_output::PCMMOutput{Simulation}[; direction=:any])</code></pre><p>Return the mean speed, distance traveled, and time alive for each cell in the simulation, broken down by cell type in the case of cell type transitions.</p><p>The time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first. If the cell transitions to a new cell type during the simulation, the time is counted for each cell type separately. Each cell type taken on by a given cell will be a key in the dictionary returned at that entry.</p><p><strong>Arguments</strong></p><ul><li><code>simulation_id::Integer</code>: The ID of the PhysiCell simulation. A <code>Simulation</code> object can also be passed in.</li><li><code>simulation::Simulation</code>: The simulation object.</li><li><code>pcmm_output::PCMMOutput{Simulation}</code>: The output of a PCMM simulation run.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>direction::Symbol</code>: The direction to compute the mean speed. Can be <code>:x</code>, <code>:y</code>, <code>:z</code>, or <code>:any</code> (default). If <code>:x</code>, for example, the mean speed is calculated using only the x component of the cell&#39;s movement.</li></ul><p><strong>Returns</strong></p><ul><li><code>AgentDict{Dict{String, NamedTuple}}</code>: An <a href="../loader/#PhysiCellModelManager.AgentDict"><code>AgentDict</code></a>, i.e., one entry per cell in the simulation. Each dictionary has keys for each cell type taken on by the cell. The values are NamedTuples with fields <code>:time</code>, <code>:distance</code>, and <code>:speed</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ms = motilityStatistics(1) # an AgentDict{Dict{String, NamedTuple}}, one per cell in the simulation
ms[1][&quot;epithelial&quot;] # NamedTuple with fields :time, :distance, :speed for the cell with ID 1 in the simulation corresponding to its time as an `epithelial` cell
ms[1][&quot;mesenchymal&quot;].time # time spent as a `mesenchymal` cell for the cell with ID 1 in the simulation
ms[1][&quot;mesenchymal&quot;].distance # distance traveled as a `mesenchymal` cell for the cell with ID 1 in the simulation
ms[1][&quot;mesenchymal&quot;].speed # mean speed as a `mesenchymal` cell for the cell with ID 1 in the simulation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/motility.jl#L56-L86">source</a></section></details></article><article><details class="docstring"><summary id="PairCorrelationFunction.pcf"><a class="docstring-binding" href="#PairCorrelationFunction.pcf"><code>PairCorrelationFunction.pcf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pcf(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types=center_cell_types; include_dead::Union{Bool,Tuple{Bool,Bool}}=false, dr::Float64=20.0)
pcf(simulation::Simulation[, index], args...; kwargs...)
pcf(simulation_id::Integer[, index], args...; kwargs...)
pcf(pcmm_output::PCMMOutput{Simulation}[, index], args...; kwargs...)</code></pre><p>Calculate the pair correlation function (PCF) between two sets of cell types in a PhysiCell simulation snapshot or sequence.</p><p>The <code>center_cell_types</code> and <code>target_cell_types</code> can be strings or vectors of strings. This will compute one PCF rather than one for each pair of (center, target) cell types, i.e., all centers are compared to all targets. If omitted, the target<em>cell</em>types will be the same as the center<em>cell</em>types, i.e., not a cross-PCF. The <code>include_dead</code> argument can be a boolean or a tuple of booleans to indicate whether to include the dead centers and/or targets, respectively. The <code>dr</code> argument specifies the bin size (thickness of each annulus) for the PCF calculation.</p><p>In the signatures with an <code>index</code>, if it is provided then a single snapshot is analyzed, otherwise the entire sequence is analyzed. The <code>index</code> must be an integer or either the symbol <code>:initial</code> or <code>:final</code>.</p><p><strong>Arguments</strong></p><ul><li><code>S::AbstractPhysiCellSequence</code>: A <a href="../../man/analyzing_output/#PhysiCellSnapshot"><code>PhysiCellSnapshot</code></a> or <a href="../../man/analyzing_output/#PhysiCellSequence"><code>PhysiCellSequence</code></a> object.</li><li><code>center_cell_types</code>: The cell type name(s) to use as the center of the PCF.</li><li><code>target_cell_types</code>: The cell type name(s) to use as the target of the PCF.</li><li><code>simulation::Simulation</code>: The simulation object.</li><li><code>simulation_id::Integer</code>: The ID of the PhysiCell simulation.</li><li><code>pcmm_output::PCMMOutput{Simulation}</code>: The output of a PCMM simulation run.</li><li><code>index::Union{Integer, Symbol}</code>: The index of the snapshot to analyze (can be an integer or the symbol <code>:initial</code> or <code>:final</code>).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Union{Bool,Tuple{Bool,Bool}}</code>: Whether to include dead cells in the PCF calculation. If a tuple, the first element indicates whether to include dead centers and the second element indicates whether to include dead targets.</li><li><code>dr::Float64</code>: The bin size for the PCF calculation.</li></ul><p><strong>Alternate methods</strong></p><ul><li><code>pcf(simulation::Simulation, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for a specific snapshot in a simulation.</li><li><code>pcf(simulation_id::Integer, index::Union{Integer, Symbol}, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for a specific snapshot in a simulation by ID.</li><li><code>pcf(simulation_id::Integer, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for all snapshots in a simulation by ID.</li><li><code>pcf(simulation::Simulation, center_cell_types, target_cell_types=center_cell_types; kwargs...)</code>: Calculate the PCF for all snapshots in a simulation.</li></ul><p><strong>Returns</strong></p><p>A <a href="#PhysiCellModelManager.PCMMPCFResult"><code>PCMMPCFResult</code></a> object containing the time, radii, and g values of the PCF. Regardless of the type of <code>S</code>, the time and radii will always be vectors. If <code>S</code> is a snapshot, the g values will be a vector of the PCF. If <code>S</code> is a sequence, the g values will be a (length(radii)-1 x length(time)) matrix of the PCF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L87-L128">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.finalPopulationCount-Tuple{Int64}"><a class="docstring-binding" href="#PhysiCellModelManager.finalPopulationCount-Tuple{Int64}"><code>PhysiCellModelManager.finalPopulationCount</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])</code></pre><p>Return the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.</p><p>Also works with the simulation ID:</p><pre><code class="language-julia hljs">fpc = finalPopulationCount(1)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">fpc = finalPopulationCount(simulation)
final_default_count = fpc[&quot;default&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L156-L171">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.plotbycelltype"><a class="docstring-binding" href="#PhysiCellModelManager.plotbycelltype"><code>PhysiCellModelManager.plotbycelltype</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">plotbycelltype(T::AbstractTrial; include_dead::Bool=false, include_cell_type_names=:all, exclude_cell_type_names=String[], time_unit=:min)</code></pre><p>Plot the population time series of a trial by cell type.</p><p>Each cell type gets its own subplot. Each monad gets its own series within each subplot.</p><p><strong>Arguments</strong></p><ul><li><code>T::AbstractTrial</code>: The trial to plot.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Bool</code>: Whether to include dead cells in the count. Default is <code>false</code>.</li><li><code>include_cell_type_names::Vector{String}</code>: A vector of cell type names to include in the plot. Default is <code>:all</code>, which includes all cell types in separate plots.</li><li><code>exclude_cell_type_names::Vector{String}</code>: A vector of cell type names to exclude from the plot. Default is an empty vector, i.e., no cell types are excluded.</li><li><code>time_unit::Symbol</code>: The time unit to use for the x-axis. Default is <code>:min</code>, which uses minutes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L392-L408">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.populationCount"><a class="docstring-binding" href="#PhysiCellModelManager.populationCount"><code>PhysiCellModelManager.populationCount</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">populationCount(snapshot, cell_type_to_name_dict::Dict{Int,String}=Dict{Int,String}(), labels::Vector{String}=String[]; include_dead::Bool=false)</code></pre><p>Return the population count of a snapshot as a dictionary with cell type names as keys and their counts as values.</p><p>If the snapshot is missing, it will return missing. This helps in cases where the files have been deleted, for example by pruning.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to count the cells in.</li><li><code>cell_type_to_name_dict::Dict{Int,String}</code>: A dictionary mapping cell type IDs to names (default is an empty dictionary). If not provided, it is read from the snapshot files.</li><li><code>labels::Vector{String}</code>: The labels to identify the cell data. If not provided, it is read from the snapshot files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Bool</code>: Whether to include dead cells in the count. Default is <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L5-L20">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.populationTimeSeries-Tuple{PhysiCellModelManager.AbstractMonad}"><a class="docstring-binding" href="#PhysiCellModelManager.populationTimeSeries-Tuple{PhysiCellModelManager.AbstractMonad}"><code>PhysiCellModelManager.populationTimeSeries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])
populationTimeSeries(pcmm_output::PCMMOutput{&lt;:AbstractMonad}[; include_dead::Bool=false])</code></pre><p>Return the population time series of a simulation or a monad.</p><p>See <code>SimulationPopulationTimeSeries</code> and <code>MonadPopulationTimeSeries</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L265-L272">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.simulationRuntimeIntervals-Tuple{PhysiCellSequence}"><a class="docstring-binding" href="#PhysiCellModelManager.simulationRuntimeIntervals-Tuple{PhysiCellSequence}"><code>PhysiCellModelManager.simulationRuntimeIntervals</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulationRuntimeIntervals(sequence::PhysiCellSequence)
simulationRuntimeIntervals(simulation::Simulation)
simulationRuntimeIntervals(pcmm_output::PCMMOutput{Simulation})
simulationRuntimeIntervals(simulation_id::Integer)</code></pre><p>Get the runtime intervals of a simulation.</p><p><strong>Returns</strong></p><p>A named tuple with the time and runtime vectors. Each entry corresponds to the amount of runtime to simulate from the previous snapshot to the current snapshot.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">seq = simulationRuntimeIntervals(1)
using Plots
plot(seq.time, seq.runtime) # plot time from previous save time vs time
plot(seq.time, cumsum(seq.runtime)) # plot time vs cumulative runtime (same as plotting against the runtime values of each snapshot)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/runtime.jl#L38-L57">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.AverageSubstrateTimeSeries"><a class="docstring-binding" href="#PhysiCellModelManager.AverageSubstrateTimeSeries"><code>PhysiCellModelManager.AverageSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AverageSubstrateTimeSeries</code></pre><p>A struct to hold the average substrate concentrations over time for a PhysiCell simulation.</p><p>Constructed using <code>AverageSubstrateTimeSeries(x)</code> where <code>x</code> is any of the following: <code>Integer</code> (simulation ID), <code>PhysiCellSequence</code>, or <code>Simulation</code>.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>substrate_concentrations::Dict{String, Vector{Real}}</code>: A dictionary mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">asts = PhysiCellModelManager.AverageSubstrateTimeSeries(1) # Load average substrate time series for Simulation 1
asts.time # Get the time points
asts[&quot;time&quot;] # alternative way to get the time points
asts[&quot;oxygen&quot;] # Get the oxygen concentration over time</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L63-L82">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.ExtracellularSubstrateTimeSeries"><a class="docstring-binding" href="#PhysiCellModelManager.ExtracellularSubstrateTimeSeries"><code>PhysiCellModelManager.ExtracellularSubstrateTimeSeries</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExtracellularSubstrateTimeSeries</code></pre><p>A struct to hold the mean extracellular substrate concentrations per cell type over time for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the PhysiCell simulation.</li><li><code>time::Vector{Real}</code>: The time points at which the snapshots were taken.</li><li><code>data::Dict{String, Dict{String, Vector{Real}}}</code>: A dictionary mapping cell type names to dictionaries mapping substrate names to vectors of their average concentrations over time.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">ests = PhysiCellModelManager.ExtracellularSubstrateTimeSeries(1) # Load extracellular substrate time series for Simulation 1
ests.time # Get the time points
ests[&quot;cancer&quot;][&quot;oxygen&quot;] # Get the oxygen concentration over time for the cancer cell type

ests = PhysiCellModelManager.ExtracellularSubstrateTimeSeries(simulation; include_dead=true) # Load extracellular substrate time series for a Simulation object, including dead cells
ests[&quot;time&quot;] # Alternate way to get the time points
ests[&quot;cd8&quot;][&quot;IFNg&quot;] # Get the interferon gamma concentration over time for the CD8 cell type

ests = PhysiCellModelManager.ExtracellularSubstrateTimeSeries(sequence) # Load extracellular substrate time series for a PhysiCellSequence object</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L223-L245">source</a></section></details></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><article><details class="docstring"><summary id="PhysiCellModelManager._connectedComponents-Tuple{MetaGraphsNext.MetaGraph}"><a class="docstring-binding" href="#PhysiCellModelManager._connectedComponents-Tuple{MetaGraphsNext.MetaGraph}"><code>PhysiCellModelManager._connectedComponents</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_connectedComponents(G::MetaGraph)</code></pre><p>Find the connected components of a graph.</p><p>First compute the transitive closure of the underlying <code>Graphs.Graph</code> object. Then, update the edge data of the <code>MetaGraph</code> object to reflect the new edges. Finally, loop over vertex labels and find the vertices they are connected to until all vertices are accounted for. Returns a list of connected components, where each component is represented as a vector of vertex labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/graphs.jl#L119-L128">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager._motilityStatistics-Tuple{Any}"><a class="docstring-binding" href="#PhysiCellModelManager._motilityStatistics-Tuple{Any}"><code>PhysiCellModelManager._motilityStatistics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_motilityStatistics(p[; direction=:any])</code></pre><p>Compute the motility statistics for a single cell in the PhysiCell simulation.</p><p>Accounts for cell type transitions and computes the distance traveled, time spent, and mean speed for each cell type the given cell has taken on during the simulation. The speed can be restricted to a specific direction (x, y, z) or calculated in any direction. In either case, the distance is unsigned.</p><p>This function is used internally by <a href="#PhysiCellModelManager.motilityStatistics-Tuple{Integer}"><code>motilityStatistics</code></a>.</p><p><strong>Returns</strong></p><p>A <code>Dict{String, NamedTuple}</code> where each key is a cell type name visited by the cell and the value is a <code>NamedTuple</code> with fields <code>:time</code>, <code>:distance</code>, and <code>:speed</code>. The values in this named tuple are the time, distance traveled, and mean speed for the cell in that cell type, i.e., all scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/motility.jl#L3-L17">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.PCMMPCFResult"><a class="docstring-binding" href="#PhysiCellModelManager.PCMMPCFResult"><code>PhysiCellModelManager.PCMMPCFResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PCMMPCFResult</code></pre><p>A struct to hold the results of the pair correlation function (PCF) calculation.</p><p>The start and end radii for each annulus are stored in the <code>radii</code> field. Thus, there is one more radius than there are annuli, i.e. <code>length(radii) == size(g, 1) + 1</code>. Each column of <code>g</code> corresponds to a time point in the <code>time</code> field, hence <code>size(g, 2) == length(time)</code>.</p><p><strong>Fields</strong></p><ul><li><code>time::Vector{Float64}</code>: The time points at which the PCF was calculated.</li><li><code>pcf_result::PairCorrelationFunction.PCFResult</code>: The result of the PCF calculation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PairCorrelationFunction
time = 12.0
radii = [0.0, 1.0, 2.0]
g = [0.5, 1.2]
PhysiCellModelManager.PCMMPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCMMPCFResult:
  Time: 12.0
  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0
  g: 0.5 - 1.2 (min - max)</code></pre><pre><code class="language-julia hljs">using PairCorrelationFunction
time = [12.0; 24.0; 36.0]
radii = [0.0, 1.0, 2.0]
g = [0.5 0.6 0.4; 1.2 1.15 1.4]
PhysiCellModelManager.PCMMPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))
# output
PCMMPCFResult:
  Time: 12.0 - 36.0 (n = 3)
  Radii: 0.0 - 2.0 with 2 annuli, Δr = 1.0
  g: 0.4 - 1.4 (min - max)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L7-L45">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.cellPositionsForPCF-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, Int64}, Bool, Bool}"><a class="docstring-binding" href="#PhysiCellModelManager.cellPositionsForPCF-Tuple{DataFrames.DataFrame, Vector{String}, Dict{String, Int64}, Bool, Bool}"><code>PhysiCellModelManager.cellPositionsForPCF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cellPositionsForPCF(cells::DataFrame, cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Bool, is_3d::Bool)</code></pre><p>Get the positions of the cells for the PCF calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L248-L252">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.isCrossPCF-Tuple{Vector{String}, Vector{String}}"><a class="docstring-binding" href="#PhysiCellModelManager.isCrossPCF-Tuple{Vector{String}, Vector{String}}"><code>PhysiCellModelManager.isCrossPCF</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isCrossPCF(center_cell_types::Vector{String}, target_cell_types::Vector{String})</code></pre><p>Check if the center and target cell types are the same (PCF) or disjoint (cross-PCF); if neither, throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L231-L235">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.pcfConstants-Tuple{PhysiCellSnapshot, Float64}"><a class="docstring-binding" href="#PhysiCellModelManager.pcfConstants-Tuple{PhysiCellSnapshot, Float64}"><code>PhysiCellModelManager.pcfConstants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pcfConstants(S::AbstractPhysiCellSequence, dr::Float64)</code></pre><p>Create a <code>Constants</code> object for the PCF calculation based on the mesh of the snapshot or sequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L174-L178">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.pcfSnapshotCalculation-Tuple{PhysiCellSnapshot, Vector{String}, Vector{String}, Dict{String, Int64}, Union{Bool, Tuple{Bool, Bool}}, Bool, PairCorrelationFunction.Constants}"><a class="docstring-binding" href="#PhysiCellModelManager.pcfSnapshotCalculation-Tuple{PhysiCellSnapshot, Vector{String}, Vector{String}, Dict{String, Int64}, Union{Bool, Tuple{Bool, Bool}}, Bool, PairCorrelationFunction.Constants}"><code>PhysiCellModelManager.pcfSnapshotCalculation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pcfSnapshotCalculation(snapshot::PhysiCellSnapshot, center_cell_types::Vector{String}, target_cell_types::Vector{String}, cell_name_to_type_dict::Dict{String,Int}, include_dead::Union{Bool,Tuple{Bool,Bool}}, is_cross_pcf::Bool, constants::Constants)</code></pre><p>Calculate the pair correlation function (PCF) for a given snapshot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L199-L203">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.preparePCF!-Tuple{PhysiCellModelManager.AbstractPhysiCellSequence, Any, Any, Union{Bool, Tuple{Bool, Bool}}, Float64}"><a class="docstring-binding" href="#PhysiCellModelManager.preparePCF!-Tuple{PhysiCellModelManager.AbstractPhysiCellSequence, Any, Any, Union{Bool, Tuple{Bool, Bool}}, Float64}"><code>PhysiCellModelManager.preparePCF!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">preparePCF!(S::AbstractPhysiCellSequence, center_cell_types, target_cell_types, include_dead::Union{Bool,Tuple{Bool,Bool}}, dr::Float64)</code></pre><p>Prepare the arguments for the PCF calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L155-L159">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.preparePCFPlot-Tuple{Vector{PhysiCellModelManager.PCMMPCFResult}}"><a class="docstring-binding" href="#PhysiCellModelManager.preparePCFPlot-Tuple{Vector{PhysiCellModelManager.PCMMPCFResult}}"><code>PhysiCellModelManager.preparePCFPlot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">preparePCFPlot(results::Vector{PCMMPCFResult}; time_unit=:min, distance_unit=:um)</code></pre><p>Prepare the time and radii for the PCF plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L283-L287">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.processDistance-Tuple{Any, Any}"><a class="docstring-binding" href="#PhysiCellModelManager.processDistance-Tuple{Any, Any}"><code>PhysiCellModelManager.processDistance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processDistance(distance::Vector{Float64}, distance_unit::Symbol)</code></pre><p>Process the distance vector to convert it to the desired distance unit. Options are :um, :mm, and :cm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L322-L327">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.processPCFCellTypes-Tuple{Any}"><a class="docstring-binding" href="#PhysiCellModelManager.processPCFCellTypes-Tuple{Any}"><code>PhysiCellModelManager.processPCFCellTypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processPCFCellTypes(cell_types)</code></pre><p>Process the cell types for the PCF calculation so that they are always a vector of strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L217-L221">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.processTime-Tuple{Any, Any}"><a class="docstring-binding" href="#PhysiCellModelManager.processTime-Tuple{Any, Any}"><code>PhysiCellModelManager.processTime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processTime(time::Vector{Float64}, time_unit::Symbol)</code></pre><p>Process the time vector to convert it to the desired time unit. Options are :min, :s, :h, :d, :w, :mo, and :y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/pcf.jl#L295-L300">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.AbstractPopulationTimeSeries"><a class="docstring-binding" href="#PhysiCellModelManager.AbstractPopulationTimeSeries"><code>PhysiCellModelManager.AbstractPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPopulationTimeSeries</code></pre><p>Abstract type representing a population time series for either a simulation or a monad.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L41-L45">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.MonadPopulationTimeSeries"><a class="docstring-binding" href="#PhysiCellModelManager.MonadPopulationTimeSeries"><code>PhysiCellModelManager.MonadPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MonadPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a monad&#39;s population time series.</p><p>Note: unlike <code>SimulationPopulationTimeSeries</code>, this type does not save the data to a file.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mpts = MonadPopulationTimeSeries(1)
mpts = MonadPopulationTimeSeries(Monad(1))</code></pre><p><strong>Fields</strong></p><ul><li><code>monad_id::Int</code>: The ID of the monad.</li><li><code>monad_length::Int</code>: The number of simulations in the monad.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, NamedTuple}</code>: A dictionary where keys are cell type names and values are NamedTuples with fields <code>:counts</code>, <code>:mean</code>, and <code>:std</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L182-L201">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.SimulationPopulationTimeSeries"><a class="docstring-binding" href="#PhysiCellModelManager.SimulationPopulationTimeSeries"><code>PhysiCellModelManager.SimulationPopulationTimeSeries</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimulationPopulationTimeSeries &lt;: AbstractPopulationTimeSeries</code></pre><p>Holds the data for a simulation&#39;s population time series.</p><p>If constructed using a <code>Simulation</code> or an <code>Integer</code> (representing a simulation ID), it will save the time series inside the <code>simulations/simulation_id/summary/</code> folder. It will also look for previously computed time series there to avoid recomputing them.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">spts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it
spts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has &quot;_include_dead&quot; appended</code></pre><p><strong>Fields</strong></p><ul><li><code>simulation_id::Int</code>: The ID of the simulation.</li><li><code>time::Vector{Real}</code>: The time points of the population time series.</li><li><code>cell_count::Dict{String, Vector{Integer}}</code>: A dictionary where keys are cell type names and values are vectors of cell counts over time.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L48-L67">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.formatTimeRange-Tuple{Vector{&lt;:Real}}"><a class="docstring-binding" href="#PhysiCellModelManager.formatTimeRange-Tuple{Vector{&lt;:Real}}"><code>PhysiCellModelManager.formatTimeRange</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">formatTimeRange(v::Vector{&lt;:Real})</code></pre><p>Format a vector of time points into a string representation.</p><p>Used only for printing certain classes to the console.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L133-L139">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.getMeanCounts-Tuple{PhysiCellModelManager.SimulationPopulationTimeSeries}"><a class="docstring-binding" href="#PhysiCellModelManager.getMeanCounts-Tuple{PhysiCellModelManager.SimulationPopulationTimeSeries}"><code>PhysiCellModelManager.getMeanCounts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getMeanCounts(apts::AbstractPopulationTimeSeries)</code></pre><p>Return the mean counts of a population time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/population.jl#L284-L288">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.processExcludeCellTypes-Tuple{Any}"><a class="docstring-binding" href="#PhysiCellModelManager.processExcludeCellTypes-Tuple{Any}"><code>PhysiCellModelManager.processExcludeCellTypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processExcludeCellTypes(exclude_cell_type_names)</code></pre><p>Process the <code>exclude_cell_type_names</code> argument to ensure it is in the correct format.</p><p>If <code>exclude_cell_type_names</code> is a string, it is converted to a single-element vector. If it is a vector, it is returned as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/preprocessing.jl#L41-L48">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.processIncludeCellTypes-Tuple{Any, Vector{String}}"><a class="docstring-binding" href="#PhysiCellModelManager.processIncludeCellTypes-Tuple{Any, Vector{String}}"><code>PhysiCellModelManager.processIncludeCellTypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">processIncludeCellTypes(include_cell_type_names, all_cell_types::Vector{String})</code></pre><p>Process the <code>include_cell_type_names</code> argument to ensure it is in the correct format.</p><p>Uses the <code>all_cell_types</code> vector to determine the valid cell types.</p><p><strong>Arguments</strong></p><ul><li><code>include_cell_type_names</code>: the cell types to include in the analysis (default is <code>:all_in_one</code>). Full list of options:<ul><li><code>:all</code> - return the vector of all cell types</li><li><code>:all_in_one</code> - return a vector with a single element, which is a vector of all cell types</li><li><code>&quot;cell_type_1&quot;</code> - return [&quot;cell<em>type</em>1&quot;]</li><li><code>[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]</code> - return [&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;]</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;]]</code> - return [[&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;]]</li><li><code>[[&quot;cell_type_1&quot;, &quot;cell_type_2&quot;], &quot;cell_type_3&quot;]</code> - return [[&quot;cell<em>type</em>1&quot;, &quot;cell<em>type</em>2&quot;], &quot;cell<em>type</em>3&quot;]</li></ul></li><li><code>all_cell_types</code>: a vector of all cell types in the simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/preprocessing.jl#L1-L17">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.VoxelWeights"><a class="docstring-binding" href="#PhysiCellModelManager.VoxelWeights"><code>PhysiCellModelManager.VoxelWeights</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VoxelWeights</code></pre><p>A struct to hold the voxel weights for a PhysiCell simulation.</p><p><strong>Fields</strong></p><ul><li><code>use_weights::Bool</code>: Whether to use weights for the voxel volumes. If all voxel volumes are the same, this is set to <code>false</code>.</li><li><code>weights::Vector{Real}</code>: The weights for the voxel volumes.</li><li><code>weight_total::Real</code>: The total weight of the voxel volumes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L5-L13">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.averageExtracellularSubstrate"><a class="docstring-binding" href="#PhysiCellModelManager.averageExtracellularSubstrate"><code>PhysiCellModelManager.averageExtracellularSubstrate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">averageExtracellularSubstrate(snapshot::PhysiCellSnapshot, cell_type_to_name_dict::Dict{Int, String}=Dict{Int, String}(), substrate_names::Vector{String}=String[], labels::Vector{String}=String[]; include_dead::Bool=false)</code></pre><p>Compute the average extracellular substrate concentrations for each cell type in a PhysiCell snapshot.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to analyze.</li><li><code>cell_type_to_name_dict::Dict{Int, String}</code>: A dictionary mapping cell type IDs to their names. If not provided, it is read from the snapshot files.</li><li><code>substrate_names::Vector{String}</code>: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.</li><li><code>labels::Vector{String}</code>: The labels to use for the cells. If not provided, it is read from the snapshot files.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>include_dead::Bool</code>: Whether to include dead cells in the analysis (default is <code>false</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, Dict{String, Real}}</code>: A dictionary mapping cell type names to dictionaries mapping substrate names to their average concentrations.</li></ul><p>That is, if <code>aes</code> is the output of this function, then <code>aes[&quot;cell_type_name&quot;][&quot;substrate_name&quot;]</code> is the average concentration of <code>substrate_name</code> for cells of type <code>cell_type_name</code> in the snapshot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L151-L169">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.averageSubstrate"><a class="docstring-binding" href="#PhysiCellModelManager.averageSubstrate"><code>PhysiCellModelManager.averageSubstrate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">averageSubstrate(snapshot::PhysiCellSnapshot, substrate_names::Vector{String}=String[], voxel_weights::VoxelWeights=VoxelWeights(snapshot))</code></pre><p>Compute the average substrate concentrations for every substrate in a PhysiCell snapshot.</p><p>The voxel volumes are used as weights if they are not all the same.</p><p><strong>Arguments</strong></p><ul><li><code>snapshot::PhysiCellSnapshot</code>: The snapshot to analyze.</li><li><code>substrate_names::Vector{String}</code>: The names of the substrates in the simulation. If not provided, it is read from the snapshot files.</li><li><code>voxel_weights::VoxelWeights</code>: The voxel weights to use. If not provided, it is computed from the snapshot.</li></ul><p><strong>Returns</strong></p><ul><li><code>data::Dict{String, Real}</code>: A dictionary mapping substrate names to their average concentrations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L32-L46">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.computeVoxelIndices-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><a class="docstring-binding" href="#PhysiCellModelManager.computeVoxelIndices-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><code>PhysiCellModelManager.computeVoxelIndices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">computeVoxelIndices(cells::DataFrame, mesh::Dict{String, Vector{Float64}})</code></pre><p>Compute the voxel (linear) indices (1-nx<em>ny</em>nz) for a set of cells in a PhysiCell simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L211-L215">source</a></section></details></article><article><details class="docstring"><summary id="PhysiCellModelManager.computeVoxelSubscripts-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><a class="docstring-binding" href="#PhysiCellModelManager.computeVoxelSubscripts-Tuple{DataFrames.DataFrame, Dict{String, Vector{Float64}}}"><code>PhysiCellModelManager.computeVoxelSubscripts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">computeVoxelSubscripts(cells::DataFrame, mesh::Dict{String, Vector{Float64}})</code></pre><p>Compute the voxel subscripts (1-nx, 1-ny, 1-nz) for a set of cells in a PhysiCell simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/drbergman-lab/PhysiCellModelManager.jl/blob/fe871cf1dcc3373bb1125b2592ab57e2fded0ccb/src/analysis/substrate.jl#L194-L198">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PhysiCellModelManager/">« Core</a><a class="docs-footer-nextpage" href="../classes/">Classes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 03:22">Monday 1 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
