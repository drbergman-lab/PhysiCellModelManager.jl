var documenterSearchIndex = {"docs":
[{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTHPC/#VCTHPC","page":"VCTHPC","title":"VCTHPC","text":"","category":"section"},{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"Run pcvct on an HPC.","category":"page"},{"location":"lib/VCTHPC/","page":"VCTHPC","title":"VCTHPC","text":"Modules = [pcvct]\nPages = [\"VCTHPC.jl\"]","category":"page"},{"location":"lib/VCTHPC/#pcvct.isRunningOnHPC-Tuple{}","page":"VCTHPC","title":"pcvct.isRunningOnHPC","text":"isRunningOnHPC()\n\nReturn true if the current environment is an HPC environment, false otherwise.\n\nCurrently, this function checks if the sbatch command is available, indicating a SLURM environment.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTHPC/#pcvct.setJobOptions-Tuple{Dict}","page":"VCTHPC","title":"pcvct.setJobOptions","text":"setJobOptions(options::Dict)\n\nSet the default job options for use with SLURM.\n\nFor any key-value pair in options, the corresponding key in the global sbatch_options dictionary is set to the value. A flag is then added to the sbatch command for each key-value pair in options: --key=value. When running simulations, any values in this dictionary that are Function's will be assumed to be functions of the simulation id.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTHPC/#pcvct.useHPC","page":"VCTHPC","title":"pcvct.useHPC","text":"useHPC([use::Bool=true])\n\nSet the global variable run_on_hpc to use.\n\nExamples\n\nuseHPC() # Set to true so `sbatch` is used for running simulations\nuseHPC(true) # set to true so `sbatch` is used for running simulations\nuseHPC(false) # Set to false so simulations are run locally\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Read Best practices before using pcvct.","category":"page"},{"location":"man/getting_started/#Install-pcvct","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/#Download-julia","page":"Getting started","title":"Download julia","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"See here for more options:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: this command also installs the JuliaUp installation manager, which will automatically install julia and help keep it up to date.","category":"page"},{"location":"man/getting_started/#Add-the-PCVCTRegistry","page":"Getting started","title":"Add the PCVCTRegistry","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Launch julia by running julia in a shell. Then, enter the Pkg REPL by pressing ]. Finally, add the PCVCTRegistry by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> registry add https://github.com/drbergman/PCVCTRegistry","category":"page"},{"location":"man/getting_started/#Install-pcvct-2","page":"Getting started","title":"Install pcvct","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Still in the Pkg REPL, run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"pkg> add pcvct","category":"page"},{"location":"man/getting_started/#Set-up-a-pcvct-project","page":"Getting started","title":"Set up a pcvct project","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Leave the Pkg REPL by pressing the delete or backspace key (if still in it from the previous step). Load the pcvct module by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> using pcvct","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Then, create a new project by running:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> createProject(path_to_project_folder) # createProject() will use the current directory as the project folder","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"This creates three folders inside the path_to_project_folder folder: data/, PhysiCell/, and VCT/. See Data directory structure for information about the data/ folder.","category":"page"},{"location":"man/getting_started/#(Optional)-Import-from-user_projects","page":"Getting started","title":"(Optional) Import from user_projects","text":"","category":"section"},{"location":"man/getting_started/#Inputs","page":"Getting started","title":"Inputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you have a project in the PhysiCell/user_projects/ folder that you would like to import, you can do so by running importProject:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder)","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The path_to_project_folder string can be either the absolute path (recommended) or the relative path (from the directory julia was launched) to the project folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: This function assumes your project files are in the standard PhysiCell/user_projects/ format. See the table below for the standard locations of the files. Note the Default location column shows the path relative to path_to_project_folder.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Input Default location Key Optional\nconfig config/PhysiCell_settings.xml config \nmain main.cpp main \nMakefile Makefile makefile \ncustom modules custom_modules/ custom_modules \nrules config/cell_rules.csv rules X\ncell initial conditions config/cells.csv ic_cell X\nsubstrate initial conditions config/substrates.csv ic_substrate X","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If any of these files are not located in the standard location, you can define a dictionary with keys taken from the table above to specify the location of each file. For example, if the config file is instead located at PhysiCell/user_projects/[project_name]/config/config.xml, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> src = Dict(\"config\" => \"config/config.xml\")","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Additional entries can be added in a comma-separated list into Dict or added later with src[key] = rel_path. Pass the dictionary in as the second argument as follows:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"julia> importProject(path_to_project_folder, src)","category":"page"},{"location":"man/getting_started/#Outputs","page":"Getting started","title":"Outputs","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"If you use this option, then the GenerateData.jl script must be updated to reflect the new project folders. By default, the folder names are taken from the name of the project with an integer appended if it already exists. If you want to use a different name, you can pass ","category":"page"},{"location":"man/getting_started/#Running-first-trial","page":"Getting started","title":"Running first trial","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"The createProject() command creates three folder, including a VCT folder with a single file: VCT/GenerateData.jl. The name of this folder and this file are purely convention, change them as you like. To run your first pcvct trial, you can run the GenerateData.jl script from the shell:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Note: if you want to parallelize these 9 runs, you can set the shell environment variable PCVCT_NUM_PARALLEL_SIMS to the number of parallel simulations you want to run. For example, to run 9 parallel simulations, you would run:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ export PCVCT_NUM_PARALLEL_SIMS=9\n$ julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Or for a one-off solution:","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"$ PCVCT_NUM_PARALLEL_SIMS=9 julia VCT/GenerateData.jl","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Alternatively, you can run the script via the REPL.","category":"page"},{"location":"man/getting_started/","page":"Getting started","title":"Getting started","text":"Run the script a second time and observe that no new simulations are run. This is because pcvct looks for matching simulations first before running new ones. The use_previous optional keyword argument can control this behavior if new simulations are desired.","category":"page"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTExport/#VCTExport","page":"VCTExport","title":"VCTExport","text":"","category":"section"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"This file holds the functions for exporting a simulation to a user_project format.","category":"page"},{"location":"lib/VCTExport/","page":"VCTExport","title":"VCTExport","text":"Modules = [pcvct]\nPages = [\"VCTExport.jl\"]","category":"page"},{"location":"lib/VCTExport/#pcvct.exportSimulation","page":"VCTExport","title":"pcvct.exportSimulation","text":"exportSimulation(simulation_id::Integer[, export_folder::AbstractString])\nexportSimulation(simulation::Simulation[, export_folder::AbstractString])\n\nCreate a user_project folder from a simulation that can be loaded into PhysiCell.\n\nWarning: not all features in drbergman/PhysiCell/latest/release are not supported in MathCancer/PhysiCell.\n\nArguments\n\nsimulation_id::Integer: the id of the simulation to export\nsimulation::Simulation: the simulation to export\nexport_folder::AbstractString: the folder to export the simulation to. Default is the simulation output folder.\n\n\n\n\n\n","category":"function"},{"location":"misc/renaming/#Renaming","page":"Renaming","title":"Renaming","text":"","category":"section"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"Julia packages are supposed to follow certain conventions to be admitted to the General registry. In particular, it must end with .jl, be CamelCase, avoid jargon/acronyms (looking at you pcvct), and be descriptive. We want to clearly tie it to PhysiCell but not make it sound like a replacement for PhysiCell, i.e. not PhysiCell.jl. Here are the options brainstormed thus far:","category":"page"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"PhysiCellVT.jl\nPhysiVT.jl (possible confusion with the OpenVT project where VT = virtual tissue)\nPhysiCellCohorts.jl\nPhysiCellTrials.jl\nPhysiVirtualTrials.jl\nPhysiCellBatch.jl\nPhysiBatch.jl\nPhysiCellDB.jl\nPhysiDB.jl (the clear name for make the database portion a separate package)\nPhysiCell.jl (kinda self-important to assume this will be all the PhysiCell stuff in Julia)","category":"page"},{"location":"misc/renaming/","page":"Renaming","title":"Renaming","text":"I think I'm now leaning towards ModelManager.jl being the underlying framework that works across ABM (or other modeling paradigms) frameworks and then PhysiCellModelManager.jl is the PhysiCell-specific version.","category":"page"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTRunner/#VCTRunner","page":"VCTRunner","title":"VCTRunner","text":"","category":"section"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"Run simulations, monads, samplings, and trials in the pcvct framework.","category":"page"},{"location":"lib/VCTRunner/","page":"VCTRunner","title":"VCTRunner","text":"Modules = [pcvct]\nPages = [\"VCTRunner.jl\"]","category":"page"},{"location":"lib/VCTRunner/#Base.run-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"Base.run","text":"run(T::AbstractTrial[; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions()])`\n\nRun the given simulation, monad, sampling, or trial.\n\nCall the appropriate functions to run the simulations and return the number of successful simulations. Also print out messages to the console to inform the user about the progress and results of the simulations.\n\nArguments\n\nT::AbstractTrial: The trial, sampling, monad, or simulation to run.\nforce_recompile::Bool=false: If true, forces a recompilation of all files by removing all .o files in the PhysiCell directory.\nprune_options::PruneOptions=PruneOptions(): Options for pruning simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTRunner/#pcvct.collectSimulationTasks-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"pcvct.collectSimulationTasks","text":"collectSimulationTasks(T::AbstractTrial[; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions()])\n\nCollect the simulation tasks for the given trial, sampling, monad, or simulation.\n\nUsed by run to collect the tasks to run.\n\nSee also run.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTRunner/#pcvct.runAbstractTrial-Tuple{pcvct.AbstractTrial}","page":"VCTRunner","title":"pcvct.runAbstractTrial","text":"runAbstractTrial(T::AbstractTrial; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions())\n\nAlias for run, but only with this particular signature. Does not work on Cmd objects as Base.run is built for. Also, does not work with running sensitivity samplings.\n\n\n\n\n\n","category":"method"},{"location":"man/covariations/#CoVariations","page":"CoVariations","title":"CoVariations","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"Sometimes several parameters need to be varied together. A common use case is the varying the base value of a rule and the max response of the rule[1] To handle this scenario, pcvct provides the CoVariation type. A CoVariation is a wrapper for a vector of ElementaryVariation's, and each ElementaryVariation must be of the same type, i.e., all DiscreteVariation's or all DistributedVariation's. The type of a CoVariation is parameterized by the type of ElementaryVariation's it contains. Thus, there are, for now, two types of CoVariation's: CoVariation{DiscreteVariation} and CoVariation{DistributedVariation}.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"[1]: PhysiCell does not allow the base value to exceed the max response. That is, the base response of a decreasing signal cannot be < the max response. Similarly, the base resposne of an increasing signal cannot be > the max response.","category":"page"},{"location":"man/covariations/#CoVariation{DiscreteVariation}","page":"CoVariations","title":"CoVariation{DiscreteVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DiscreteVariation}, each of the DiscreteVariation's must have the same number of values. This may be relaxed in future versions, but the primary use case anticipated is a GridVariation which requires the variations to inform the size of the grid. No restrictions are imposed on how the values of the various variations are linked. pcvct will use values that share an index their respective vectors together.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"base_xml_path = pcvct.customDataPath(\"default\", \"sample\")\nev1 = DiscreteVariation(base_xml_path, [1, 2, 3]) # vary the `sample` custom data for cell type default\nmax_xml_path = [\"hypothesis_ruleset:name:default\", \"behavior:name:custom sample\", \"increasing_signals\", \"max_response\"] # the max response of the rule increasing sample (must be bigger than the base response above)\nev2 = DiscreteVariation(rule_xml_path, [2, 3, 4])\ncovariation = CoVariation(ev1, ev2) # CoVariation([ev1, ev2]) also works","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"It is also not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"# have the phase durations vary by and compensate for each other\nphase_0_xml_path = [pcvct.cyclePath(\"default\"); \"phase_durations\"; \"duration:index:0\"]\nphase_0_durations = [300.0, 400.0] \nphase_1_durations = [200.0, 100.0] # the (mean) duration through these two phases is 500 min\n# input any number of tuples (xml_path, values)\ncovariation = Covariation((phase_0_xml_path, phase_0_durations), (phase_1_xml_path, phase_1_durations))","category":"page"},{"location":"man/covariations/#CoVariation{DistributedVariation}","page":"CoVariations","title":"CoVariation{DistributedVariation}","text":"","category":"section"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"For a CoVariation{DistributedVariation}, the conversion of a CDF value, x in 0 1, is done independently for each distribution. That is, in the joint probability space, a CoVariation{DistributedVariation} restricts us to the one-dimensional line connecting mathbf0 to mathbf1. To allow for the parameters to vary inversely with one another, the DistributedVariation type accepts an optional flip::Bool argument (not a keyword argument!). For a distribution dv with dv.flip=true, when a value is requested with a CDF x, pcvct will \"flip\" the CDF to give the value with CDF 1 - x.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"using pcvct\ntiming_1_path = pcvct.userParameterPath(\"event_1_time\")\ntiming_2_path = pcvct.userParameterPath(\"event_2_time\")\ndv1 = UniformDistributedVariation(timing_1_path, 100.0, 200.0)\nflip = true\ndv2 = UniformDistributedVariation(timing_2_path, 100.0, 200.0, flip)\ncovariation = CoVariation(dv1, dv2)\ncdf = 0.1\npcvct._values.(covariation.variations, cdf) # pcvct internal for getting values for an ElementaryVariation\n# output\n2-element Vector{Vector{Float64}}:\n [110.0]\n [190.0]","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"As with CoVariation{DiscreteVariation}, it is not necessary to create the ElementaryVariation's separately and then pass them to the CoVariation constructor. It is not possible to flip a DistributedVariation with this syntax, however.","category":"page"},{"location":"man/covariations/","page":"CoVariations","title":"CoVariations","text":"apop_xml_path = [pcvct.apoptosisPath(\"default\"); \"death_rate\"]\napop_dist = Uniform(0, 0.001)\ncycle_entry_path = [pcvct.cyclePath(\"default\"); \"phase_transition_rates\"; \"rate:start_index:0\"]\ncycle_dist = Uniform(0.00001, 0.0001)\ncovariation = CoVariation((apop_xml_path, apop_dist), (cycle_entry_path, cycle_dist))","category":"page"},{"location":"man/intracellular_inputs/#Intracellular-inputs","page":"Intracellular inputs","title":"Intracellular inputs","text":"","category":"section"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"pcvct currently only supports ODE intracellular models using libRoadRunner. It uses a specialized format to achieve this, creating the SBML files needed by libRoadRunner at PhysiCell runtime. Briefly, the intracellular.xml file defines a mapping between cell definitions and intracellular models. See the template provided here.","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"To facilitate creation of such files, and to make it easy to mix-and-match intracellular models, users can place the SBML files that define the ODEs into data/components/roadrunner and then simply reference those to construct the specialized XMLs needed. For example, place the Toy_Metabolic_Model.xml from sampleprojectsintracellular/ode/ode_energy/config/ into data/components/roadrunner and assemble the XML as follows","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"cell_type = \"default\" # name of the cell type using this intracellular model\ncomponent = PhysiCellComponent(\"roadrunner\", \"Toy_Metabolic_Model.xml\") # pass in the type of the component and the name of the file to use\ncell_type_to_component = Dict{String, PhysiCellComponent}(cell_type => component) # add other entries to this Dict for other cell types using an intracellular model\nintracellular_folder = assembleIntracellular!(cell_type_to_component; name=\"toy_metabolic\") # will return \"toy_metabolic\" or \"toy_metabolic_n\"","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"This creates a folder at data/inputs/intracellulars/ with the name stored in intracellular_folder. Also, the ! in assembleIntracellular! references how the components in the cell_type_to_component Dict are updated to match those in data/inputs/intracellulars/$(intracellular_folder)/intracellular.xml. Use these IDs to make variations on the components by using","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"xml_path = [\"intracellulars\", \"intracellular:ID:$(component.id)\", ...]","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"where the ... is the path starting with the root of the XML file (sbml for SBML files).","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"Finally, pass this folder into InputFolders to use this input in simulation runs:","category":"page"},{"location":"man/intracellular_inputs/","page":"Intracellular inputs","title":"Intracellular inputs","text":"inputs = InputFolders(...; ..., intracellular=intracellular_folder, ...)","category":"page"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTImport/#VCTImport","page":"VCTImport","title":"VCTImport","text":"","category":"section"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"Import a project from the standard PhysiCell format into the pcvct format.","category":"page"},{"location":"lib/VCTImport/","page":"VCTImport","title":"VCTImport","text":"Modules = [pcvct]\nPages = [\"VCTImport.jl\"]","category":"page"},{"location":"lib/VCTImport/#pcvct.importProject","page":"VCTImport","title":"pcvct.importProject","text":"importProject(path_to_project::AbstractString[, src=Dict(), dest=Dict(); extreme_caution::Bool=false])\n\nImport a project from the structured in the format of PhysiCell sample projects and user projects into the pcvct structure.\n\nArguments\n\npath_to_project::AbstractString: Path to the project to import. Relative paths are resolved from the current working directory where Julia was launched.\nsrc::Dict: Dictionary of the project sources to import. If absent, tries to use the default names.\n\nThe following keys are recognized: config, main, makefile, custom_modules, rulesets_collection, intracellular, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\ndest::Dict: Dictionary of the inputs folders to create in the pcvct structure. If absent, taken from the project name.\n\nThe following keys are recognized: config, custom_code, rules, intracellular, ic_cell, ic_substrate, ic_ecm, and ic_dc.\n\nextreme_caution::Bool: If true, will ask for confirmation before deleting any folders created during the import process. Care has been taken to ensure this is unnecessary. Provided for users who want to be extra cautious.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTCreation/#VCTCreation","page":"VCTCreation","title":"VCTCreation","text":"","category":"section"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"Create a new pcvct project.","category":"page"},{"location":"lib/VCTCreation/","page":"VCTCreation","title":"VCTCreation","text":"Modules = [pcvct]\nPages = [\"VCTCreation.jl\"]","category":"page"},{"location":"lib/VCTCreation/#pcvct.createProject","page":"VCTCreation","title":"pcvct.createProject","text":"createProject(project_dir::String=\".\"; clone_physicell::Bool=true, template_as_default::Bool=true, terse::Bool=false)\n\nCreate a new pcvct project structure.\n\nCreates a new project directory at project_dir with the following structure:\n\nproject_dir\n├── data\n├── PhysiCell # The latest release from https://github.com/drbergman/PhysiCell\n└── VCT\n\ndata is populated with the standard structure. PhysiCell is a copy of PhysiCell. VCT contains a generated GenerateData.jl file.\n\nArguments\n\nproject_dir::String=\".\": The directory in which to create the project. Relative paths are resolved from the current working directory where Julia was launched.\nclone_physicell::Bool=true: Whether to clone the PhysiCell repository. If false, the latest release will be downloaded. Recommended to set to true so pcvct will be able to track changes to the PhysiCell repository.\ntemplate_as_default::Bool=true: Whether to set up the project with the template files as the default. If false, the project will be set up with an empty structure.\nterse::Bool=false: Whether to generate a terse GenerateData.jl file. If true, the file will be generated without comments and explanations.\n\nNote\n\nThe names of the data and PhysiCell directories are fixed and cannot be changed. Their relative locations should not be changed without updating the GenerateData.jl file. The name of the VCT file and the GenerateData.jl are just by convention and can be changed.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTICCell/#VCTICCell","page":"VCTICCell","title":"VCTICCell","text":"","category":"section"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"Functionality for the using PhysiCellCellCreator.jl to create and use PhysiCell IC cell XML files.","category":"page"},{"location":"lib/VCTICCell/","page":"VCTICCell","title":"VCTICCell","text":"Modules = [pcvct]\nPages = [\"VCTICCell.jl\"]","category":"page"},{"location":"lib/VCTICCell/#pcvct.createICCellXMLTemplate-Tuple{String}","page":"VCTICCell","title":"pcvct.createICCellXMLTemplate","text":"createICCellXMLTemplate(folder::String)\n\nCreate folder with a template XML file for IC cells.\n\nSee the PhysiCellCellCreator.jl documentation for more information on IC cells and how this function works outside of pcvct. This pcvct function runs the createICCellXMLTemplate function from PhysiCellCellCreator.jl and then updates the database. Furthermore, the folder can be passed in just as the name of the folder located in data/inputs/ics/cells/ rather than the full path.\n\nThis functionality is run outside of a PhysiCell runtime. It will not work in PhysiCell! This function creates a template XML file for IC cells, showing all the current functionality of this initialization scheme. It uses the cell type \"default\". Create ICs for more cell types by copying the cell_patches element. The ID attribute in patch elements is there exactly to allow variations to target specific patches. Manually maintain these or you will not be able to vary specific patches effectively.\n\nEach time a simulation is run that is using a cells.xml file, a new CSV file will be created, drawing randomly from the patches defined in the XML file. These will all be stored with data/inputs/ics/cells/folder/ic_cell_variations as ic_cell_variation_#_s#.csv where the first # is the variation ID associated with variation on the XML file and the second # is the simulation ID. Importantly, no two simulations will use the same CSV file.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTICECM/","page":"VCTICECM","title":"VCTICECM","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTICECM/#VCTICECM","page":"VCTICECM","title":"VCTICECM","text":"","category":"section"},{"location":"lib/VCTICECM/","page":"VCTICECM","title":"VCTICECM","text":"Functionality for the using PhysiCellECMCreator.jl to create and use PhysiCell ECM XML files.","category":"page"},{"location":"lib/VCTICECM/","page":"VCTICECM","title":"VCTICECM","text":"Modules = [pcvct]\nPages = [\"VCTICECM.jl\"]","category":"page"},{"location":"lib/VCTICECM/#pcvct.createICECMXMLTemplate-Tuple{String}","page":"VCTICECM","title":"pcvct.createICECMXMLTemplate","text":"createICECMXMLTemplate(folder::String)\n\nCreate folder with a template XML file for IC ECM.\n\nSee the PhysiCellECMCreator.jl documentation for more information on IC ECM and how this function works outside of pcvct. This pcvct function runs the createICECMXMLTemplate function from PhysiCellECMCreator.jl and then updates the database. Furthermore, the folder can be passed in just as the name of the folder located in data/inputs/ics/ecms/ rather than the full path.\n\nThis functionality is run outside of a PhysiCell runtime. It will not work in PhysiCell! This function creates a template XML file for IC ECM, showing all the current functionality of this initialization scheme. The ID attribute in patch elements is there to allow variations to target specific patches within a layer. Manually maintain these or you will not be able to vary specific patches effectively.\n\nEach time a simulation is run that is using a ecm.xml file, a new CSV file will be created. These will all be stored with data/inputs/ics/ecms/folder/ic_ecm_variations as ic_ecm_variation_#_s#.csv where the first # is the variation ID associated with variation on the XML file and the second # is the simulation ID. Importantly, no two simulations will use the same CSV file.\n\n\n\n\n\n","category":"method"},{"location":"man/physicell_studio/#Using-PhysiCell-Studio","page":"PhysiCell Studio","title":"Using PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"See PhysiCell-Studio.","category":"page"},{"location":"man/physicell_studio/#Setting-paths","page":"PhysiCell Studio","title":"Setting paths","text":"","category":"section"},{"location":"man/physicell_studio/#Environment-variables","page":"PhysiCell Studio","title":"Environment variables","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"You must first inform pcvct where your desired python executable is and the PhysiCell Studio folder. The recommended way to do this is to add the following two lines to your shell environment file (e.g. ~/.bashrc or ~/.zshenv):","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"export PCVCT_PYTHON_PATH=\"/usr/bin/python3\"\nexport PCVCT_STUDIO_PATH=\"/home/user/PhysiCell-Studio\"","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If your python executable is on your PATH, you can set PCVCT_PYTHON_PATH=\"python3\", for example.","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"After making these changes, make sure to source the file to apply the changes:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"$ source ~/.bashrc","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"Or open a new terminal window.","category":"page"},{"location":"man/physicell_studio/#Using-keyword-arguments","page":"PhysiCell Studio","title":"Using keyword arguments","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you prefer not to set these environment variables, you can pass the paths as keyword arguments to the runStudio function. It will remember these settings during the session, so you only need to pass them once. See below for the function signature.","category":"page"},{"location":"man/physicell_studio/#Launching-PhysiCell-Studio","page":"PhysiCell Studio","title":"Launching PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"First, launch julia and make sure the project is initialized by running:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"# if you used createProject(), these are the first two lines of GenerateData.jl\nusing pcvct\ninitializeVCT(path_to_physicell, path_to_data)","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"As soon as the simulation has begun (so that its PhysiCell-generated output folder is created and populated), you can launch PhysiCell Studio. If you set the environment variables, you can run the following command for a simulation with id sim_id::Integer:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id)","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"If you did not set the environment variables, you can run the following command:","category":"page"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"julia> runStudio(sim_id; python_path=path_to_python, studio_path=path_to_studio)","category":"page"},{"location":"man/physicell_studio/#Editing-in-PhysiCell-Studio","page":"PhysiCell Studio","title":"Editing in PhysiCell Studio","text":"","category":"section"},{"location":"man/physicell_studio/","page":"PhysiCell Studio","title":"PhysiCell Studio","text":"When you run the runStudio function, PhysiCell Studio will open with the simulation you specified using temporary files for the configuration and rules. Any edits to these in studio will be lost when the studio is closed. Remember: this is the output of a simulation that already ran. Use the File > Save as dropdown to save the configuration file. Use the Rules tab to save the rules file. Note: the recent changes in PhysiCell 1.14.1 copying over the initial conditions files are not yet supported by this. See Known limitations for more information.","category":"page"},{"location":"man/analyzing_output/#Analyzing-output","page":"Analyzing output","title":"Analyzing output","text":"","category":"section"},{"location":"man/analyzing_output/#Loading-output","page":"Analyzing output","title":"Loading output","text":"","category":"section"},{"location":"man/analyzing_output/#PhysiCellSnapshot","page":"Analyzing output","title":"PhysiCellSnapshot","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The base unit of PhysiCell output is the PhysiCellSnapshot. These are currently considered pcvct internals and so the API may change. Each snapshot records the path to the PhysiCell output folder, its index in the sequence of outputs, the time of the snapshot in the simulation, and optionally the cell, substrate, and mesh data at that snapshot.","category":"page"},{"location":"man/analyzing_output/#PhysiCellSequence","page":"Analyzing output","title":"PhysiCellSequence","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"A PhysiCellSequence is the full sequence of snapshots corresponding to a single PhysiCell simulation. As with PhysiCellSnapshot's, these are currently considered internals and their API may change. In addition to the path to the PhysiCell output folder and the vector of PhysiCellSnapshot's, it holds metadata for the simulation.","category":"page"},{"location":"man/analyzing_output/#getCellDataSequence","page":"Analyzing output","title":"getCellDataSequence","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The main function to get sequences of cell data is getCellDataSequence. It accepts any of a simulation ID (<:Integer), a simulation (::Simulation), or a sequence (::PhysiCellSequence) and either a single label (::String) or a vector of labels (::Vector{String}). For each cell in the simulation (as determined by the cell ID), the output creates a dictionary entry (the key is the integer cell ID) whose value is a named tuple with the input labels as keys as well as :time. This means that if one sets","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"data = getCellDataSequence(1, \"position\")","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Then one can access the positions of the cell with ID 78 by","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"cell_78_positions = data[78].position # an Nx3 matrix for the N integer-indexed outputs (ignores the `initial_*` and `final_*` files)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"and plot the x-coordinates of this cell over time using","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"cell_78_times = data[78].time\n\nusing Plots\nplot(cell_78_times, cell_78_positions[:,1])","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Note: Each call to getCellDataSequence will load all the data unless a PhysiCellSequence is passed in. Plan your analyses accordingly as loading simulation data is not fast.","category":"page"},{"location":"man/analyzing_output/#Population-plots","page":"Analyzing output","title":"Population plots","text":"","category":"section"},{"location":"man/analyzing_output/#Group-by-Monad","page":"Analyzing output","title":"Group by Monad","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Plotting population plots is one the most basic analysis tasks and pcvct makes it super easy! If you call plot on a Simulation, Monad, Sampling, or the return value of a call to run (though not for a sensitivity analysis), then a sequence of panels will be generated in a single figure. Each panel will correspond to a Monad (replicates using the same parameter values) and will plot mean +/- SD for each cell type.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finer-grained control of the output is possible, too!","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"to include dead cells in your counts: plot(...; ..., include_dead=true, ...)\nselect a subset of cell types to include: plot(...; ..., include_cell_types=\"cancer\", ...)\nselect a subset of cell types to exclude: plot(...; ..., exclude_cell_types=\"cancer\", ...)","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The include_cell_types and exclude_cell_types can also accept a Vector{String} to include or exclude certain cell types, respectively. Furthermore, if the value of include_cell_types is a Vector and one of its entries is a Vector{String}, pcvct will interpret this to sum up those cell types. In other words, to get the total tumor cell count in addition to the epithelial (\"epi\") and mesenchymal (\"mes\") components, you could use","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\nplot(Monad(1); include_cell_types=[\"epi\", \"mes\", [\"epi\", \"mes\"]])","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finally, this makes use of Julia's Plot Recipes (see RecipesBase.jl) so any standard plotting keywords can be passed in:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\ncolors = [:blue :red] # Note the absence of a `,` or `;`. This is how Julia requires different series parameters to be passed in \nplot(Simulation(1); color=colors, include_cell_types=[\"cd8\", \"cancer\"]) # will plot cd8s in blue and cancer in red.","category":"page"},{"location":"man/analyzing_output/#Group-by-cell-type","page":"Analyzing output","title":"Group by cell type","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Invert the above by including all data for a single cell type across all monads in a single panel with a call to plotbycelltype. This function works on any T<:AbstractTrial (Simulation, Monad, Sampling, or Trial) as well as any PCVCTOutput object (the return value to run). Everything above for plot applies here.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using Plots\nplotbycelltype(Sampling(1); include_cell_types=[\"epi\", \"mes\", [\"epi\", \"mes\"]], color=[:blue :red :purple], labels=[\"epi\" \"mes\" \"both\"], legend=true)","category":"page"},{"location":"man/analyzing_output/#Substrate-analysis","page":"Analyzing output","title":"Substrate analysis","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"pcvct supports two ways to summarize substrate information over time.","category":"page"},{"location":"man/analyzing_output/#AverageSubstrateTimeSeries","page":"Analyzing output","title":"AverageSubstrateTimeSeries","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An AverageSubstrateTimeSeries gives the time series for the average substrate across the entire domain.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nasts = AverageSubstrateTimeSeries(simulation_id)\nusing Plots\nplot(asts.time, asts[\"oxygen\"])","category":"page"},{"location":"man/analyzing_output/#ExtracellularSubstrateTimeSeries","page":"Analyzing output","title":"ExtracellularSubstrateTimeSeries","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An ExtracellularSubstrateTimeSeries gives the time series for the average substrate concentration in the extracellular space neighboring all cells of a given cell type. In a simulation with cd8 cells and IFNg diffusible substrate, plot the average concentration of IFNg experienced by CD8+ T cells using the following:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nests = ExtracellularSubstrateTimeSeries(simulation_id)\nusing Plots\nplot(ests.time, ests[\"cd8\"][\"IFNg\"])","category":"page"},{"location":"man/analyzing_output/#Motility-analysis","page":"Analyzing output","title":"Motility analysis","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The motilityStatistics function returns the time alive, distance traveled, and mean speed for each cell in the simulation. For each cell, these values are split amongst the cell types the given cell assumed throughout (or at least at the save times). To calculate these values, the cell type at the start of the save interval is used and the net displacement is used to calculate the speed. Optionally, users can pass in a coordinate direction to only consider speed in a given axis.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"simulation_id = 1\nmss = motilityStatistics(simulation_id)\nall_mean_speeds_as_mes = [ms[\"mes\"].speed for ms in mss if haskey(ms, \"mes\")] # concatenate all speeds as a \"mes\" cell type (if the given cell ever was a \"mes\")\nall_times_as_mes = [ms[\"mes\"].time for ms in mss if haskey(ms, \"mes\")] # similarly, get the time spent in the \"mes\" state\nmean_mes_speed = all_mean_speeds_as_mes .* all_times_as_mes |> sum # start computing the weighted average of their speeds\nmean_mes_speed /= sum(all_times_as_mes) # finish computing weighted average","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"mss = motilityStatistics(simulation_id; direction=:x) # only consider the movement in the x direction","category":"page"},{"location":"man/analyzing_output/#Pair-correlation-function-(PCF)","page":"Analyzing output","title":"Pair correlation function (PCF)","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Sometimes referred to as radial distribution functions, the pair correlation function (PCF) computes the density of target cells around center cells. If the two sets of cells (centers = targets), this is called PCF. If the two are not equal, this is sometimes called cross-PCF. Both can be computed with a call to pcvct.pcf (or just pcf if using PairCorrelationFunction has been called).","category":"page"},{"location":"man/analyzing_output/#Arguments","page":"Analyzing output","title":"Arguments","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"PCF computations can readily be called on PhysiCellSnapshot's, PhysiCellSequence's, or Simulation's. If the first argument in a call to pcf is an Integer, this is treated as a simulation ID. If this is followed by an index (of type Integer or value :initial or :final), this is treated as a snapshot; otherwise, it computes the PCF for the entire simulation.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The next argument is the cell type to use as the center cells as either a String or Vector{String}, representing the name of the cell type(s). If the target cells are different from the center cells, the next argument is the target cell type as either a String or Vector{String}. If omitted, the target cell type is the same as the center cell type and a (non-cross) PCF is computed. The resulting sets of center and target cell types must either be identical or have no overlap. Under the hood, the PCF computation relies on the signature used (with or without a target matrix) to determine whether to correct for cross or non-cross PCF, not the coordinates matching or not.","category":"page"},{"location":"man/analyzing_output/#Keyword-arguments","page":"Analyzing output","title":"Keyword arguments","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The following keyword arguments are available:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"include_dead::Union{Bool, Tuple{Bool,Bool}} = false: whether to include dead cells in the PCF computation.\nIf true, all cells are included.\nIf false, only live cells are included.\nIf a tuple, the first value is for the center cells and the second is for the target cells.\ndr::Float64 = 20.0: the step size for the radial bins in micrometers.","category":"page"},{"location":"man/analyzing_output/#Output","page":"Analyzing output","title":"Output","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The output of pcf is a PCVCTPCFResult object which has two fields: time and pcf_result. The time field is always a vector of the time points at which the PCF was computed, even if computing PCF for a single snapshot. The pcf_result is of type PairCorrelationFunction.PCFResult and has two fields: radii and g. The radii is the set of cutoffs used to compute the PCF and g is either a vector or a matrix of the PCF values of size length(radii)-1 by length(time).","category":"page"},{"location":"man/analyzing_output/#Plotting","page":"Analyzing output","title":"Plotting","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"An API to make use of the PairCorrelationFunction package plotting interface is available through the plot function. Simply pass in the PCVCTPCFResult! You can pass in as many such objects as you like or pass in a Vector{PCVCTPCFResult}. In this case, these are interpreted as stochastic realizations of the same PCF and summary statistics are used to plot. See the PairCorrelationFunction documentation for more details.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"The pcvct implementation supports two keyword arguments:","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"time_unit::Symbol = :min: the time unit to use for the time axis (only relevant if the PCVCTPCFResult has more than one time point).\nThe default is :min and the other options are :s, :h, :d, :w, :mo, :y.\ndistance_unit::Symbol = :um: the distance unit to use for the distance axis.\nThe default is :um and the other options are :mm and :cm.","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"Finally, a keyword argument supported by PairCorrelationFunction is colorscheme which can be used to change the colorscheme of the color map. pcvct overrides the default from PairCorrelationFunction (:tofino) with :cork to use white to represent values near one.","category":"page"},{"location":"man/analyzing_output/#Examples","page":"Analyzing output","title":"Examples","text":"","category":"section"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using pcvct\nsimulation_id = 1\nresult = pcvct.pcf(simulation_id, \"cancer\", \"cd8\") #! using PairCorrelationFunction will obviate the need to prefix with `pcvct`\nplot(result) #! heatmap of proximity of (living) cd8s to (living) cancer cells throughout simulation 1","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using pcvct\nmonad = Monad(1) #! let's assume that there are >1 simulations in this monad\nresults = [pcvct.pcf(simulation_id, :final, \"cancer\", \"cd8\") for simulation_id in getSimulationIDs(monad)] #! one vector of PCF values for each simulation at the final snapshot\nplot(results) #! line plot of average PCF values against radius across the monad +/- 1 SD","category":"page"},{"location":"man/analyzing_output/","page":"Analyzing output","title":"Analyzing output","text":"using pcvct\nmonad = Monad(1) #! let's assume that there are >1 simulations in this monad\nresults = [pcvct.pcf(simulation_id, \"cancer\", \"cd8\") for simulation_id in getSimulationIDs(monad)] #! one matrix of PCF values for each simulation across all time points\nplot(results) #! heatmap of average PCF values with time on the x-axis and radius on the y-axis; averages omit NaN values that can occur at higher radii","category":"page"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTSensitivity/#VCTSensitivity","page":"VCTSensitivity","title":"VCTSensitivity","text":"","category":"section"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"Run sensitivity analyses on a model.","category":"page"},{"location":"lib/VCTSensitivity/","page":"VCTSensitivity","title":"VCTSensitivity","text":"Modules = [pcvct]\nPages = [\"VCTSensitivity.jl\"]","category":"page"},{"location":"lib/VCTSensitivity/#pcvct.GSASampling","page":"VCTSensitivity","title":"pcvct.GSASampling","text":"GSASampling\n\nStore the information that comes out of a global sensitivity analysis method.\n\nSubtypes\n\nMOATSampling\nSobolSampling\nRBDSampling\n\nMethods\n\ngetMonadIDDataFrame(gsa_sampling::GSASampling): get the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\ngetSimulationIDs(gsa_sampling::GSASampling): get the simulation IDs that were run in the sensitivity analysis.\nmethodString(gsa_sampling::GSASampling): get the string representation of the method used in the sensitivity analysis.\nsensitivityResults!(gsa_sampling::GSASampling, functions::Vector{<:Function}): calculate the sensitivity indices for the given functions.\ncalculateGSA!(gsa_sampling::GSASampling, f::Vector{<:Function}): calculate the sensitivity indices for the given function(s).\nevaluateFunctionOnSampling(gsa_sampling::GSASampling, f::Function): evaluate the function on the sampling and return the results.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.MOAT","page":"VCTSensitivity","title":"pcvct.MOAT","text":"MOAT\n\nStore the information necessary to run a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nlhs_variation::LHSVariation: the Latin Hypercube Sampling (LHS) variation to use for the MOAT. See LHSVariation.\n\nExamples\n\nNote: any keyword arguments in the MOAT constructor are passed to LHSVariation.\n\nMOAT() # default to 15 base points\nMOAT(10) # 10 base points\nMOAT(10; add_noise=true) # do not restrict the base points to the center of their cells\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.MOATSampling","page":"VCTSensitivity","title":"pcvct.MOATSampling","text":"MOATSampling\n\nStore the information that comes out of a Morris One-At-A-Time (MOAT) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.MorrisResult}: the results of the sensitivity analysis for each function.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.RBD","page":"VCTSensitivity","title":"pcvct.RBD","text":"RBD\n\nStore the information necessary to run a Random Balance Design (RBD) global sensitivity analysis.\n\nBy default, RBD will use the Sobol' sequence to sample the parameter space. See below for how to turn this off. Currently, users cannot control the Sobolʼ sequence used in RBD to the same degree it can be controlled in Sobolʼ. Open an Issue if you would like this feature.\n\nFields\n\nrbd_variation::RBDVariation: the RBD variation to use for the RBD analysis. See RBDVariation.\nnum_harmonics::Int: the number of harmonics to use from the Fourier transform for the RBD analysis.\n\nExamples\n\nNote: any keyword arguments in the RBD constructor are passed to RBDVariation, except for the num_harmonics keyword argument. If num_harmonics is not specified, it defaults to 6.\n\nRBD(15) # 15 points from the Sobol' sequence\nRBD(15; num_harmonics=10) # use 10 harmonics\nRBD(15; use_sobol=false) # opt out of using the Sobol' sequence, instead using a random sequence in each dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.RBDSampling","page":"VCTSensitivity","title":"pcvct.RBDSampling","text":"RBDSampling\n\nStore the information that comes out of a Random Balance Design (RBD) global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nnum_harmonics::Int: the number of harmonics used in the Fourier transform.\nnum_cycles::Union{Int, Rational}: the number of cycles used for each parameter.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.SobolSampling","page":"VCTSensitivity","title":"pcvct.SobolSampling","text":"SobolSampling\n\nStore the information that comes out of a Sobol' global sensitivity analysis.\n\nFields\n\nsampling::Sampling: the sampling used in the sensitivity analysis.\nmonad_ids_df::DataFrame: the DataFrame of monad IDs that define the scheme of the sensitivity analysis.\nresults::Dict{Function, GlobalSensitivity.SobolResult}: the results of the sensitivity analysis for each function.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods used for calculating the first and total order indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#pcvct.Sobolʼ","page":"VCTSensitivity","title":"pcvct.Sobolʼ","text":"Sobolʼ\n\nStore the information necessary to run a Sobol' global sensitivity analysis as well as how to extract the first and total order indices.\n\nThe rasp symbol is used to avoid conflict with the Sobol module. To type it in VS Code, use \\rasp and then press tab. The methods available for the first order indices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. The methods available for the total order indices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.\n\nFields\n\nsobol_variation::SobolVariation: the Sobol' variation to use for the Sobol' analysis. See SobolVariation.\nsobol_index_methods::NamedTuple{(:first_order, :total_order), Tuple{Symbol, Symbol}}: the methods to use for calculating the first and total order indices.\n\nExamples\n\nNote: any keyword arguments in the Sobolʼ constructor are passed to SobolVariation, except for the sobol_index_methods keyword argument. Do not use the n_matrices keyword argument in the SobolVariation constructor as it is set to 2 as required for Sobol' analysis.\n\nSobolʼ(15) # 15 points from the Sobol' sequence\nSobolʼ(15; sobol_index_methods=(first_order=:Jansen1999, total_order=:Jansen1999)) # use Jansen, 1999 for both first and total order indices\nSobolʼ(15; randomization=NoRand())` # use the default Sobol' sequence with no randomization. See GlobalSensitivity.jl for more options.\nSobolʼ(15; skip_start=true) # force the Sobol' sequence to skip to the lowest denominator in the sequence that can hold 15 points, i.e., choose from [1/32, 3/32, 5/32, ..., 31/32]\nSobolʼ(15; skip_start=false) # force the Sobol' sequence to start at the beginning, i.e. [0, 0.5, 0.25, 0.75, ...]\nSobolʼ(15; include_one=true) # force the Sobol' sequence to include 1 in the sequence\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTSensitivity/#Base.run-Tuple{pcvct.GSAMethod, Integer, InputFolders, Union{pcvct.AbstractVariation, Vector{<:pcvct.AbstractVariation}}}","page":"VCTSensitivity","title":"Base.run","text":"run(method::GSAMethod, args...; functions::Vector{<:Function}=Function[], kwargs...)\n\nRun a global sensitivity analysis method on the given arguments.\n\nArguments\n\nmethod::GSAMethod: the method to run. Options are MOAT, Sobolʼ, and RBD.\nn_replicates::Int: the number of replicates to run for each monad, i.e., at each sampled parameter vector.\ninputs::InputFolders: the input folders shared across all simuations to run.\navs::Vector{<:AbstractVariation}: the elementary variations to sample. These can be either DiscreteVariation's or DistributedVariation's.\n\nAlternatively, the third argument, inputs, can be replaced with a reference::AbstractMonad, i.e., a simulation or monad to be the reference. This should be preferred to setting reference variation IDs manually, i.e., if not using the base files in the input folders.\n\nKeyword Arguments\n\nThe reference_variation_id keyword argument is only compatible when the third argument is of type InputFolders. Otherwise, the reference simulation/monad will set the reference variation values.\n\nreference_variation_id::VariationID: the reference variation IDs as a VariationID\nignore_indices::Vector{Int}=[]: indices into avs to ignore when perturbing the parameters. Only used for Sobolʼ. See Sobolʼ for a use case.\nforce_recompile::Bool=false: whether to force recompilation of the simulation code\nprune_options::PruneOptions=PruneOptions(): the options for pruning the simulation results\nuse_previous::Bool=true: whether to use previous simulation results if they exist\nfunctions::Vector{<:Function}=Function[]: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTSensitivity/#pcvct.calculateGSA!-Tuple{pcvct.GSASampling, Vector{<:Function}}","page":"VCTSensitivity","title":"pcvct.calculateGSA!","text":"calculateGSA!(gsa_sampling::GSASampling, functions::Vector{<:Function})\n\nCalculate the sensitivity indices for the given functions.\n\nThis function is also used to compute the sensitivity indices for a single function:\n\ncalculateGSA!(gsa_sampling, f)\n\nArguments\n\ngsa_sampling::GSASampling: the sensitivity analysis to calculate the indices for.\nfunctions::Vector{<:Function}: the functions to calculate the sensitivity indices for. Each function must take a simulation ID as the singular input and return a real number.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTSensitivity/#pcvct.variationsToMonads-Tuple{InputFolders, Dict{Symbol, Matrix{Int64}}}","page":"VCTSensitivity","title":"pcvct.variationsToMonads","text":"variationsToMonads(inputs::InputFolders, variation_ids::Dict{Symbol,Matrix{Int}}, use_previous::Bool)\n\nReturn a dictionary of monads and a matrix of monad IDs based on the given variation IDs.\n\nThe five matrix inputs together define a single matrix of variation IDs. This information, together with the inputs, identifies the monads to be used. The use_previous flag determines whether to use previous simulations, if they exist.\n\nReturns\n\nmonad_dict::Dict{VariationID, Monad}: a dictionary of the monads to be used without duplicates.\nmonad_ids::Matrix{Int}: a matrix of the monad IDs to be used. Matches the shape of the input IDs matrices.\n\n\n\n\n\n","category":"method"},{"location":"man/sensitivity_analysis/#Sensitivity-analysis","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"pcvct supports some sensitivity analysis workflows. By using pcvct, you will have the opportunity to readily reuse previous simulations to perform and extend sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/#Supported-sensitivity-analysis-methods","page":"Sensitivity analysis","title":"Supported sensitivity analysis methods","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"pcvct currently supports three sensitivity analysis methods:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Morris One-At-A-Time (MOAT)\nSobol\nRandom Balance Design (RBD)","category":"page"},{"location":"man/sensitivity_analysis/#Morris-One-At-A-Time-(MOAT)","page":"Sensitivity analysis","title":"Morris One-At-A-Time (MOAT)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The Morris One-At-A-Time (MOAT) method gives an intuitive understanding of the sensitivity of a model to its parameters. What it lacks in theoretical grounding, it makes up for in speed and ease of use. In short, MOAT will sample parameter space at n points. From each point, it will vary each parameter one at a time and record the change in model output. Aggregating these changes, MOAT will quantify the sensitivity of the model to each parameter.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT uses a Latin Hypercube Sampling (LHS) to sample the parameter space. By default, it will use the centerpoint of each bin as the point to vary each parameter from. To pick a random point within the bin, set add_noise=true.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT furthermore uses an orthogonal LHS, if possible. If n=k^d for some integer k, then the LHS will be orthogonal. Here, n is the requested number of base points and d is the number of parameters varied. For example, if n=16 and d=4, then k=2 and the LHS will be orthogonal. To force pcvct to NOT use an orthogonal LHS, set orthogonalize=false.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the MOAT method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"MOAT() # will default to n=15\nMOAT(8) # set n=8\nMOAT(8; add_noise=true) # use a random point in the bin, not necessarily the center\nMOAT(8; orthogonalize=false) # do not use an orthogonal LHS (even if d=3, so k=2 would make an orthogonal LHS)","category":"page"},{"location":"man/sensitivity_analysis/#Sobol","page":"Sensitivity analysis","title":"Sobol","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The Sobol method is a more rigorous sensitivity analysis method, relying on the variance of the model output to quantify sensitivity. It relies on a Sobol sequence, a deterministic sequence of points that are evenly distributed in the unit hypercube. The important main feature of the Sobol sequence is that it is a low-discrepancy sequence, meaning that it fills the space very evenly. Thus, using such sequences can give a very good approximation of certain quantities (like integrals) with fewer points than a random sequence would require. The Sobol sequence is built around powers of 2, and so picking n=2^k (as well as ±1) will give the best results. See SobolVariation for more information on how pcvct will use the Sobol sequence to sample the parameter space and how you can control it.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"If the extremes of your distributions (where the CDF is 0 or 1) are non-physical, e.g., an unbounded normal distribution, then consider using n=2^k-1 to pick a subsequence that does not include the extremes. For example, if you choose n=7, then the Sobol sequence will be [0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875]. If you do want to include the extremes, consider using n=2^k+1. For example, if you choose n=9, then the Sobol sequence will be [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1].","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"You can also choose which method is used to compute the first and total order Sobol indices. For first order: the choices are :Sobol1993, :Jansen1999, and :Saltelli2010. Default is :Jansen1999. For total order: the choices are :Homma1996, :Jansen1999, and :Sobol2007. Default is :Jansen1999.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the Sobol method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Sobolʼ(9)\nSobolʼ(9; skip_start=true) # skip to the odd multiples of 1/32 (smallest one with at least 9)","category":"page"},{"location":"man/sensitivity_analysis/#Random-Balance-Design-(RBD)","page":"Sensitivity analysis","title":"Random Balance Design (RBD)","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The RBD method uses a random design matrix (similar to the Sobol method) and uses a Fourier transform (as in in the FAST method) to compute the sensitivity indices. It is much cheaper than Sobol, but only gives first order indices. Choosing n design points, RBD will run n monads. It will then rearrange the n output values so that each parameter in turn is varied along a sinusoid and computes the Fourier transforms to estimate the first order indices. By default, it looks up to the 6th harmonic, but you can control this with the num_harmonics keyword argument.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"By default, pcvct will make use of the Sobol sequence to pick the design points. It is best to pick n such that is differs from a power of 2 by at most 1, e.g. 7, 8, or 9. In this case, pcvct will actually use a half-period of a sinusoid when converting the design points into CDF space. Otherwise, pcvct will use random permuations of n uniformly spaced points in each parameter dimension and will use a full period of a sinusoid when converting the design points into CDF space.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"To use the RBD method, any of the following signatures can be used:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"RBD(9) # will use a Sobol sequence with elements chosen from 0:0.125:1\nRBD(32; use_sobol=false) # opt out of using the Sobol sequence\nRBD(22) # will use the first 22 elements of the Sobol sequence, including 0\nRBD(32; num_harmonics=4) # will look up to the 4th harmonic, instead of the default 6th","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"If you choose n=2^k - 1 or n=2^k + 1, then you will be well-positioned to increment k by one and rerun the RBD method to get more accurate results. The reason: pcvct will start from the start of the Sobol sequence to cover these n points, meaning runs will not need to be repeated. If n=2^k, then pcvct will choose the n odd multiples of 1/2^(k+1) from the Sobol sequence, which will not be used if k is incremented.","category":"page"},{"location":"man/sensitivity_analysis/#Setting-up-a-sensitivity-analysis","page":"Sensitivity analysis","title":"Setting up a sensitivity analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/#Simulation-inputs","page":"Sensitivity analysis","title":"Simulation inputs","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Having chosen a sensitivity analysis method, you must now choose the same set of inputs as required for a sampling. You will need:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"inputs::InputFolders containing the data/inputs/ folder info defining your model\nn_replicates::Integer for the number of replicates to run at each parameter vector to get average behavior\nevs::Vector{<:ElementaryVariation} to define the parameters to conduct the sensitivity analysis on and their ranges/distributions","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Unlike for (most) trials, the ElementaryVariation's you will want here are likely to be DistributedVariation's to allow for a continuum of parameter values to be tested. pcvct offers UniformDistributedVariation and NormalDistributedVariation as convenience functions to create these DistributedVariation's. You can also use any d::Distribution to create a DistributedVariation directly:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"dv = DistributedVariation(xml_path, d)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Currently, pcvct does not support defining relationships between parameters in any context. CoVariation's are a work-in-progress and will be a sibling of ElementaryVariation in the type tree.","category":"page"},{"location":"man/sensitivity_analysis/#Sensitivity-functions","page":"Sensitivity analysis","title":"Sensitivity functions","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"At the time of starting the sensitivity analysis, you can include any number of sensitivity functions to compute. They must take a single argument, the simulation ID (an Int64) and return a Number (or any type that Statistics.mean will accept a Vector of). For example, finalPopulationCount returns a dictionary of the final population counts of each cell type from a simulation ID. So, if you want to know the sensitivity of the final population count of cell type \"cancer\", you could define a function like:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"f(sim_id) = finalPopulationCount(sim_id)[\"cancer\"]","category":"page"},{"location":"man/sensitivity_analysis/#Running-the-analysis","page":"Sensitivity analysis","title":"Running the analysis","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Putting it all together, you can run this analysis:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"config_folder = \"default\"\ncustom_codes = \"default\"\ninputs = InputFolders(config_folder, custom_codes)\nn_replicates = 3\nevs = [NormalDistributedVariation([pcvct.apoptosisPath(\"cancer\"); \"rate\"], 1e-3, 1e-4; lb=0),\n       UniformDistributedVariation([pcvct.cyclePath(\"cancer\"); \"phase_durations\"; \"duration:index:0\"], 720, 2880)]\nmethod = MOAT(15)\nsensitivity_sampling = run(method, inputs, n_replicates, evs)","category":"page"},{"location":"man/sensitivity_analysis/#Post-processing","page":"Sensitivity analysis","title":"Post-processing","text":"","category":"section"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The object sensitivity_sampling is of type pcvct.GSASampling, meaning you can use pcvct.calculateGSA! to compute sensitivity analyses.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"f = simulation_id -> finalPopulationCount(simulation_id)[\"default\"] # count the final population of cell type \"default\"\ncalculateGSA!(sensitivity_sampling, f)","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"These results are stored in a Dict in the sensitivity_sampling object:","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"println(sensitivity_sampling.results[f])","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"The exact concrete type of sensitivity_sampling will depend on the method used. This, in turn, is used by calculateGSA! to determine how to compute the sensitivity indices.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"Likewise, the method will determine how the sensitivity scheme is saved After running the simulations, pcvct will print a CSV in the data/outputs/sampling/$(sampling) folder named based on the method. This can later be used to reload the GSASampling and continue doing analysis. Currently, this requires some ingenuity by the user. A future version of pcvct could provide convenience functions for simplifying this.","category":"page"},{"location":"man/sensitivity_analysis/","page":"Sensitivity analysis","title":"Sensitivity analysis","text":"using CSV, DataFrames\nsampling_id = 1 # for example\nmonad_ids_df = CSV.read(\"data/outputs/samplings/$(sampling_id)/moat_scheme.csv\", DataFrame) # if this was a MOAT scheme\nmoat_sampling = MOATSampling(Sampling(sampling_id), monad_ids_df, Dict{Function, GlobalSensitivity.MorrisResult}())","category":"page"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTConfiguration/#VCTConfiguration","page":"VCTConfiguration","title":"VCTConfiguration","text":"","category":"section"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Interface with the configuration file necessary for PhysiCell simulations.","category":"page"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Provide functionality for accessing and modifying elements in any XML, including the PhysiCell configuration file, XML rules file, combined intracellular XML file, XML IC cell file, and XML IC ECM file.","category":"page"},{"location":"lib/VCTConfiguration/","page":"VCTConfiguration","title":"VCTConfiguration","text":"Modules = [pcvct]\nPages = [\"VCTConfiguration.jl\"]","category":"page"},{"location":"lib/VCTConfiguration/#pcvct.createXMLFile-Tuple{Symbol, pcvct.AbstractMonad}","page":"VCTConfiguration","title":"pcvct.createXMLFile","text":"createXMLFile(location::Symbol, M::AbstractMonad)\n\nCreate XML file for the given location and variation_id in the given monad.\n\nThe file is placed in $(location)_variations and can be accessed from there to run the simulation(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTLoader/#VCTLoader","page":"VCTLoader","title":"VCTLoader","text":"","category":"section"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"Load PhysiCell data into useful forms for downstream analysis. This may be split off into its own module or even package eventually, likely with VCTAnalysis.jl.","category":"page"},{"location":"lib/VCTLoader/","page":"VCTLoader","title":"VCTLoader","text":"Modules = [pcvct]\nPages = [\"VCTLoader.jl\"]","category":"page"},{"location":"lib/VCTLoader/#pcvct.AgentID","page":"VCTLoader","title":"pcvct.AgentID","text":"AgentID\n\nA wrapper for the agent ID used in PhysiCell.\n\nThe purpose of this struct is to make it easier to interpret the data in the MetaGraphs loaded from PhysiCell. The MetaGraphs use Ints to index the vertices, which could cause confusion when looking at the mappings to the agent ID metadata if also using Ints.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTLoader/#pcvct.PhysiCellSequence","page":"VCTLoader","title":"pcvct.PhysiCellSequence","text":"PhysiCellSequence\n\nA sequence of PhysiCell snapshots.\n\nBy default, only the simulation ID, index, and time are recorded for each PhysiCellSnapshot in the sequence. To include any of cells, substrates, mesh, attachments, spring_attachments, or neighbors, pass in the corresponding keyword argument as true (see below).\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\nsnapshots::Vector{PhysiCellSnapshot}: A vector of PhysiCell snapshots.\ncell_type_to_name_dict::Dict{Int, String}: A dictionary mapping cell type IDs to cell type names.\nlabels::Vector{String}: A vector of cell data labels.\nsubstrate_names::Vector{String}: A vector of substrate names.\n\nExamples\n\nsequence = PhysiCellSequence(1; include_cells=true, include_substrates=true) # loads cell and substrate data for simulation ID 1\nsequence = PhysiCellSequence(simulation; include_attachments=true, include_spring_attachments=true) # loads attachment data for a Simulation object\nsequence = PhysiCellSequence(1; include_mesh=true, include_neighbors=true) # loads mesh and neighbor data for simulation ID 1\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTLoader/#pcvct.PhysiCellSnapshot","page":"VCTLoader","title":"pcvct.PhysiCellSnapshot","text":"PhysiCellSnapshot\n\nA single snapshot of a PhysiCell simulation.\n\nThe cells, substrates, and mesh fields may remain empty until they are needed for analysis.\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\nindex::Union{Int,Symbol}: The index of the snapshot. Can be an integer or a symbol (:initial or :final).\ntime::Float64: The time of the snapshot (in minutes).\ncells::DataFrame: A DataFrame containing cell data.\nsubstrates::DataFrame: A DataFrame containing substrate data.\nmesh::Dict{String, Vector{Float64}}: A dictionary containing mesh data.\nattachments::MetaGraph: A graph of cell attachment data with vertices labeled by cell IDs.\nspring_attachments::MetaGraph: A graph of spring attachment data with vertices labeled by cell IDs.\nneighbors::MetaGraph: A graph of cell neighbor data with vertices labeled by cell IDs.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTLoader/#pcvct.getCellDataSequence-Tuple{Integer, Vector{String}}","page":"VCTLoader","title":"pcvct.getCellDataSequence","text":"getCellDataSequence(simulation_id::Integer, labels::Vector{String}; include_dead::Bool=false, include_cell_type::Bool=false)\n\nReturn a dictionary where the keys are cell IDs from the PhysiCell simulation and the values are NamedTuples containing the time and the values of the specified labels for that cell. For scalar values, such as volume, the values are in a length N vector, where N is the number of snapshots in the simulation. In the case of a label that has multiple columns, such as position, the values are concatenated into a length(snapshots) x number of columns array.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation. Alternatively, can be a Simulation object or a PhysiCellSequence object.\nlabels::Vector{String}: The labels to extract from the cell data. If a label has multiple columns, such as position, the columns are concatenated into a single array. Alternatively, a single label string can be passed.\ninclude_dead::Bool=false: Whether to include dead cells in the data.\ninclude_cell_type::Bool=false: Whether to include the cell type name in the data. Equivalent to including \"cell_type_name\" in labels.\n\nExamples\n\ndata = getCellDataSequence(sequence, [\"position\", \"elapsed_time_in_phase\"]; include_dead=true, include_cell_type=true)\ndata[1] # the first cell's data\ndata[1].position # an Nx3 array of the cell's position over time\ndata[1].elapsed_time_in_phase # an Nx1 array of the cell's elapsed time in phase over time\ndata[1].cell_type_name # an Nx1 array of the cell type name of the first cell over time\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTMovie/#VCTMovie","page":"VCTMovie","title":"VCTMovie","text":"","category":"section"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"Make movies for simulations in the database.","category":"page"},{"location":"lib/VCTMovie/","page":"VCTMovie","title":"VCTMovie","text":"Modules = [pcvct]\nPages = [\"VCTMovie.jl\"]","category":"page"},{"location":"lib/VCTMovie/#pcvct.makeMovie-Tuple{Union{pcvct.AbstractTrial, pcvct.PCVCTOutput}}","page":"VCTMovie","title":"pcvct.makeMovie","text":"makeMovie(T::AbstractTrial)\n\nMake movies for all simulations in T, a simulation, monad, sampling, or trial.\n\nUses the PhysiCell Makefile to generate the movies. Deletes the JPEG files after the movie is generated.    \n\nPassing a single simulation ID into makeMovie will generate a movie for that simulation.\n\nExamples\n\nmakeMovie(123) # make a movie for simulation 123\nmakeMovie(sampling) # make movies for all simulations in sampling\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTVariations/#VCTVariations","page":"VCTVariations","title":"VCTVariations","text":"","category":"section"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"Vary parameters of the project.","category":"page"},{"location":"lib/VCTVariations/","page":"VCTVariations","title":"VCTVariations","text":"Modules = [pcvct]\nPages = [\"VCTVariations.jl\"]","category":"page"},{"location":"lib/VCTVariations/#pcvct.CoVariation","page":"VCTVariations","title":"pcvct.CoVariation","text":"CoVariation\n\nA co-variation of one or more variations.\n\nFields\n\nvariations::Vector{T}: The variations that make up the co-variation.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.DiscreteVariation","page":"VCTVariations","title":"pcvct.DiscreteVariation","text":"DiscreteVariation\n\nThe location, target, and values of a discrete variation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets_collection, :intracellular, :ic_cell, :ic_ecm. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\nvalues::Vector{T}: The values of the variation. The values are the possible values that the target can take on.\n\nA singleton value can be passed in place of values for convenience.\n\nExamples\n\njulia> dv = DiscreteVariation([\"overall\", \"max_time\"], [1440.0, 2880.0])\nDiscreteVariation (Float64):\n  location: config\n  target: overall/max_time\n  values: [1440.0, 2880.0]\n\nxml_path = [\"hypothesis_ruleset:name:default\",\"behavior:name:cycle entry\",\"decreasing_signals\",\"max_response\"]\nDiscreteVariation(xml_path, 0)\n# output\nDiscreteVariation (Int64):\n  location: rulesets_collection\n  target: hypothesis_ruleset:name:default/behavior:name:cycle entry/decreasing_signals/max_response\n  values: [0]\n\nxml_path = [\"cell_patches:name:default\",\"patch_collection:type:disc\",\"patch:ID:1\",\"x0\"]\nDiscreteVariation(xml_path, [0.0, 100.0])\n# output\nDiscreteVariation (Float64):\n  location: ic_cell\n  target: cell_patches:name:default/patch_collection:type:disc/patch:ID:1/x0\n  values: [0.0, 100.0]\n\n```jldoctest xmlpath = [\"layer:ID:2\", \"patch:ID:1\", \"density\"] DiscreteVariation(xmlpath, [0.1, 0.2])\n\noutput\n\nDistributedVariation:   location: ic_ecm   target: layer:ID:2/patch:ID:1/density   values: [0.1, 0.2]\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.DistributedVariation","page":"VCTVariations","title":"pcvct.DistributedVariation","text":"DistributedVariation\n\nThe location, target, and distribution of a distributed variation.\n\nAnalagousy to DiscreteVariation, instances of DistributedVariation can be initialized with a target (XML path) and a distribution (a distribution from the Distributions package). Alternatively, users can use the UniformDistributedVariation and NormalDistributedVariation functions to create instances of DistributedVariation.\n\nFields\n\nlocation::Symbol: The location of the variation. Can be :config, :rulesets_collection, :intracellular, :ic_cell, or :ic_ecm. The location is inferred from the target.\ntarget::XMLPath: The target of the variation. The target is a vector of strings that represent the XML path to the element being varied. See XMLPath for more information.\ndistribution::Distribution: The distribution of the variation.\nflip::Bool=false: Whether to flip the distribution, i.e., when asked for the iCDF of x, return the iCDF of 1-x. Useful for CoVariation's.\n\nExamples\n\nusing Distributions\nd = Uniform(1, 2)\nDistributedVariation([pcvct.apoptosisPath(\"default\"); \"death_rate\"], d)\n# output\nDistributedVariation:\n  location: config\n  target: cell_definitions/cell_definition:name:default/phenotype/death/model:code:100/death_rate\n  distribution: Distributions.Uniform{Float64}(a=1.0, b=2.0)\n\n```jldoctest using Distributions d = Uniform(1, 2) flip = true # the cdf on this variation will decrease from 1 to 0 as the value increases from 1 to 2 DistributedVariation([pcvct.necrosisPath(\"default\"); \"death_rate\"], d, flip)\n\noutput\n\nDistributedVariation (flipped):   location: config   target: celldefinitions/celldefinition:name:default/phenotype/death/model:code:101/death_rate   distribution: Distributions.Uniform{Float64}(a=1.0, b=2.0)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.GridVariation","page":"VCTVariations","title":"pcvct.GridVariation","text":"GridVariation\n\nA variation method that creates a grid of all possible combinations of the values of the variations.\n\nExamples\n\njulia> GridVariation() # the only method for GridVariation\nGridVariation()\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.LHSVariation","page":"VCTVariations","title":"pcvct.LHSVariation","text":"LHSVariation\n\nA variation method that creates a Latin Hypercube Sample of the values of the variations.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nExamples\n\njulia> LHSVariation(4) # set `n` and use default values for the rest\nLHSVariation(4, false, Random.TaskLocalRNG(), true)\n\nusing Random\nLHSVariation(; n=4, add_noise=true, rng=MersenneTwister(1234), orthogonalize=false)\n# output\nLHSVariation(4, true, MersenneTwister(1234), false)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.RBDVariation","page":"VCTVariations","title":"pcvct.RBDVariation","text":"RBDVariation\n\nA variation method that creates a Random Balance Design of the values of the variations.\n\nThis creates n sample points where the values in each dimension are uniformly distributed. By default, this will use Sobol sequences (see SobolVariation) to create the sample points. If use_sobol is false, it will use random permutations of uniformly spaced points for each dimension.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\nuse_sobol::Bool=true: Whether to use Sobol sequences to create the sample points.\n\nDo not set these next two fields unless you know what you are doing. Let pcvct compute them.\n\npow2_diff::Union{Missing, Int}=missing: The difference between n and the nearest power of 2. Missing means pcvct will compute it if using Sobol sequences.\nnum_cycles::Union{Missing, Int, Rational}=missing: The number of cycles to use in the Sobol sequence. Missing means pcvct will set it.\n\nExamples\n\njulia> pcvct.RBDVariation(4) # set `n` and use default values for the rest\npcvct.RBDVariation(4, Random.TaskLocalRNG(), true, 0, 1//2)\n\njulia> pcvct.RBDVariation(4; use_sobol=false) # use random permutations of uniformly spaced points\npcvct.RBDVariation(4, Random.TaskLocalRNG(), false, missing, 1//1)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.SobolVariation","page":"VCTVariations","title":"pcvct.SobolVariation","text":"SobolVariation\n\nA variation method that creates a Sobol sequence of the values of the variations.\n\nSee generateSobolCDFs for more information on how the Sobol sequence is generated based on n and the other fields.\n\nSee the GlobalSensitivity.jl package for more information on RandomizationMethod's to use.\n\nFields\n\nDefault values from constructors are shown.\n\nn::Int: The number of samples to take.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence.\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nExamples\n\njulia> SobolVariation(9) # set `n` and use default values for the rest; will use [0, 0.5, 0.25, 0.75, 0.125, 0.375, 0.625, 0.875, 1]\nSobolVariation(9, 1, QuasiMonteCarlo.NoRand(), missing, missing)\n\njulia> SobolVariation(15; skip_start=true) # use [0.5, 0.25, 0.75, ..., 1/16, 3/16, ..., 15/16]\nSobolVariation(15, 1, QuasiMonteCarlo.NoRand(), true, missing)\n\njulia> SobolVariation(4; include_one=true) # use [0, 0.5, 1] and one of [0.25, 0.75]\nSobolVariation(4, 1, QuasiMonteCarlo.NoRand(), missing, true)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.XMLPath","page":"VCTVariations","title":"pcvct.XMLPath","text":"XMLPath\n\nHold the XML path as a vector of strings.\n\nPhysiCell uses a : in names for signals/behaviors from cell custom data. For example, custom:sample is the default way to represent the sample custom data in a PhysiCell rule. pcvct uses : to indicate an attribute in an XML path and thus splits on : when looking for attribute values. To avoid this conflict, pcvct will internally replace custom:<name> and custom: <name> with custom <name>. Users should never have to think about this. Any pcvct function that uses XML paths will automatically handle this replacement.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTVariations/#pcvct.NormalDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"VCTVariations","title":"pcvct.NormalDistributedVariation","text":"NormalDistributedVariation(xml_path::Vector{<:AbstractString}, mu::T, sigma::T; lb::Real=-Inf, ub::Real=Inf) where {T<:Real}\n\nCreate a (possibly truncated) distributed variation with a normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.UniformDistributedVariation-Union{Tuple{T}, Tuple{Vector{<:AbstractString}, T, T}, Tuple{Vector{<:AbstractString}, T, T, Bool}} where T<:Real","page":"VCTVariations","title":"pcvct.UniformDistributedVariation","text":"UniformDistributedVariation(xml_path::Vector{<:AbstractString}, lb::T, ub::T) where {T<:Real}\n\nCreate a distributed variation with a uniform distribution.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addAttackRateVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"VCTVariations","title":"pcvct.addAttackRateVariationDimension!","text":"addAttackRateVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, target_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for the attack rate of a cell type against a target cell type.\n\nExamples:\n\naddAttackRateVariationDimension!(evs, \"immune\", \"cancer\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addCustomDataVariationDimension!-Tuple{Vector{<:ElementaryVariation}, String, String, Vector}","page":"VCTVariations","title":"pcvct.addCustomDataVariationDimension!","text":"addCustomDataVariationDimension!(evs::Vector{<:ElementaryVariation}, cell_definition::String, field_name::String, values::Vector{T} where T)\n\nPushes a variation onto evs for a custom data field of a cell type.\n\nExamples:\n\naddCustomDataVariationDimension!(evs, \"immune\", \"perforin\", [0.1, 0.2, 0.3])\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.addDomainVariationDimension!-Tuple{Vector{<:ElementaryVariation}, NamedTuple}","page":"VCTVariations","title":"pcvct.addDomainVariationDimension!","text":"addDomainVariationDimension!(evs::Vector{<:ElementaryVariation}, domain::NamedTuple)\n\nPushes variations onto evs for each domain boundary named in domain.\n\nThe names in domain can be flexibly named as long as they contain either min or max and one of x, y, or z (other than the the x in max). It is not required to include all three dimensions and their boundaries. The values for each boundary can be a single value or a vector of values.\n\nExamples:\n\n``` evs = ElementaryVariation[] addDomainVariationDimension!(evs, (xmin=-78, xmax=78, miny=-30, maxy=[30, 60], z_max=10))\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.generateLHSCDFs-Tuple{Int64, Int64}","page":"VCTVariations","title":"pcvct.generateLHSCDFs","text":"generateLHSCDFs(n::Int, d::Int[; add_noise::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG, orthogonalize::Bool=true])\n\nGenerate a Latin Hypercube Sample of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nadd_noise::Bool=false: Whether to add noise to the samples or have them be in the center of the bins.\nrng::AbstractRNG=Random.GLOBAL_RNG: The random number generator to use.\northogonalize::Bool=true: Whether to orthogonalize the samples, if possible. See https://en.wikipedia.org/wiki/Latinhypercubesampling#:~:text=In%20orthogonal%20sampling\n\nReturns\n\ncdfs::Matrix{Float64}: The CDFs for the samples. Each row is a sample and each column is a dimension (corresponding to a feature).\n\nExamples\n\ncdfs = pcvct.generateLHSCDFs(4, 2)\nsize(cdfs)\n# output\n(4, 2)\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTVariations/#pcvct.generateSobolCDFs-Tuple{Int64, Int64}","page":"VCTVariations","title":"pcvct.generateSobolCDFs","text":"generateSobolCDFs(n::Int, d::Int[; n_matrices::Int=1, randomization::RandomizationMethod=NoRand(), skip_start::Union{Missing, Bool, Int}=missing, include_one::Union{Missing, Bool}=missing)\n\nGenerate n_matrices Sobol sequences of the Cumulative Distribution Functions (CDFs) for n samples in d dimensions.\n\nThe subsequence of the Sobol sequence is chosen based on the value of n and the value of include_one. If it is one less than a power of 2, e.g. n=7, skip 0 and start from 0.5. Otherwise, it will always start from 0. If it is one more than a power of 2, e.g. n=9, include 1 (unless include_one is false).\n\nThe skip_start field can be used to control this by skipping the start of the sequence. If skip_start is true, skip to the smallest consecutive subsequence with the same denominator that has at least n elements. If skip_start is false, start from 0. If skip_start is an integer, skip that many elements in the sequence, .e.g., skip_start=1 skips 0 and starts at 0.5.\n\nIf you want to include 1 in the sequence, set include_one to true. If you want to exlude 1 (in the case of n=9, e.g.), set include_one to false.\n\nArguments\n\nn::Int: The number of samples to take.\nd::Int: The number of dimensions to sample.\nn_matrices::Int=1: The number of matrices to use in the Sobol sequence (effectively, the dimension of the sample is d x n_matrices).\nrandomization::RandomizationMethod=NoRand(): The randomization method to use on the deterministic Sobol sequence. See GlobalSensitivity.jl.\nskip_start::Union{Missing, Bool, Int}=missing: Whether to skip the start of the sequence. Missing means pcvct will choose the best option.\ninclude_one::Union{Missing, Bool}=missing: Whether to include 1 in the sequence. Missing means pcvct will choose the best option.\n\nReturns\n\ncdfs::Array{Float64, 3}: The CDFs for the samples. The first dimension is the features, the second dimension is the matrix, and the third dimension is the sample points.\n\nExamples\n\ncdfs = pcvct.generateSobolCDFs(11, 3)\nsize(cdfs)\n# output\n(3, 1, 11)\n\ncdfs = pcvct.generateSobolCDFs(7, 5; n_matrices=2)\nsize(cdfs)\n# output\n(5, 2, 7)\n\n\n\n\n\n","category":"method"},{"location":"man/known_limitations/#Known-limitations","page":"Known limitations","title":"Known limitations","text":"","category":"section"},{"location":"man/known_limitations/#Always-select-all-simulations-associated-with-a-Monad","page":"Known limitations","title":"Always select all simulations associated with a Monad","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"Anytime a group of simulation replicates (a Monad in pcvct internals) is requested, all simulations in that group are used, regardless of the value of n_replicates. If the number of simulations in the group is less than n_replicates, then additional simulations are run to reach n_replicates. Note: if use_previous=false, then n_replicates will be run regardless and the returned Monad will only have the newly-run simulations. If you do need an upper bound on the number of simulations in such a grouping, submit an issue. It is assumed that most, if not all use cases, will benefit from more simulations.","category":"page"},{"location":"man/known_limitations/#Initial-conditions-not-loaded-when-launching-PhysiCell-Studio-for-a-simulation.","page":"Known limitations","title":"Initial conditions not loaded when launching PhysiCell Studio for a simulation.","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"When launching PhysiCell Studio from pcvct, the initial conditions (cells and substrates) are not loaded.","category":"page"},{"location":"man/known_limitations/#Limited-intracellular-models","page":"Known limitations","title":"Limited intracellular models","text":"","category":"section"},{"location":"man/known_limitations/","page":"Known limitations","title":"Known limitations","text":"Currently only supports ODE intracellular models (using libRoadRunner). Does not support MaBoSS or dFBA.","category":"page"},{"location":"misc/database_upgrades/#Database-upgrades","page":"Database upgrades","title":"Database upgrades","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Over time, the database structure of pcvct will evolve to reflect new capabilities, features, and improvements. Not every release will change the database structure, but when one does in a way that could affect your workflow, pcvct will throw a warning. The warning will link to this page and the function will wait for user input to proceed. Changes are listed in reverse chronological order.","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.15","page":"Database upgrades","title":"to v0.0.15","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Introduce XML-based ECM initial conditions. This introduces ic_ecm_variations. Also, introduce Dirichlet initial conditions from file, which introduces the ic_dc_id in the database. For any simulations in the database before upgrading, both of these will be set to -1 (i.e., no initial conditions) except if  ic_ecm_id is not -1, in which case ic_ecm_variation_id will be set to 0 (i.e., the default ECM initial conditions which is all the original CSV version can handle).","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.10","page":"Database upgrades","title":"to v0.0.10","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Start tracking the PhysiCell version used in the simulation. This introduces the physicell_versions table which tracks the PhysiCell versions used in simulations. Currently, only supports reading the PhysiCell version, not setting it (e.g., through git commands). Key changes include:","category":"page"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Adding the physicell_version_id column to the simulations, monads, and samplings tables.\nAdding the physicell_versions table.\nIf PhysiCell is a git-tracked repo, this will store the commit hash as well as any tag and repo owner it can find based on the remotes. It will also store the date of the commit.\nIf PhysiCell is not a git-tracked repo, it will read the VERSION.txt file and store that as the commit_hash with -download appended to the version.","category":"page"},{"location":"misc/database_upgrades/#to-v0.0.3","page":"Database upgrades","title":"to v0.0.3","text":"","category":"section"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Introduce XML-based cell initial conditions. This introduces ic_cell_variations. Also, standardized the use of config_variation in place of variation. Key changes include:","category":"page"},{"location":"misc/database_upgrades/","page":"Database upgrades","title":"Database upgrades","text":"Renaming the variation_id column in the simulations and monads tables to config_variation_id.\nAdding the ic_cell_variation_id column to the simulations and monads tables.\nIn data/inputs/configs, renaming all instances of \"variation\" to \"config_variation\" in filenames and databases.","category":"page"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTDeletion/#VCTDeletion","page":"VCTDeletion","title":"VCTDeletion","text":"","category":"section"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"Safely delete output from a pcvct project.","category":"page"},{"location":"lib/VCTDeletion/","page":"VCTDeletion","title":"VCTDeletion","text":"Modules = [pcvct]\nPages = [\"VCTDeletion.jl\"]","category":"page"},{"location":"lib/VCTDeletion/#pcvct.deleteSimulations-Tuple{AbstractVector{<:Union{Missing, Integer}}}","page":"VCTDeletion","title":"pcvct.deleteSimulations","text":"deleteSimulations(simulation_ids::AbstractVector{<:Union{Integer,Missing}}; delete_supers::Bool=true, and_constraints::String=\"\")\n\nDeletes the simulations with the input IDs from the database and from the data/outputs/simulations folder.\n\nWorks with any vector of integers or a single integer. If delete_supers is true, it will also delete any monads, samplings, and trials that no longer have any simulations associated with them. It is recommended to leave this to true to keep the database clean. The and_constraints argument allows for additional SQLite conditions to be added to the WHERE clause of the SQLite query. Use this only after inspecting the simulations table in the data/vct.db database.     Note: deleteSimulation is an alias for deleteSimulations.\n\nExamples\n\ndeleteSimulations(1:3)\ndeleteSimulations(4)\ndeleteSimulations(1:100; and_constraints=\"AND config_id = 1\") # delete simulations with IDs 1 to 100 that have config_id = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDeletion/#pcvct.deleteSimulationsByStatus","page":"VCTDeletion","title":"pcvct.deleteSimulationsByStatus","text":"deleteSimulationsByStatus(status_codes_to_delete::Vector{String}=[\"Failed\"]; user_check::Bool=true)\n\nDelete simulations from the database based on their status codes.\n\nThe list of possible status codes is: \"Not Started\", \"Queued\", \"Running\", \"Completed\", \"Failed\".\n\nArguments\n\nstatus_codes_to_delete::Vector{String}: A vector of status codes for which simulations should be deleted. Default is [\"Failed\"].\nuser_check::Bool: If true, prompts the user for confirmation before deleting simulations. Default is true.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTDeletion/#pcvct.eraseSimulationID-Tuple{Int64}","page":"VCTDeletion","title":"pcvct.eraseSimulationID","text":"eraseSimulationID(simulation_id::Int[; monad_id::Union{Missing,Int}=missing])\n\nErase a simulation ID from the simulations.csv file of the monad it belongs to.\n\nIf monad_id is not provided, the function will infer it from the simulation ID. If the monad contains only the given simulation ID, the monad will be deleted. This is used when running simulations if they error so that the monads no longer rely on them, but the simulation output can still be checked.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDeletion/#pcvct.resetDatabase-Tuple{}","page":"VCTDeletion","title":"pcvct.resetDatabase","text":"resetDatabase()\n\nReset the database (after user confirmation) by deleting all simulations, monads, samplings, and trials.\n\nAll the base inputs files will be kept, so previously run scripts should still work as expected. If the user aborts the reset, the user will then be asked if they want to continue with the script.\n\nKeyword Arguments\n\nforce_reset::Bool: If true, skips the user confirmation prompt. Default is false.\nforce_continue::Bool: If true, skips the user confirmation prompt for continuing with the script after aborting the reset. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"man/best_practices/#Best-practices","page":"Best practices","title":"Best practices","text":"","category":"section"},{"location":"man/best_practices/#Do-NOT-manually-edit-files-inside-inputs.","page":"Best practices","title":"Do NOT manually edit files inside inputs.","text":"","category":"section"},{"location":"man/best_practices/","page":"Best practices","title":"Best practices","text":"If parameter values need to be changed, use variations as shown in VCT/GenerateData.jl. Let pcvct manage the databases that track simulation parameters.","category":"page"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTAnalysis/#VCTAnalysis","page":"VCTAnalysis","title":"VCTAnalysis","text":"","category":"section"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"Analyze output from a pcvct project. It is anticipated that this will eventually be split off into its own module or even package. Possibly with VCTLoader.jl.","category":"page"},{"location":"lib/VCTAnalysis/","page":"VCTAnalysis","title":"VCTAnalysis","text":"Modules = [pcvct]\nPages = [\"graphs.jl\", \"motility.jl\", \"pcf.jl\", \"population.jl\", \"preprocessing.jl\", \"substrate.jl\"]","category":"page"},{"location":"lib/VCTAnalysis/#pcvct.motilityStatistics-Tuple{Integer}","page":"VCTAnalysis","title":"pcvct.motilityStatistics","text":"motilityStatistics(simulation_id::Integer[; direction=:any])\n\nReturn the mean speed, distance traveled, and time alive for each cell in the simulation, broken down by cell type in the case of cell type transitions.\n\nThe time is counted from when the cell first appears in simulation output until it dies or the simulation ends, whichever comes first. If the cell transitions to a new cell type during the simulation, the time is counted for each cell type separately. Each cell type taken on by a given cell will be a key in the dictionary returned at that entry.\n\nArguments\n\nsimulation_id::Integer: The ID of the PhysiCell simulation.\ndirection::Symbol: The direction to compute the mean speed. Can be :x, :y, :z, or :any (default). If :x, for example, the mean speed is calculated using only the x component of the cell's movement.\n\nReturns\n\nVector{Dict{String, NamedTuple}}: A vector of dictionaries, one per cell in the simulation. Each dictionary has keys for each cell type taken on by the cell. The values are NamedTuples with fields :time, :distance, and :speed.\n\nExample\n\nms = motilityStatistics(1) # a vector of dictionaries, one per cell in the simulation\nms[1][\"epithelial\"] # NamedTuple with fields :time, :distance, :speed for the first cell in the simulation corresponding to its time as an `epithelial` cell\nms[1][\"mesenchymal\"].time # time spent as a `mesenchymal` cell for the first cell in the simulation\nms[1][\"mesenchymal\"].distance # distance traveled as a `mesenchymal` cell for the first cell in the simulation\nms[1][\"mesenchymal\"].speed # mean speed as a `mesenchymal` cell for the first cell in the simulation\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTAnalysis/#pcvct.PCVCTPCFResult","page":"VCTAnalysis","title":"pcvct.PCVCTPCFResult","text":"PCVCTPCFResult\n\nA struct to hold the results of the pair correlation function (PCF) calculation.\n\nThe start and end radii for each annulus are stored in the radii field. Thus, there is one more radius than there are annuli, i.e. length(radii) == size(g, 1) + 1. Each column of g corresponds to a time point in the time field, hence size(g, 2) == length(time).\n\nFields\n\ntime::Vector{Float64}: The time points at which the PCF was calculated.\npcf_result::PairCorrelationFunction.PCFResult: The result of the PCF calculation.\n\nExample\n\nusing pcvct, PairCorrelationFunction\ntime = 12.0\nradii = [0.0, 1.0, 2.0]\ng = [0.5, 1.2]\npcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))\n# output\nPCVCTPCFResult:\n  Time: 12.0\n  Radii: 0.0 - 2.0 with 2 annuli\n  g: 0.5 - 1.2 (min - max)\n\nusing pcvct, PairCorrelationFunction\ntime = [12.0; 24.0; 36.0]\nradii = [0.0, 1.0, 2.0]\ng = [0.5 0.6 0.4; 1.2 1.15 1.4]\npcvct.PCVCTPCFResult(time, PairCorrelationFunction.PCFResult(radii, g))\n# output\nPCVCTPCFResult:\n  Time: 12.0 - 36.0 (n = 3)\n  Radii: 0.0 - 2.0 with 2 annuli\n  g: 0.4 - 1.4 (min - max)\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#PairCorrelationFunction.pcf","page":"VCTAnalysis","title":"PairCorrelationFunction.pcf","text":"pcf(snapshot::PhysiCellSnapshot, center_cell_types, target_cell_types=center_cell_types; include_dead::Union{Bool,Tuple{Bool,Bool}}=false, dr::Float64=20.0)\n\nCalculate the pair correlation function (PCF) between two sets of cell types in a PhysiCell simulation snapshot.\n\nThe center_cell_types and target_cell_types can be strings or vectors of strings. This will compute one PCF rather than one for each pair of (center, target) cell types, i.e., all centers are compared to all targets. If omitted, the targetcelltypes will be the same as the centercelltypes, i.e., not a cross-PCF. The include_dead argument can be a boolean or a tuple of booleans to indicate whether to include the dead centers and/or targets, respectively. The dr argument specifies the bin size (thickness of each annulus) for the PCF calculation.\n\nArguments\n\nsnapshot::PhysiCellSnapshot: The snapshot of the PhysiCell simulation.\ncenter_cell_types: The cell type name(s) to use as the center of the PCF.\ntarget_cell_types: The cell type name(s) to use as the target of the PCF.\n\nKeyword Arguments\n\ninclude_dead::Union{Bool,Tuple{Bool,Bool}}: Whether to include dead cells in the PCF calculation. If a tuple, the first element indicates whether to include dead centers and the second element indicates whether to include dead targets.\ndr::Float64: The bin size for the PCF calculation.\n\nReturns\n\nPCVCTPCFResult: A struct containing the time, radii, and g values of the PCF.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#PairCorrelationFunction.pcf-2","page":"VCTAnalysis","title":"PairCorrelationFunction.pcf","text":"pcf(sequence::PhysiCellSequence, center_cell_types, target_cell_types=center_cell_types; kwargs...)\n\nCalculate the pair correlation function (PCF) across all snapshots in a PhysiCell simulation sequence.\n\nReturns\n\nPCVCTPCFResult: A struct containing the times, radii, and g values as a (length(radii)-1 x length(time)) matrix of the PCF.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#pcvct.MonadPopulationTimeSeries","page":"VCTAnalysis","title":"pcvct.MonadPopulationTimeSeries","text":"MonadPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a monad's population time series.\n\nNote: unlike SimulationPopulationTimeSeries, this type does not save the data to a file.\n\nExamples\n\nmpts = MonadPopulationTimeSeries(1)\nmpts = MonadPopulationTimeSeries(monad(1))\n\nFields\n\nmonad_id::Int: The ID of the monad.\nmonad_length::Int: The number of simulations in the monad.\ntime::Vector{Real}: The time points of the population time series.\ncell_count::Dict{String, NamedTuple}: A dictionary where keys are cell type names and values are NamedTuples with fields :counts, :mean, and :std.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#pcvct.SimulationPopulationTimeSeries","page":"VCTAnalysis","title":"pcvct.SimulationPopulationTimeSeries","text":"SimulationPopulationTimeSeries <: AbstractPopulationTimeSeries\n\nHolds the data for a simulation's population time series.\n\nIf constructed using a Simulation or an Integer (representing a simulation ID), it will save the time series inside the simulations/simulation_id/summary/ folder. It will also look for previously computed time series there to avoid recomputing them.\n\nExamples\n\nspts = SimulationPopulationTimeSeries(1) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(Simulation(1)) # first checks if the population time series is already computed and if not, computes it\nspts = SimulationPopulationTimeSeries(1; include_dead=true) # similar, but counts dead cells as well; the file name has \"_include_dead\" appended\n\nFields\n\nsimulation_id::Int: The ID of the simulation.\ntime::Vector{Real}: The time points of the population time series.\ncell_count::Dict{String, Vector{Integer}}: A dictionary where keys are cell type names and values are vectors of cell counts over time.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#pcvct.finalPopulationCount","page":"VCTAnalysis","title":"pcvct.finalPopulationCount","text":"finalPopulationCount(simulation::Simulation[; include_dead::Bool=false])\n\nReturn the final population count of a simulation as a dictionary with cell type names as keys and their counts as values.\n\nAlso works with the simulation ID:\n\nfpc = finalPopulationCount(1)\n\nExample\n\nfpc = finalPopulationCount(simulation)\nfinal_default_count = fpc[\"default\"]\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#pcvct.plotbycelltype","page":"VCTAnalysis","title":"pcvct.plotbycelltype","text":"plotbycelltype(T::AbstractTrial; include_dead::Bool=false, include_cell_types=:all, exclude_cell_types=String[])\n\nPlot the population time series of a trial by cell type.\n\nEach cell type gets its own subplot. Each monad gets its own series within each subplot.\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTAnalysis/#pcvct.populationTimeSeries-Tuple{pcvct.AbstractMonad}","page":"VCTAnalysis","title":"pcvct.populationTimeSeries","text":"populationTimeSeries(M::AbstractMonad[; include_dead::Bool=false])\n\nReturn the population time series of a simulation or a monad.\n\nSee SimulationPopulationTimeSeries and MonadPopulationTimeSeries for more details.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTAnalysis/#pcvct.AverageSubstrateTimeSeries","page":"VCTAnalysis","title":"pcvct.AverageSubstrateTimeSeries","text":"AverageSubstrateTimeSeries\n\nA struct to hold the average substrate concentrations over time for a PhysiCell simulation.\n\nFields\n\nsimulation_id::Int: The ID of the PhysiCell simulation.\ntime::Vector{Real}: The time points at which the snapshots were taken.\nsubstrate_concentrations::Dict{String, Vector{Real}}: A dictionary mapping substrate names to vectors of their average concentrations over time.\n\nExample\n\n```julia asts = AverageSubstrateTimeSeries(1) # Load average substrate time series for Simulation 1 asts.time # Get the time points asts[\"time\"] # alternative way to get the time points asts[\"oxygen\"] # Get the oxygen concentration over time\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTAnalysis/#pcvct.ExtracellularSubstrateTimeSeries","page":"VCTAnalysis","title":"pcvct.ExtracellularSubstrateTimeSeries","text":"ExtracellularSubstrateTimeSeries\n\nA struct to hold the mean extracellular substrate concentrations per cell type over time for a PhysiCell simulation.\n\nFields\n\nsimulation_id::Int: The ID of the PhysiCell simulation.\ntime::Vector{Real}: The time points at which the snapshots were taken.\ndata::Dict{String, Dict{String, Vector{Real}}}: A dictionary mapping cell type names to dictionaries mapping substrate names to vectors of their average concentrations over time.\n\nExample\n\nests = ExtracellularSubstrateTimeSeries(1) # Load extracellular substrate time series for Simulation 1\nests.time # Get the time points\nests[\"cancer\"][\"oxygen\"] # Get the oxygen concentration over time for the cancer cell type\n\nests = ExtracellularSubstrateTimeSeries(simulation; include_dead=true) # Load extracellular substrate time series for a Simulation object, including dead cells\nests[\"time\"] # Alternate way to get the time points\nests[\"cd8\"][\"IFNg\"] # Get the interferon gamma concentration over time for the CD8 cell type\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTDatabase/#VCTDatabase","page":"VCTDatabase","title":"VCTDatabase","text":"","category":"section"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"Create and manage the pcvct database.","category":"page"},{"location":"lib/VCTDatabase/","page":"VCTDatabase","title":"VCTDatabase","text":"Modules = [pcvct]\nPages = [\"VCTDatabase.jl\"]","category":"page"},{"location":"lib/VCTDatabase/#pcvct.isStarted-Tuple{Int64}","page":"VCTDatabase","title":"pcvct.isStarted","text":"isStarted(simulation_id::Int[; new_status_code::Union{Missing,String}=missing])\n\nCheck if a simulation has been started.\n\nIf new_status_code is provided, update the status of the simulation to this value. The check and status update are done in a transaction to ensure that the status is not changed by another process.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTDatabase/#pcvct.printSimulationsTable-Tuple","page":"VCTDatabase","title":"pcvct.printSimulationsTable","text":"printSimulationsTable()\n\nPrint a table of simulations and their varied values. See keyword arguments below for more control of the output.\n\nThere are many methods for this function. The simplest is printSimulationsTable(), which prints all simulations in the database. You can also pass in any number of simulations, monads, samplings, and trials to print a table of those simulations:\n\nprintSimulationsTable([simulation_1, monad_3, sampling_2, trial_1])\n\nFinally, a vector of simulation IDs can be passed in:\n\nprintSimulationsTable([1, 2, 3])\n\nKeyword arguments can be used with any of these methods to control the output:\n\nKeyword Arguments\n\nsink: A function to print the table. Defaults to println. Note, the table is a DataFrame, so you can also use CSV.write to write the table to a CSV file.\nremove_constants::Bool: If true, removes columns that have the same value for all simulations. Defaults to true.\nsort_by::Vector{String}: A vector of column names to sort the table by. Defaults to all columns. To populate this argument, first print the table to see the column names.\nsort_ignore::Vector{String}: A vector of column names to ignore when sorting. Defaults to the database IDs associated with the simulations.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTClasses/#VCTClasses","page":"VCTClasses","title":"VCTClasses","text":"","category":"section"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"Class definitions for the hierarchical structure connecting simulations to trials.","category":"page"},{"location":"lib/VCTClasses/","page":"VCTClasses","title":"VCTClasses","text":"Modules = [pcvct]\nPages = [\"VCTClasses.jl\"]","category":"page"},{"location":"lib/VCTClasses/#pcvct.InputFolder","page":"VCTClasses","title":"pcvct.InputFolder","text":"InputFolder\n\nHold the information for a single input folder.\n\nFields\n\nlocation::Symbol: The location of the input folder, e.g. :config, :custom_code, etc. Options are defined in data/inputs.toml.\nid::Int: The ID of the input folder in the database.\nfolder::String: The name of the input folder. It will be in data/inputs/<path_from_inputs>.\nbasename::Union{String,Missing}: The basename of the input file. This can be used to determine if the input file is varied.\nrequired::Bool: Whether the input folder is required. This is defined in data/inputs.toml.\nvaried::Bool: Whether the input folder is varied. This is determined by the presence of a varied basename in the input folder.\npath_from_inputs::String: The path from the data/inputs directory to the input folder. This is defined in data/inputs.toml.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.InputFolders","page":"VCTClasses","title":"pcvct.InputFolders","text":"InputFolders\n\nConsolidate the folder information for a simulation/monad/sampling.\n\nPass the folder names within the inputs/<path_from_inputs> directory to create an InputFolders object. The path_from_inputs is defined in the data/inputs.toml file for each. It is possible to acces the InputFolder values using index notation, e.g. input_folders[:config].\n\nSeveral constructors exist:\n\nAll folders passed as keyword arguments. Omitted folders are assumed to be \"\", i.e. those inputs are unused.\n\nInputFolders(; config=\"default\", custom_codes=\"default\", rulesets_collection=\"default\")\n\nPass in the required inputs as arguments and the optional inputs as keyword arguments. The required folders must be passed in alphabetical order.\n\nRefer to the names defined in data/inputs.toml to see this order. Omitted optional folders are assumed to be \"\", i.e. those inputs are unused.\n\nconfig_folder = \"default\"\ncustom_code_folder = \"default\"\nic_cell_folder = \"cells_in_disc\"\nInputFolders(config_folder, custom_code_folder; ic_cell=ic_cell_folder)\n\nFields\n\ninput_folders::NamedTuple: The input locations defined in data/inputs.toml define the keys. The values are InputFolders.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Monad","page":"VCTClasses","title":"pcvct.Monad","text":"Monad\n\nA group of simulations that are identical up to randomness.\n\nTo create a new monad, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations. Set n_replicates=0 to avoid adding new simulations to the database. This is useful for creating references for later use. Otherwise, set n_replicates > 1 to create the simulations to go with this monad. If n_replicates = 1, it will return a Simulation object.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nmonad = createTrial(inputs; n_replicates=0) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nmonad = createTrial(inputs, ev; n_replicates=10) # uses the config file with the specified variation\n\nmonad = createTrial(inputs, ev; n_replicates=10, use_previous=false) # changes the default behavior and creates 10 new simulations for this monad\n\nIf there is a previously created monad that you wish to access, you can use its ID to create a Monad object:\n\nmonad = Monad(monad_id)\nmonad = Monad(monad_id; n_replicates=5) # ensures at least 5 simulations in the monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this monad. Matches with the folder in data/outputs/monads/\ninputs::InputFolders: contains the folder info for this monad.\nvariation_id::VariationID: contains the variation IDs for this monad.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Sampling","page":"VCTClasses","title":"pcvct.Sampling","text":"Sampling\n\nA group of monads that have the same input folders, but differ in parameter values.\n\nTo create a new sampling, best practice is to use createTrial and supply it with the InputFolders and any number of DiscreteVariations. At least one should have multiple values to create a sampling.\n\ninputs = InputFolders(config_folder, custom_code_folder)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling = createTrial(inputs, ev; n_replicates=3, use_previous=true)\n\nIf there is a previously created sampling that you wish to access, you can use its ID to create a Sampling object:\n\nsampling = Sampling(sampling_id)\nsampling = Sampling(sampling_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this sampling. Matches with the folder in data/outputs/samplings/\ninputs::InputFolders: contains the folder info for this sampling.\nmonads::Vector{Monad}: array of monads belonging to this sampling.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Simulation","page":"VCTClasses","title":"pcvct.Simulation","text":"Simulation\n\nA simulation that represents a single run of the model.\n\nTo create a new simulation, best practice is to use createTrial and supply it with the InputFolders and any number of single-valued DiscreteVariations:\n\ninputs = InputFolders(config_folder, custom_code_folder)\nsimulation = createTrial(inputs) # uses the default config file as-is\n\nev = DiscreteVariation([\"overall\",\"max_time\"], 1440)\nsimulation = createTrial(inputs, ev) # uses the config file with the specified variation\n\nIf there is a previously created simulation that you wish to access, you can use its ID to create a Simulation object:\n\nsimulation = Simulation(simulation_id)\n\nFields\n\nid::Int: integer uniquely identifying this simulation. Matches with the folder in data/outputs/simulations/\ninputs::InputFolders: contains the folder info for this simulation.\nvariation_id::VariationID: contains the variation IDs for this simulation.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.Trial","page":"VCTClasses","title":"pcvct.Trial","text":"Trial\n\nA group of samplings that can have different input folders.\n\nTo create a new trial, best practice currently is to create a vector of Sampling objects and passing them to Trial.\n\ninputs_1 = InputFolders(config_folder_1, custom_code_folder_1)\ninputs_2 = InputFolders(config_folder_2, custom_code_folder_2)\nev = DiscreteVariation([\"overall\",\"max_time\"], [1440, 2880]))\nsampling_1 = createTrial(inputs_1, ev; n_replicates=3, use_previous=true)\nsampling_2 = createTrial(inputs_2, ev; n_replicates=3, use_previous=true)\ntrial = Trial([sampling_1, sampling_2])\n\nIf there is a previous trial that you wish to access, you can use its ID to create a Trial object:\n\ntrial = Trial(trial_id)\ntrial = Trial(trial_id; n_replicates=5) # ensures at least 5 simulations in each monad (using previous sims)\n\nFields\n\nid::Int: integer uniquely identifying this trial. Matches with the folder in data/outputs/trials/\ninputs::Vector{InputFolders}: contains the folder info for each sampling in this trial.\nvariation_ids::Vector{Vector{VariationID}}: contains the variation IDs for each monad in each sampling in this trial.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTClasses/#pcvct.VariationID","page":"VCTClasses","title":"pcvct.VariationID","text":"VariationID\n\nThe variation IDs for any of the possibly varying inputs.\n\nFor each input type that can be varied, a record of the current variation ID for that input type. By convention, a values of -1 indicates that the input is not being used (hence this is disallowed for a required input type). A value of 0 indicates that the base file is being used, unvaried. Hence, if the input type is sometimes varied (such as ic_cell with a cells.csv file), this value must be 0 in such conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTPruner/#VCTPruner","page":"VCTPruner","title":"VCTPruner","text":"","category":"section"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"Prune files from a simulation immediately after finishing the simulation.","category":"page"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"To motivate this functionality, consider the following scenario. A user has been testing their model, including making movies, and is ready to do a large virtual clinical trial with thousands of simulations. Saving all the SVGs will require gigabytes of storage, which is not ideal for the user. The user could choose to create a new variation on the SVG parameters (e.g., increase the SVG save interval), but then pcvct will not be able to reuse previous simulations as they have different variation IDs. Alternatively, the user can use the PruneOptions to delete the SVGs after each simulation is finished. This way, there are fewer variations in the database and more capability to reuse simulations.","category":"page"},{"location":"lib/VCTPruner/","page":"VCTPruner","title":"VCTPruner","text":"Modules = [pcvct]\nPages = [\"VCTPruner.jl\"]","category":"page"},{"location":"lib/VCTPruner/#pcvct.PruneOptions","page":"VCTPruner","title":"pcvct.PruneOptions","text":"PruneOptions\n\nAutomatically prune some of the generated output files from a simulation.\n\nFields\n\nprune_svg::Bool=false: Prune SVG files\nprune_txt::Bool=false: Prune TXT files\nprune_mat::Bool=false: Prune MAT files\nprune_initial::Bool=false: If any of the above are true, also prune the initial files for that type\nprune_final::Bool=false: If any of the above are true, also prune the final files for that type\n\n\n\n\n\n","category":"type"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTCompilation/#VCTCompilation","page":"VCTCompilation","title":"VCTCompilation","text":"","category":"section"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"Compile a PhysiCell project in pcvct. Includes the necessary compiler macros and checks PhysiCell version by the commit hash of the PhysiCell repository.","category":"page"},{"location":"lib/VCTCompilation/","page":"VCTCompilation","title":"VCTCompilation","text":"Modules = [pcvct]\nPages = [\"VCTCompilation.jl\"]","category":"page"},{"location":"lib/VCTCompilation/#pcvct.compilerFlags-Tuple{pcvct.AbstractSampling}","page":"VCTCompilation","title":"pcvct.compilerFlags","text":"compilerFlags(S::AbstractSampling)\n\nGenerate the compiler flags for the given sampling object S.\n\nGenerate the necessary compiler flags based on the system and the macros defined in the sampling object S. If the required macros differ from a previous compilation (as stored in macros.txt), then recompile.\n\nReturns\n\ncflags::String: The compiler flags as a string.\nrecompile::Bool: A boolean indicating whether recompilation is needed.\nclean::Bool: A boolean indicating whether cleaning is needed.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTCompilation/#pcvct.loadCustomCode-Tuple{pcvct.AbstractSampling}","page":"VCTCompilation","title":"pcvct.loadCustomCode","text":"loadCustomCode(S::AbstractSampling[; force_recompile::Bool=false])\n\nLoad and compile custom code for a simulation, monad, or sampling.\n\nDetermines if recompilation is necessary based on the previously used macros. If compilation is required, copy the PhysiCell directory to a temporary directory to avoid conflicts. Then, compile the project, recording the output and error in the custom_codes folder used. Move the compiled executable into the custom_codes folder and the temporary PhysiCell folder deleted.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTComponents/","page":"VCTComponents","title":"VCTComponents","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTComponents/#VCTComponents","page":"VCTComponents","title":"VCTComponents","text":"","category":"section"},{"location":"lib/VCTComponents/","page":"VCTComponents","title":"VCTComponents","text":"Allows for combining PhysiCell input components into whole inputs.","category":"page"},{"location":"lib/VCTComponents/","page":"VCTComponents","title":"VCTComponents","text":"Currently, only supports this for intracellular ODE (libRoadRunner) models.","category":"page"},{"location":"lib/VCTComponents/","page":"VCTComponents","title":"VCTComponents","text":"Modules = [pcvct]\nPages = [\"VCTComponents.jl\"]","category":"page"},{"location":"lib/VCTComponents/#pcvct.PhysiCellComponent","page":"VCTComponents","title":"pcvct.PhysiCellComponent","text":"PhysiCellComponent\n\nA struct to hold the information about a component that is used to assemble an input of PhysiCell.\n\nThe type and name are the only fields that are compared for equality. The type represents the type of component that it is. Currently, only \"roadrunner\" is supported. The name is the name of the file inside the components/type/ directory. The path_from_components is the path from the components directory to the file. The id is the id of the component, which will be -1 to indicate it is not yet set. The id is used to link which cell definition(s) use which component(s). \n\n\n\n\n\n","category":"type"},{"location":"man/developer_guide/#Developer-guide","page":"Developer guide","title":"Developer guide","text":"","category":"section"},{"location":"man/developer_guide/#Style-guide","page":"Developer guide","title":"Style guide","text":"","category":"section"},{"location":"man/developer_guide/","page":"Developer guide","title":"Developer guide","text":"Use #! for comments that are informative\nThis helps find code lines commented out in development.\nUsing the regexp ^(\\s+)?# .+\\n seems to work well for finding commented out code lines.","category":"page"},{"location":"man/data_directory/#Data-directory-structure","page":"Data directory","title":"Data directory structure","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"To set up your pcvct-enabled repository within project-dir (the name of your project directory), create the following directory structure:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"project-dir/\n├── data/\n│   └── inputs/\n│       ├── configs/\n│       ├── custom_codes/\n│       ├── ics/\n│       │   ├── cells/\n│       │   ├── dcs/\n│       │   ├── ecms/\n│       │   └── substrates/\n│       ├── intracellulars/\n│       ├── rulesets_collections/\n...","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Within each of the terminal subdirectories above within data/inputs/, add a subdirectory with a user-defined name with content described below. We will use the name \"default\" for all as an example.","category":"page"},{"location":"man/data_directory/#Configs","page":"Data directory","title":"Configs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/configs/default/ called PhysiCell_settings.xml with the base configuration file for your PhysiCell project.","category":"page"},{"location":"man/data_directory/#Custom-codes","page":"Data directory","title":"Custom codes","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add within data/inputs/custom_codes/default/ the following, each exactly as is used in a PhysiCell project:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"main.cpp\nMakefile\ncustom_modules/","category":"page"},{"location":"man/data_directory/#Rulesets-collections","page":"Data directory","title":"Rulesets collections","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single file within data/inputs/rulesets_collections/default/ called base_rulesets.csv with the base ruleset collection for your PhysiCell project. If your project does not use rules, you can skip this step.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"You may also place an XML file here. Use PhysiCellXMLRules.jl to create one from a standard CSV version of the rules.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Important: In either case, the variations you define must be on the XML version. After calling initializeModelManager(), any folder with base_rulesets.csv will now be populated with a base_rulesets.xml file that can be reference to set the XML paths.","category":"page"},{"location":"man/data_directory/#Intracellulars","page":"Data directory","title":"Intracellulars","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Add a single XML file within data/inputs/intracellulars/default/ called intracellular.xml in which the root has two child elements: cell_definitions and intracellulars. This currently only supports libRoadRunner, i.e., ODEs. See the sample_projects_intracellular/combined/template-combined for an example. See Intracellular inputs for much more information.","category":"page"},{"location":"man/data_directory/#ICs","page":"Data directory","title":"ICs","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"These folders are optional as not every model includes initial conditions as separate files. If your model does, for each initial condition add a subfolder. For example, if you have two initial cell position conditions, random_cells.csv and structured_cells.csv, the data/inputs/ics/cells/ directory would look like this:","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"cells/\n├── random_cells/\n│   └── cells.csv\n└── structured_cells/\n    └── cells.csv","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Note: Place the files in their corresponding folders and rename to cells.csv.","category":"page"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"Proceed similarly for dcs/, ecms/, and substrates/, renaming those files to dcs.csv, ecm.csv, and substrates.csv, respectively.","category":"page"},{"location":"man/data_directory/#IC-cells","page":"Data directory","title":"IC cells","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"pcvct uses PhysiCellCellCreator.jl to allow for creation of cells.csv files based on geometries defined in a cells.xml file. To use this, first create such an XML document (see PhysiCellCellCreator.jl for details) and place this in place of the cells.csv file. You may make variations on this in the same was as for config and rulesets_collection.","category":"page"},{"location":"man/data_directory/#IC-ecm","page":"Data directory","title":"IC ecm","text":"","category":"section"},{"location":"man/data_directory/","page":"Data directory","title":"Data directory","text":"pcvct uses PhysiCellECMCreator.jl to allow for creation of ecm.csv files based on the structure defined in a ecm.xml file. To use this, first create such an XML document (see PhysiCellECMCreator.jl for details) and place this in place of the ecm.csv file. You may make variations on this in the same was as for config and rulesets_collection.","category":"page"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTPhysiCellStudio/#VCTPhysiCellStudio","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"","category":"section"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"Launch PhysiCell Studio for a simulation run in pcvct.","category":"page"},{"location":"lib/VCTPhysiCellStudio/","page":"VCTPhysiCellStudio","title":"VCTPhysiCellStudio","text":"Modules = [pcvct]\nPages = [\"VCTPhysiCellStudio.jl\"]","category":"page"},{"location":"lib/VCTPhysiCellStudio/#pcvct.runStudio-Tuple{Int64}","page":"VCTPhysiCellStudio","title":"pcvct.runStudio","text":"runStudio(simulation_id::Int; python_path::Union{Missing,String}=path_to_python, studio_path::Union{Missing,String}=path_to_studio)\n\nLaunch PhysiCell Studio for a given simulation.\n\nCreates temporary config and rules files to avoid overwriting the original files in the output folder. The intent of this function is to allow users to visualize the results of a simulation with Studio, rather than to modify the simulation itself.\n\nThe path to the python executable and the Studio folder must be set. pcvct will look for these in the environment variables PCVCT_PYTHON_PATH and PCVCT_STUDIO_PATH, respectively.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = pcvct","category":"page"},{"location":"#pcvct","page":"Home","title":"pcvct","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The pcvct (PhysiCell Virtual Clinical Trials) package is a Julia package that provides a framework for running virtual clinical trials using PhysiCell simulations. See Getting started for getting pcvct set up and running.","category":"page"},{"location":"#Issues","page":"Home","title":"Issues","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Have an issue? First check the Known limitations and Best practices sections. If you still have an issue, please submit it here.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTUserAPI/#VCTUserAPI","page":"VCTUserAPI","title":"VCTUserAPI","text":"","category":"section"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"Main functions users will use to create and run simulations, monads, samplings, and trials.","category":"page"},{"location":"lib/VCTUserAPI/","page":"VCTUserAPI","title":"VCTUserAPI","text":"Modules = [pcvct]\nPages = [\"VCTUserAPI.jl\"]","category":"page"},{"location":"lib/VCTUserAPI/#Base.run-Tuple{pcvct.AddVariationMethod, Vararg{Any}}","page":"VCTUserAPI","title":"Base.run","text":"run(args...; force_recompile::Bool=false, prune_options::PruneOptions=PruneOptions(), kwargs...)\n\nRun a simulation, monad, sampling, or trial with the same signatures available to createTrial.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTUserAPI/#pcvct.createTrial","page":"VCTUserAPI","title":"pcvct.createTrial","text":"createTrial([method=GridVariation()], inputs::InputFolders, avs::Vector{<:AbstractVariation}=AbstractVariation[];\n            n_replicates::Integer=1, use_previous::Bool=true)\n\nReturn an object of type <:AbstractTrial (simulation, monad, sampling, trial) with the given input folders and elementary variations.\n\nUses the avs and n_replicates to determine whether to create a simulation, monad, or sampling. Despite its name, trials cannot yet be created by this function. If n_replicates is 0, and each variation has a single value, a simulation will be created.\n\nBy default, the method is GridVariation(), which creates a grid of variations from the vector avs. Other methods are: LHSVariation, SobolVariation, and RBDVariation.\n\nAlternate forms (all work with the optional method argument in the first position): Only supplying a single AbstractVariation:\n\ncreateTrial(inputs::InputFolders, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nUsing a reference simulation or monad:\n\ncreateTrial(reference::AbstractMonad, avs::Vector{<:AbstractVariation}=AbstractVariation[]; n_replicates::Integer=1,\n            use_previous::Bool=true)\n\ncreateTrial(reference::AbstractMonad, av::AbstractVariation; n_replicates::Integer=1, use_previous::Bool=true)\n\nExamples\n\ninputs = InputFolders(config_folder, custom_code_folder)\ndv_max_time = DiscreteVariation([\"overall\", \"max_time\"], 1440)\ndv_apoptosis = DiscreteVariation([pcvct.apoptosisPath(cell_type); \"rate\"], [1e-6, 1e-5])\nsimulation = createTrial(inputs, dv_max_time)\nmonad = createTrial(inputs, dv_max_time; n_replicates=2)\nsampling = createTrial(monad, dv_apoptosis; n_replicates=2) # uses the max time defined for monad\n\n\n\n\n\n","category":"function"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/VCTModule/#VCTModule","page":"VCTModule","title":"VCTModule","text":"","category":"section"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"Core functionality for pcvct.","category":"page"},{"location":"lib/VCTModule/","page":"VCTModule","title":"VCTModule","text":"Modules = [pcvct]\nPages = [\"VCTModule.jl\"]","category":"page"},{"location":"lib/VCTModule/#pcvct.getSimulationIDs-Tuple{}","page":"VCTModule","title":"pcvct.getSimulationIDs","text":"getSimulationIDs()\n\nReturn a vector of all simulation IDs in the database.\n\nAlternate forms take a simulation, monad, sampling, or trial object (or an array of any combination of them) and return the corresponding simulation IDs.\n\nExamples\n\ngetSimulationIDs() # all simulation IDs in the database\ngetSimulationIDs(simulation) # just a vector with the simulation ID, i.e. [simulation.id]\ngetSimulationIDs(monad) # all simulation IDs in a monad\ngetSimulationIDs(sampling) # all simulation IDs in a sampling\ngetSimulationIDs(trial) # all simulation IDs in a trial\ngetSimulationIDs([trial1, trial2]) # all simulation IDs between trial1 and trial2\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.initializeModelManager-Tuple{String, String}","page":"VCTModule","title":"pcvct.initializeModelManager","text":"initializeModelManager(path_to_physicell::String, path_to_data::String)\n\nInitialize the VCT environment by setting the paths to PhysiCell and data directories, and initializing the database.\n\nArguments\n\npath_to_physicell::String: Path to the PhysiCell directory as either an absolute or relative path.\npath_to_data::String: Path to the data directory as either an absolute or relative path.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.pcvctLogo-Tuple{}","page":"VCTModule","title":"pcvct.pcvctLogo","text":"pcvctLogo()\n\nReturn a string representation of the awesome pcvct logo.\n\n\n\n\n\n","category":"method"},{"location":"lib/VCTModule/#pcvct.setNumberOfParallelSims-Tuple{Int64}","page":"VCTModule","title":"pcvct.setNumberOfParallelSims","text":"setNumberOfParallelSims(n::Int)\n\nSet the maximum number of parallel simulations to n.\n\n\n\n\n\n","category":"method"}]
}
